// AUTOGENERATED CODE.  DO NOT MODIFY DIRECTLY!  Instead, please modify the visualization/AbstractVisualization.ftl file.
// See the README in the module's src/template directory for details.
package com.linkedin.dagli.visualization;

import com.linkedin.dagli.util.cloneable.AbstractCloneable;
import com.linkedin.dagli.util.collection.LinkedStack;
import com.linkedin.dagli.util.function.Function1;
import com.linkedin.dagli.util.named.Named;
import com.linkedin.dagli.objectio.ObjectReader;
import com.linkedin.dagli.transformer.PreparableTransformer1;
import com.linkedin.dagli.transformer.PreparedTransformer1;
import com.linkedin.dagli.transformer.Transformer1;
import com.linkedin.dagli.transformer.PreparableTransformer2;
import com.linkedin.dagli.transformer.PreparedTransformer2;
import com.linkedin.dagli.transformer.Transformer2;
import com.linkedin.dagli.transformer.PreparableTransformer3;
import com.linkedin.dagli.transformer.PreparedTransformer3;
import com.linkedin.dagli.transformer.Transformer3;
import com.linkedin.dagli.transformer.PreparableTransformer4;
import com.linkedin.dagli.transformer.PreparedTransformer4;
import com.linkedin.dagli.transformer.Transformer4;
import com.linkedin.dagli.transformer.PreparableTransformer5;
import com.linkedin.dagli.transformer.PreparedTransformer5;
import com.linkedin.dagli.transformer.Transformer5;
import com.linkedin.dagli.transformer.PreparableTransformer6;
import com.linkedin.dagli.transformer.PreparedTransformer6;
import com.linkedin.dagli.transformer.Transformer6;
import com.linkedin.dagli.transformer.PreparableTransformer7;
import com.linkedin.dagli.transformer.PreparedTransformer7;
import com.linkedin.dagli.transformer.Transformer7;
import com.linkedin.dagli.transformer.PreparableTransformer8;
import com.linkedin.dagli.transformer.PreparedTransformer8;
import com.linkedin.dagli.transformer.Transformer8;
import com.linkedin.dagli.transformer.PreparableTransformer9;
import com.linkedin.dagli.transformer.PreparedTransformer9;
import com.linkedin.dagli.transformer.Transformer9;
import com.linkedin.dagli.transformer.PreparableTransformer10;
import com.linkedin.dagli.transformer.PreparedTransformer10;
import com.linkedin.dagli.transformer.Transformer10;
import com.linkedin.dagli.dag.DAG;
import com.linkedin.dagli.dag.DAGTransformer;
import com.linkedin.dagli.dag.Graph;
import com.linkedin.dagli.dag.PreparableDAGTransformer;
import com.linkedin.dagli.placeholder.Placeholder;
import com.linkedin.dagli.producer.Producer;
import java.util.function.LongPredicate;
import java.util.stream.Collectors;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Map;
import java.util.Objects;


/**
 * Base class for DAG visualizers, which render a DAG into a (typically human readable) format for documentation and
 * debugging purposes.
 *
 * In addition to the directed acyclic graph of producers, visualizers may also support rendering example data (input,
 * intermediate and output values) as well as <i>subgraphs</i>, which provide a more detailed breakdown of producers
 * (e.g. the architecture of a neural network model).
 *
 * Derived classes just need to implement {@link #render(Graph, List)}.  Visualizers are not required to render all
 * available information (e.g. if unsupported or if rendering everything would mangle the visualization).
 *
 * @param <T> the type of the rendered visualization (e.g. a String or a Bitmap)
 * @param <S> the derived type of visualizer
  */
public abstract class AbstractVisualization<T, S extends AbstractVisualization<T, S>> extends AbstractCloneable<S> {
  private static final long serialVersionUID = 1;

  private Function1.Serializable<Producer<?>, String> _producerToStringFunction = Function1
      .safelySerializable(Producer::getShortName);
  private Function1.Serializable<Object, String> _valueToStringFunction = Function1
      .safelySerializable(Named::getShortName);
  private Function1.Serializable<Object, String> _subgraphNodeToStringFunction = Function1
      .safelySerializable(Named::getShortName);
  private int _maxProducerStringLength = 100;
  private int _maxValueStringLength = 100;
  private int _maxSubgraphNodeStringLength = 100;

  /**
   * Renders a DAG (expressed as a {@link Graph}).
   *
   * This is the only method that derived classes need to implement.
   *
   * @param graph the DAG to be rendered
   * @param producerOutputs a (possibly empty) list of maps, each corresponding to a distinct example, that provide the
   *                        output value for each producer for that example; there is no requirement that outputs for
   *                        all producers must be provided, and there may be extraneous producers present that are not
   *                        part of the DAG
   * @return the rendered DAG
   */
  protected abstract T render(Graph<Producer<?>> graph, List<Map<Producer<?>, Object>> producerOutputs);

  /**
   * Renders a DAG (expressed as a {@link Graph}).
   *
   * @param graph the DAG to be rendered
   * @return the rendered DAG
   */
  public T render(Graph<Producer<?>> graph) {
    return render(graph, Collections.emptyList());
  }

  /**
   * Renders a DAG.
   *
   * @param dag the DAG to be rendered
   * @return the rendered DAG
   */
  public T render(DAGTransformer<?, ?> dag) {
    return render(dag.graph(), Collections.emptyList());
  }

  /**
   * Truncates a String to a maximum length of logical characters (code points).
   *
   * @param string the string that may be truncated if it is indeed longer than the maximum length
   * @param maxLength the maximum length
   * @return the possibly-truncated string, with an added ellipsis ("...") if it was indeed truncated
   */
  private static String truncateToLogicalChars(String string, int maxLength) {
    // get the logical length (in code points)
    return (string.codePointCount(0, string.length()) <= maxLength) ? string : string.substring(0,
        string.offsetByCodePoints(0, Math.max(0, maxLength - 2)))
        + "...";
  }

  /**
   * @param producer the producer to "render"
   * @return the String representation for the provided {@link Producer}
   */
  protected String renderProducerAsString(Producer<?> producer) {
    return truncateToLogicalChars(_producerToStringFunction.apply(producer), _maxProducerStringLength);
  }

  /**
   * @param value the value to "render"
   * @return the String representation for the provided value
   */
  protected String renderValueAsString(Object value) {
    return truncateToLogicalChars(_valueToStringFunction.apply(value), _maxValueStringLength);
  }

  /**
   * @param node a node from a subgraph that should be "rendered" into a String; subgraph nodes may be of any type
   * @return the String representation for the provided graph node
   */
  protected String renderSubgraphNodeAsString(Object node) {
    return truncateToLogicalChars(_subgraphNodeToStringFunction.apply(node), _maxSubgraphNodeStringLength);
  }

  /**
   * Returns a copy of this instance that will restrict the maximum length of the producer's rendered string description
   * to the specified number of (logical) characters, applying an ellipsis (...) to the end when truncation occurs.  The
   * actual number of displayed characters may still be less due to limits of the visualization medium, however.
   *
   * The default maximum is 100.
   *
   * @param maxLength the maximum number of logical characters to render
   * @return a copy of this instance that will restrict the maximum length of the producer's rendered string description
   */
  public S withMaxProducerStringLength(int maxLength) {
    return clone(c -> ((AbstractVisualization<?, ?>) c)._maxProducerStringLength = maxLength);
  }

  /**
   * Returns a copy of this instance that will restrict the maximum length of each input, intermediate and output
   * value's interpretation as a string to the specified number of (logical) characters, applying an ellipsis (...) to
   * the end when truncation occurs.  The actual number of displayed characters may still be less due to limits of the
   * visualization medium, however.
   *
   * The default maximum is 100.
   *
   * @param maxLength the maximum number of logical characters to render
   * @return a copy of this instance that will restrict the maximum length of the string interpretation of each value
   */
  public S withMaxValueStringLength(int maxLength) {
    return clone(c -> ((AbstractVisualization<?, ?>) c)._maxValueStringLength = maxLength);
  }

  /**
   * Returns a copy of this instance that will restrict the maximum length of each subgraph node's String representation
   * in the rendered visualization to the specified number of (logical) characters, applying an ellipsis (...) to
   * the end when truncation occurs.  The actual number of displayed characters may still be less due to limits of the
   * visualization medium, however.
   *
   * The default maximum is 100.
   *
   * @param maxLength the maximum number of logical characters to render
   * @return a copy of this instance that will restrict the maximum length of the string interpretation of each subgraph
   *         node
   */
  public S withMaxSubgraphNodeStringLength(int maxLength) {
    return clone(c -> ((AbstractVisualization<?, ?>) c)._maxSubgraphNodeStringLength = maxLength);
  }

  /**
   * Creates and returns a copy of this visualizer that will use the specified function to obtain a String
   * representation from each {@link Producer} in the graph.  The default function is {@link Producer#getShortName()}.
   *
   * @param function the Producer-to-String mapping function
   * @return a copy of this visualizer that will use the specified Producer-to-String function
   */
  public S withProducerToStringFunction(Function1.Serializable<Producer<?>, String> function) {
    return clone(c -> ((AbstractVisualization<?, ?>) c)._producerToStringFunction = function);
  }

  /**
   * Creates and returns a copy of this visualizer that will use the specified function to obtain a String
   * representation for example data (input, intermediate and output values).  The default function is
   * {@link Named#getShortName(Object)}.
   *
   * @param function the value-to-String mapping function
   * @return a copy of this visualizer that will use the specified value-to-String function
   */
  public S withValueToStringFunction(Function1.Serializable<Object, String> function) {
    return clone(c -> ((AbstractVisualization<?, ?>) c)._valueToStringFunction = function);
  }

  /**
   * Creates and returns a copy of this visualizer that will use the specified function to obtain a String
   * representation for each subgraph node.  The default function is {@link Named#getShortName(Object)}.
   *
   * @param function the subgraph-node-to-String mapping function
   * @return a copy of this visualizer that will use the specified subgraph-node-to-String function
   */
  public S withSubgraphNodeToStringFunction(Function1.Serializable<Object, String> function) {
    return clone(c -> ((AbstractVisualization<?, ?>) c)._subgraphNodeToStringFunction = function);
  }

  /**
   * Given a {@link Graph} (such as that from a DAG class, e.g. DAG3x2), returns an object that is a rendered
   * visualization of that graph.
   *
   * In addition to the graph, the input, intermediate and output values for a single example (whose placeholder values
   * are provided as arguments) will be rendered as part of the graph.
   *
   * @param value1 the example's value for the first {@link Placeholder} in the DAG.
   * @param dag a DAG or other transformer to render; if a (non-DAG) transformer is provided, it is rendered as a DAG
   *        containing that transformer as its sole output and automatically-generated placeholders.
   * @return the rendered graph
   */
  public <A, R> T render(Transformer1<A, R> dag, A value1) {
    return render(dag, ObjectReader.singleton(value1));
  }

  /**
   * Given a {@link Graph} (such as that from a DAG class, e.g. DAG3x2), returns an object that is a rendered
   * visualization of that graph.
   *
   * The inputs to this method take the form of parallel sequences of values.  Each sequence will provide the values
   * for a particular {@link Placeholder} in the DAG (the ordering of the {@link Placeholder}s in a DAG is determined
   * by their ordering in the call to "DAG.withPlaceholders(...)...." that created it).  They are "parallel" because,
   * e.g. all the values corresponding to the fourth example will be the fourth value in their respective input
   * sequences (all sequences must, of course, be equal in size).
   *
   * Only the first example will have its input, intermediate and output values rendered.
   *
   * @param values1 the sequence of values for the first {@link Placeholder} in the DAG.
   * @param dag a DAG or other transformer to render; if a (non-DAG) transformer is provided, it is rendered as a DAG
   *        containing that transformer as its sole output and automatically-generated placeholders.
   * @return the rendered graph
   */
  public <A, R> T render(Transformer1<A, R> dag, Iterable<? extends A> values1) {
    return render(dag, index -> index == 0, values1);
  }

  /**
   * Given a {@link Graph} (such as that from a DAG class, e.g. DAG3x2), returns an object that is a rendered
   * visualization of that graph.
   *
   * The inputs to this method take the form of parallel sequences of values.  Each sequence will provide the values
   * for a particular {@link Placeholder} in the DAG (the ordering of the {@link Placeholder}s in a DAG is determined
   * by their ordering in the call to "DAG.withPlaceholders(...)...." that created it).  They are "parallel" because,
   * e.g. all the values corresponding to the fourth example will be the fourth value in their respective input
   * sequences (all sequences must, of course, be equal in size).
   *
   * @param renderExampleValuesPredicate a predicate that returns true when passed an example index iff that example's
   *        input, intermediate and output values should be included as part of rendered graph
   * @param values1 the sequence of values for the first {@link Placeholder} in the DAG.
   * @param dag a DAG or other transformer to render; if a (non-DAG) transformer is provided, it is rendered as a DAG
   *        containing that transformer as its sole output and automatically-generated placeholders.
   * @return the rendered graph
   */
  public <A, R> T render(Transformer1<A, R> dag, LongPredicate renderExampleValuesPredicate,
      Iterable<? extends A> values1) {
    // make sure we have a DAG
    DAGTransformer<R, ?> dagTransformer =
        dag instanceof PreparableTransformer1 ? PreparableTransformer1.toDAG((PreparableTransformer1<A, R, ?>) dag)
            : PreparedTransformer1.toDAG((PreparedTransformer1<A, R>) dag);

    ProducerToValueMap producerToValueMap =
        new ProducerToValueMap(dagTransformer.producers().map(LinkedStack::peek).collect(Collectors.toList()),
            renderExampleValuesPredicate);

    // we shouldn't really have to cast to (Placeholder<?>), but the compiler is most insistent
    List<Placeholder<?>> placeholders =
        dagTransformer.producers(Placeholder.class).map(LinkedStack::peek).map(p -> (Placeholder<?>) p)
            .collect(Collectors.toList());

    // execute the DAG to collect producer output values
    @SuppressWarnings("unchecked")
    final List<Map<Producer<?>, Object>> mapList =
        new ArrayList<>((dagTransformer instanceof PreparableDAGTransformer) ? DAG
            .withPlaceholders((Placeholder<A>) placeholders.get(0)).withOutput(producerToValueMap)
            .prepareAndApply(values1).toCollection() : DAG.Prepared
            .withPlaceholders((Placeholder<A>) placeholders.get(0)).withOutput(producerToValueMap).applyAll(values1)
            .toCollection());

    // filter any empty maps (corresponding to examples that were not selected by the render example predicate)
    mapList.removeIf(Objects::isNull);

    return render(dagTransformer.graph(), mapList);
  }

  /**
   * Given a {@link Graph} (such as that from a DAG class, e.g. DAG3x2), returns an object that is a rendered
   * visualization of that graph.
   *
   * In addition to the graph, the input, intermediate and output values for a single example (whose placeholder values
   * are provided as arguments) will be rendered as part of the graph.
   *
   * @param value1 the example's value for the first {@link Placeholder} in the DAG.
   * @param value2 the example's value for the second {@link Placeholder} in the DAG.
   * @param dag a DAG or other transformer to render; if a (non-DAG) transformer is provided, it is rendered as a DAG
   *        containing that transformer as its sole output and automatically-generated placeholders.
   * @return the rendered graph
   */
  public <A, B, R> T render(Transformer2<A, B, R> dag, A value1, B value2) {
    return render(dag, ObjectReader.singleton(value1), ObjectReader.singleton(value2));
  }

  /**
   * Given a {@link Graph} (such as that from a DAG class, e.g. DAG3x2), returns an object that is a rendered
   * visualization of that graph.
   *
   * The inputs to this method take the form of parallel sequences of values.  Each sequence will provide the values
   * for a particular {@link Placeholder} in the DAG (the ordering of the {@link Placeholder}s in a DAG is determined
   * by their ordering in the call to "DAG.withPlaceholders(...)...." that created it).  They are "parallel" because,
   * e.g. all the values corresponding to the fourth example will be the fourth value in their respective input
   * sequences (all sequences must, of course, be equal in size).
   *
   * Only the first example will have its input, intermediate and output values rendered.
   *
   * @param values1 the sequence of values for the first {@link Placeholder} in the DAG.
   * @param values2 the sequence of values for the second {@link Placeholder} in the DAG.
   * @param dag a DAG or other transformer to render; if a (non-DAG) transformer is provided, it is rendered as a DAG
   *        containing that transformer as its sole output and automatically-generated placeholders.
   * @return the rendered graph
   */
  public <A, B, R> T render(Transformer2<A, B, R> dag, Iterable<? extends A> values1, Iterable<? extends B> values2) {
    return render(dag, index -> index == 0, values1, values2);
  }

  /**
   * Given a {@link Graph} (such as that from a DAG class, e.g. DAG3x2), returns an object that is a rendered
   * visualization of that graph.
   *
   * The inputs to this method take the form of parallel sequences of values.  Each sequence will provide the values
   * for a particular {@link Placeholder} in the DAG (the ordering of the {@link Placeholder}s in a DAG is determined
   * by their ordering in the call to "DAG.withPlaceholders(...)...." that created it).  They are "parallel" because,
   * e.g. all the values corresponding to the fourth example will be the fourth value in their respective input
   * sequences (all sequences must, of course, be equal in size).
   *
   * @param renderExampleValuesPredicate a predicate that returns true when passed an example index iff that example's
   *        input, intermediate and output values should be included as part of rendered graph
   * @param values1 the sequence of values for the first {@link Placeholder} in the DAG.
   * @param values2 the sequence of values for the second {@link Placeholder} in the DAG.
   * @param dag a DAG or other transformer to render; if a (non-DAG) transformer is provided, it is rendered as a DAG
   *        containing that transformer as its sole output and automatically-generated placeholders.
   * @return the rendered graph
   */
  public <A, B, R> T render(Transformer2<A, B, R> dag, LongPredicate renderExampleValuesPredicate,
      Iterable<? extends A> values1, Iterable<? extends B> values2) {
    // make sure we have a DAG
    DAGTransformer<R, ?> dagTransformer =
        dag instanceof PreparableTransformer2 ? PreparableTransformer2.toDAG((PreparableTransformer2<A, B, R, ?>) dag)
            : PreparedTransformer2.toDAG((PreparedTransformer2<A, B, R>) dag);

    ProducerToValueMap producerToValueMap =
        new ProducerToValueMap(dagTransformer.producers().map(LinkedStack::peek).collect(Collectors.toList()),
            renderExampleValuesPredicate);

    // we shouldn't really have to cast to (Placeholder<?>), but the compiler is most insistent
    List<Placeholder<?>> placeholders =
        dagTransformer.producers(Placeholder.class).map(LinkedStack::peek).map(p -> (Placeholder<?>) p)
            .collect(Collectors.toList());

    // execute the DAG to collect producer output values
    @SuppressWarnings("unchecked")
    final List<Map<Producer<?>, Object>> mapList =
        new ArrayList<>((dagTransformer instanceof PreparableDAGTransformer) ? DAG
            .withPlaceholders((Placeholder<A>) placeholders.get(0), (Placeholder<B>) placeholders.get(1))
            .withOutput(producerToValueMap).prepareAndApply(values1, values2).toCollection() : DAG.Prepared
            .withPlaceholders((Placeholder<A>) placeholders.get(0), (Placeholder<B>) placeholders.get(1))
            .withOutput(producerToValueMap).applyAll(values1, values2).toCollection());

    // filter any empty maps (corresponding to examples that were not selected by the render example predicate)
    mapList.removeIf(Objects::isNull);

    return render(dagTransformer.graph(), mapList);
  }

  /**
   * Given a {@link Graph} (such as that from a DAG class, e.g. DAG3x2), returns an object that is a rendered
   * visualization of that graph.
   *
   * In addition to the graph, the input, intermediate and output values for a single example (whose placeholder values
   * are provided as arguments) will be rendered as part of the graph.
   *
   * @param value1 the example's value for the first {@link Placeholder} in the DAG.
   * @param value2 the example's value for the second {@link Placeholder} in the DAG.
   * @param value3 the example's value for the third {@link Placeholder} in the DAG.
   * @param dag a DAG or other transformer to render; if a (non-DAG) transformer is provided, it is rendered as a DAG
   *        containing that transformer as its sole output and automatically-generated placeholders.
   * @return the rendered graph
   */
  public <A, B, C, R> T render(Transformer3<A, B, C, R> dag, A value1, B value2, C value3) {
    return render(dag, ObjectReader.singleton(value1), ObjectReader.singleton(value2), ObjectReader.singleton(value3));
  }

  /**
   * Given a {@link Graph} (such as that from a DAG class, e.g. DAG3x2), returns an object that is a rendered
   * visualization of that graph.
   *
   * The inputs to this method take the form of parallel sequences of values.  Each sequence will provide the values
   * for a particular {@link Placeholder} in the DAG (the ordering of the {@link Placeholder}s in a DAG is determined
   * by their ordering in the call to "DAG.withPlaceholders(...)...." that created it).  They are "parallel" because,
   * e.g. all the values corresponding to the fourth example will be the fourth value in their respective input
   * sequences (all sequences must, of course, be equal in size).
   *
   * Only the first example will have its input, intermediate and output values rendered.
   *
   * @param values1 the sequence of values for the first {@link Placeholder} in the DAG.
   * @param values2 the sequence of values for the second {@link Placeholder} in the DAG.
   * @param values3 the sequence of values for the third {@link Placeholder} in the DAG.
   * @param dag a DAG or other transformer to render; if a (non-DAG) transformer is provided, it is rendered as a DAG
   *        containing that transformer as its sole output and automatically-generated placeholders.
   * @return the rendered graph
   */
  public <A, B, C, R> T render(Transformer3<A, B, C, R> dag, Iterable<? extends A> values1,
      Iterable<? extends B> values2, Iterable<? extends C> values3) {
    return render(dag, index -> index == 0, values1, values2, values3);
  }

  /**
   * Given a {@link Graph} (such as that from a DAG class, e.g. DAG3x2), returns an object that is a rendered
   * visualization of that graph.
   *
   * The inputs to this method take the form of parallel sequences of values.  Each sequence will provide the values
   * for a particular {@link Placeholder} in the DAG (the ordering of the {@link Placeholder}s in a DAG is determined
   * by their ordering in the call to "DAG.withPlaceholders(...)...." that created it).  They are "parallel" because,
   * e.g. all the values corresponding to the fourth example will be the fourth value in their respective input
   * sequences (all sequences must, of course, be equal in size).
   *
   * @param renderExampleValuesPredicate a predicate that returns true when passed an example index iff that example's
   *        input, intermediate and output values should be included as part of rendered graph
   * @param values1 the sequence of values for the first {@link Placeholder} in the DAG.
   * @param values2 the sequence of values for the second {@link Placeholder} in the DAG.
   * @param values3 the sequence of values for the third {@link Placeholder} in the DAG.
   * @param dag a DAG or other transformer to render; if a (non-DAG) transformer is provided, it is rendered as a DAG
   *        containing that transformer as its sole output and automatically-generated placeholders.
   * @return the rendered graph
   */
  public <A, B, C, R> T render(Transformer3<A, B, C, R> dag, LongPredicate renderExampleValuesPredicate,
      Iterable<? extends A> values1, Iterable<? extends B> values2, Iterable<? extends C> values3) {
    // make sure we have a DAG
    DAGTransformer<R, ?> dagTransformer =
        dag instanceof PreparableTransformer3 ? PreparableTransformer3
            .toDAG((PreparableTransformer3<A, B, C, R, ?>) dag) : PreparedTransformer3
            .toDAG((PreparedTransformer3<A, B, C, R>) dag);

    ProducerToValueMap producerToValueMap =
        new ProducerToValueMap(dagTransformer.producers().map(LinkedStack::peek).collect(Collectors.toList()),
            renderExampleValuesPredicate);

    // we shouldn't really have to cast to (Placeholder<?>), but the compiler is most insistent
    List<Placeholder<?>> placeholders =
        dagTransformer.producers(Placeholder.class).map(LinkedStack::peek).map(p -> (Placeholder<?>) p)
            .collect(Collectors.toList());

    // execute the DAG to collect producer output values
    @SuppressWarnings("unchecked")
    final List<Map<Producer<?>, Object>> mapList =
        new ArrayList<>((dagTransformer instanceof PreparableDAGTransformer) ? DAG
            .withPlaceholders((Placeholder<A>) placeholders.get(0), (Placeholder<B>) placeholders.get(1),
                (Placeholder<C>) placeholders.get(2)).withOutput(producerToValueMap)
            .prepareAndApply(values1, values2, values3).toCollection() : DAG.Prepared
            .withPlaceholders((Placeholder<A>) placeholders.get(0), (Placeholder<B>) placeholders.get(1),
                (Placeholder<C>) placeholders.get(2)).withOutput(producerToValueMap)
            .applyAll(values1, values2, values3).toCollection());

    // filter any empty maps (corresponding to examples that were not selected by the render example predicate)
    mapList.removeIf(Objects::isNull);

    return render(dagTransformer.graph(), mapList);
  }

  /**
   * Given a {@link Graph} (such as that from a DAG class, e.g. DAG3x2), returns an object that is a rendered
   * visualization of that graph.
   *
   * In addition to the graph, the input, intermediate and output values for a single example (whose placeholder values
   * are provided as arguments) will be rendered as part of the graph.
   *
   * @param value1 the example's value for the first {@link Placeholder} in the DAG.
   * @param value2 the example's value for the second {@link Placeholder} in the DAG.
   * @param value3 the example's value for the third {@link Placeholder} in the DAG.
   * @param value4 the example's value for the fourth {@link Placeholder} in the DAG.
   * @param dag a DAG or other transformer to render; if a (non-DAG) transformer is provided, it is rendered as a DAG
   *        containing that transformer as its sole output and automatically-generated placeholders.
   * @return the rendered graph
   */
  public <A, B, C, D, R> T render(Transformer4<A, B, C, D, R> dag, A value1, B value2, C value3, D value4) {
    return render(dag, ObjectReader.singleton(value1), ObjectReader.singleton(value2), ObjectReader.singleton(value3),
        ObjectReader.singleton(value4));
  }

  /**
   * Given a {@link Graph} (such as that from a DAG class, e.g. DAG3x2), returns an object that is a rendered
   * visualization of that graph.
   *
   * The inputs to this method take the form of parallel sequences of values.  Each sequence will provide the values
   * for a particular {@link Placeholder} in the DAG (the ordering of the {@link Placeholder}s in a DAG is determined
   * by their ordering in the call to "DAG.withPlaceholders(...)...." that created it).  They are "parallel" because,
   * e.g. all the values corresponding to the fourth example will be the fourth value in their respective input
   * sequences (all sequences must, of course, be equal in size).
   *
   * Only the first example will have its input, intermediate and output values rendered.
   *
   * @param values1 the sequence of values for the first {@link Placeholder} in the DAG.
   * @param values2 the sequence of values for the second {@link Placeholder} in the DAG.
   * @param values3 the sequence of values for the third {@link Placeholder} in the DAG.
   * @param values4 the sequence of values for the fourth {@link Placeholder} in the DAG.
   * @param dag a DAG or other transformer to render; if a (non-DAG) transformer is provided, it is rendered as a DAG
   *        containing that transformer as its sole output and automatically-generated placeholders.
   * @return the rendered graph
   */
  public <A, B, C, D, R> T render(Transformer4<A, B, C, D, R> dag, Iterable<? extends A> values1,
      Iterable<? extends B> values2, Iterable<? extends C> values3, Iterable<? extends D> values4) {
    return render(dag, index -> index == 0, values1, values2, values3, values4);
  }

  /**
   * Given a {@link Graph} (such as that from a DAG class, e.g. DAG3x2), returns an object that is a rendered
   * visualization of that graph.
   *
   * The inputs to this method take the form of parallel sequences of values.  Each sequence will provide the values
   * for a particular {@link Placeholder} in the DAG (the ordering of the {@link Placeholder}s in a DAG is determined
   * by their ordering in the call to "DAG.withPlaceholders(...)...." that created it).  They are "parallel" because,
   * e.g. all the values corresponding to the fourth example will be the fourth value in their respective input
   * sequences (all sequences must, of course, be equal in size).
   *
   * @param renderExampleValuesPredicate a predicate that returns true when passed an example index iff that example's
   *        input, intermediate and output values should be included as part of rendered graph
   * @param values1 the sequence of values for the first {@link Placeholder} in the DAG.
   * @param values2 the sequence of values for the second {@link Placeholder} in the DAG.
   * @param values3 the sequence of values for the third {@link Placeholder} in the DAG.
   * @param values4 the sequence of values for the fourth {@link Placeholder} in the DAG.
   * @param dag a DAG or other transformer to render; if a (non-DAG) transformer is provided, it is rendered as a DAG
   *        containing that transformer as its sole output and automatically-generated placeholders.
   * @return the rendered graph
   */
  public <A, B, C, D, R> T render(Transformer4<A, B, C, D, R> dag, LongPredicate renderExampleValuesPredicate,
      Iterable<? extends A> values1, Iterable<? extends B> values2, Iterable<? extends C> values3,
      Iterable<? extends D> values4) {
    // make sure we have a DAG
    DAGTransformer<R, ?> dagTransformer =
        dag instanceof PreparableTransformer4 ? PreparableTransformer4
            .toDAG((PreparableTransformer4<A, B, C, D, R, ?>) dag) : PreparedTransformer4
            .toDAG((PreparedTransformer4<A, B, C, D, R>) dag);

    ProducerToValueMap producerToValueMap =
        new ProducerToValueMap(dagTransformer.producers().map(LinkedStack::peek).collect(Collectors.toList()),
            renderExampleValuesPredicate);

    // we shouldn't really have to cast to (Placeholder<?>), but the compiler is most insistent
    List<Placeholder<?>> placeholders =
        dagTransformer.producers(Placeholder.class).map(LinkedStack::peek).map(p -> (Placeholder<?>) p)
            .collect(Collectors.toList());

    // execute the DAG to collect producer output values
    @SuppressWarnings("unchecked")
    final List<Map<Producer<?>, Object>> mapList =
        new ArrayList<>((dagTransformer instanceof PreparableDAGTransformer) ? DAG
            .withPlaceholders((Placeholder<A>) placeholders.get(0), (Placeholder<B>) placeholders.get(1),
                (Placeholder<C>) placeholders.get(2), (Placeholder<D>) placeholders.get(3))
            .withOutput(producerToValueMap).prepareAndApply(values1, values2, values3, values4).toCollection()
            : DAG.Prepared
                .withPlaceholders((Placeholder<A>) placeholders.get(0), (Placeholder<B>) placeholders.get(1),
                    (Placeholder<C>) placeholders.get(2), (Placeholder<D>) placeholders.get(3))
                .withOutput(producerToValueMap).applyAll(values1, values2, values3, values4).toCollection());

    // filter any empty maps (corresponding to examples that were not selected by the render example predicate)
    mapList.removeIf(Objects::isNull);

    return render(dagTransformer.graph(), mapList);
  }

  /**
   * Given a {@link Graph} (such as that from a DAG class, e.g. DAG3x2), returns an object that is a rendered
   * visualization of that graph.
   *
   * In addition to the graph, the input, intermediate and output values for a single example (whose placeholder values
   * are provided as arguments) will be rendered as part of the graph.
   *
   * @param value1 the example's value for the first {@link Placeholder} in the DAG.
   * @param value2 the example's value for the second {@link Placeholder} in the DAG.
   * @param value3 the example's value for the third {@link Placeholder} in the DAG.
   * @param value4 the example's value for the fourth {@link Placeholder} in the DAG.
   * @param value5 the example's value for the fifth {@link Placeholder} in the DAG.
   * @param dag a DAG or other transformer to render; if a (non-DAG) transformer is provided, it is rendered as a DAG
   *        containing that transformer as its sole output and automatically-generated placeholders.
   * @return the rendered graph
   */
  public <A, B, C, D, E, R> T render(Transformer5<A, B, C, D, E, R> dag, A value1, B value2, C value3, D value4,
      E value5) {
    return render(dag, ObjectReader.singleton(value1), ObjectReader.singleton(value2), ObjectReader.singleton(value3),
        ObjectReader.singleton(value4), ObjectReader.singleton(value5));
  }

  /**
   * Given a {@link Graph} (such as that from a DAG class, e.g. DAG3x2), returns an object that is a rendered
   * visualization of that graph.
   *
   * The inputs to this method take the form of parallel sequences of values.  Each sequence will provide the values
   * for a particular {@link Placeholder} in the DAG (the ordering of the {@link Placeholder}s in a DAG is determined
   * by their ordering in the call to "DAG.withPlaceholders(...)...." that created it).  They are "parallel" because,
   * e.g. all the values corresponding to the fourth example will be the fourth value in their respective input
   * sequences (all sequences must, of course, be equal in size).
   *
   * Only the first example will have its input, intermediate and output values rendered.
   *
   * @param values1 the sequence of values for the first {@link Placeholder} in the DAG.
   * @param values2 the sequence of values for the second {@link Placeholder} in the DAG.
   * @param values3 the sequence of values for the third {@link Placeholder} in the DAG.
   * @param values4 the sequence of values for the fourth {@link Placeholder} in the DAG.
   * @param values5 the sequence of values for the fifth {@link Placeholder} in the DAG.
   * @param dag a DAG or other transformer to render; if a (non-DAG) transformer is provided, it is rendered as a DAG
   *        containing that transformer as its sole output and automatically-generated placeholders.
   * @return the rendered graph
   */
  public <A, B, C, D, E, R> T render(Transformer5<A, B, C, D, E, R> dag, Iterable<? extends A> values1,
      Iterable<? extends B> values2, Iterable<? extends C> values3, Iterable<? extends D> values4,
      Iterable<? extends E> values5) {
    return render(dag, index -> index == 0, values1, values2, values3, values4, values5);
  }

  /**
   * Given a {@link Graph} (such as that from a DAG class, e.g. DAG3x2), returns an object that is a rendered
   * visualization of that graph.
   *
   * The inputs to this method take the form of parallel sequences of values.  Each sequence will provide the values
   * for a particular {@link Placeholder} in the DAG (the ordering of the {@link Placeholder}s in a DAG is determined
   * by their ordering in the call to "DAG.withPlaceholders(...)...." that created it).  They are "parallel" because,
   * e.g. all the values corresponding to the fourth example will be the fourth value in their respective input
   * sequences (all sequences must, of course, be equal in size).
   *
   * @param renderExampleValuesPredicate a predicate that returns true when passed an example index iff that example's
   *        input, intermediate and output values should be included as part of rendered graph
   * @param values1 the sequence of values for the first {@link Placeholder} in the DAG.
   * @param values2 the sequence of values for the second {@link Placeholder} in the DAG.
   * @param values3 the sequence of values for the third {@link Placeholder} in the DAG.
   * @param values4 the sequence of values for the fourth {@link Placeholder} in the DAG.
   * @param values5 the sequence of values for the fifth {@link Placeholder} in the DAG.
   * @param dag a DAG or other transformer to render; if a (non-DAG) transformer is provided, it is rendered as a DAG
   *        containing that transformer as its sole output and automatically-generated placeholders.
   * @return the rendered graph
   */
  public <A, B, C, D, E, R> T render(Transformer5<A, B, C, D, E, R> dag, LongPredicate renderExampleValuesPredicate,
      Iterable<? extends A> values1, Iterable<? extends B> values2, Iterable<? extends C> values3,
      Iterable<? extends D> values4, Iterable<? extends E> values5) {
    // make sure we have a DAG
    DAGTransformer<R, ?> dagTransformer =
        dag instanceof PreparableTransformer5 ? PreparableTransformer5
            .toDAG((PreparableTransformer5<A, B, C, D, E, R, ?>) dag) : PreparedTransformer5
            .toDAG((PreparedTransformer5<A, B, C, D, E, R>) dag);

    ProducerToValueMap producerToValueMap =
        new ProducerToValueMap(dagTransformer.producers().map(LinkedStack::peek).collect(Collectors.toList()),
            renderExampleValuesPredicate);

    // we shouldn't really have to cast to (Placeholder<?>), but the compiler is most insistent
    List<Placeholder<?>> placeholders =
        dagTransformer.producers(Placeholder.class).map(LinkedStack::peek).map(p -> (Placeholder<?>) p)
            .collect(Collectors.toList());

    // execute the DAG to collect producer output values
    @SuppressWarnings("unchecked")
    final List<Map<Producer<?>, Object>> mapList =
        new ArrayList<>((dagTransformer instanceof PreparableDAGTransformer) ? DAG
            .withPlaceholders((Placeholder<A>) placeholders.get(0), (Placeholder<B>) placeholders.get(1),
                (Placeholder<C>) placeholders.get(2), (Placeholder<D>) placeholders.get(3),
                (Placeholder<E>) placeholders.get(4)).withOutput(producerToValueMap)
            .prepareAndApply(values1, values2, values3, values4, values5).toCollection() : DAG.Prepared
            .withPlaceholders((Placeholder<A>) placeholders.get(0), (Placeholder<B>) placeholders.get(1),
                (Placeholder<C>) placeholders.get(2), (Placeholder<D>) placeholders.get(3),
                (Placeholder<E>) placeholders.get(4)).withOutput(producerToValueMap)
            .applyAll(values1, values2, values3, values4, values5).toCollection());

    // filter any empty maps (corresponding to examples that were not selected by the render example predicate)
    mapList.removeIf(Objects::isNull);

    return render(dagTransformer.graph(), mapList);
  }

  /**
   * Given a {@link Graph} (such as that from a DAG class, e.g. DAG3x2), returns an object that is a rendered
   * visualization of that graph.
   *
   * In addition to the graph, the input, intermediate and output values for a single example (whose placeholder values
   * are provided as arguments) will be rendered as part of the graph.
   *
   * @param value1 the example's value for the first {@link Placeholder} in the DAG.
   * @param value2 the example's value for the second {@link Placeholder} in the DAG.
   * @param value3 the example's value for the third {@link Placeholder} in the DAG.
   * @param value4 the example's value for the fourth {@link Placeholder} in the DAG.
   * @param value5 the example's value for the fifth {@link Placeholder} in the DAG.
   * @param value6 the example's value for the sixth {@link Placeholder} in the DAG.
   * @param dag a DAG or other transformer to render; if a (non-DAG) transformer is provided, it is rendered as a DAG
   *        containing that transformer as its sole output and automatically-generated placeholders.
   * @return the rendered graph
   */
  public <A, B, C, D, E, F, R> T render(Transformer6<A, B, C, D, E, F, R> dag, A value1, B value2, C value3, D value4,
      E value5, F value6) {
    return render(dag, ObjectReader.singleton(value1), ObjectReader.singleton(value2), ObjectReader.singleton(value3),
        ObjectReader.singleton(value4), ObjectReader.singleton(value5), ObjectReader.singleton(value6));
  }

  /**
   * Given a {@link Graph} (such as that from a DAG class, e.g. DAG3x2), returns an object that is a rendered
   * visualization of that graph.
   *
   * The inputs to this method take the form of parallel sequences of values.  Each sequence will provide the values
   * for a particular {@link Placeholder} in the DAG (the ordering of the {@link Placeholder}s in a DAG is determined
   * by their ordering in the call to "DAG.withPlaceholders(...)...." that created it).  They are "parallel" because,
   * e.g. all the values corresponding to the fourth example will be the fourth value in their respective input
   * sequences (all sequences must, of course, be equal in size).
   *
   * Only the first example will have its input, intermediate and output values rendered.
   *
   * @param values1 the sequence of values for the first {@link Placeholder} in the DAG.
   * @param values2 the sequence of values for the second {@link Placeholder} in the DAG.
   * @param values3 the sequence of values for the third {@link Placeholder} in the DAG.
   * @param values4 the sequence of values for the fourth {@link Placeholder} in the DAG.
   * @param values5 the sequence of values for the fifth {@link Placeholder} in the DAG.
   * @param values6 the sequence of values for the sixth {@link Placeholder} in the DAG.
   * @param dag a DAG or other transformer to render; if a (non-DAG) transformer is provided, it is rendered as a DAG
   *        containing that transformer as its sole output and automatically-generated placeholders.
   * @return the rendered graph
   */
  public <A, B, C, D, E, F, R> T render(Transformer6<A, B, C, D, E, F, R> dag, Iterable<? extends A> values1,
      Iterable<? extends B> values2, Iterable<? extends C> values3, Iterable<? extends D> values4,
      Iterable<? extends E> values5, Iterable<? extends F> values6) {
    return render(dag, index -> index == 0, values1, values2, values3, values4, values5, values6);
  }

  /**
   * Given a {@link Graph} (such as that from a DAG class, e.g. DAG3x2), returns an object that is a rendered
   * visualization of that graph.
   *
   * The inputs to this method take the form of parallel sequences of values.  Each sequence will provide the values
   * for a particular {@link Placeholder} in the DAG (the ordering of the {@link Placeholder}s in a DAG is determined
   * by their ordering in the call to "DAG.withPlaceholders(...)...." that created it).  They are "parallel" because,
   * e.g. all the values corresponding to the fourth example will be the fourth value in their respective input
   * sequences (all sequences must, of course, be equal in size).
   *
   * @param renderExampleValuesPredicate a predicate that returns true when passed an example index iff that example's
   *        input, intermediate and output values should be included as part of rendered graph
   * @param values1 the sequence of values for the first {@link Placeholder} in the DAG.
   * @param values2 the sequence of values for the second {@link Placeholder} in the DAG.
   * @param values3 the sequence of values for the third {@link Placeholder} in the DAG.
   * @param values4 the sequence of values for the fourth {@link Placeholder} in the DAG.
   * @param values5 the sequence of values for the fifth {@link Placeholder} in the DAG.
   * @param values6 the sequence of values for the sixth {@link Placeholder} in the DAG.
   * @param dag a DAG or other transformer to render; if a (non-DAG) transformer is provided, it is rendered as a DAG
   *        containing that transformer as its sole output and automatically-generated placeholders.
   * @return the rendered graph
   */
  public <A, B, C, D, E, F, R> T render(Transformer6<A, B, C, D, E, F, R> dag,
      LongPredicate renderExampleValuesPredicate, Iterable<? extends A> values1, Iterable<? extends B> values2,
      Iterable<? extends C> values3, Iterable<? extends D> values4, Iterable<? extends E> values5,
      Iterable<? extends F> values6) {
    // make sure we have a DAG
    DAGTransformer<R, ?> dagTransformer =
        dag instanceof PreparableTransformer6 ? PreparableTransformer6
            .toDAG((PreparableTransformer6<A, B, C, D, E, F, R, ?>) dag) : PreparedTransformer6
            .toDAG((PreparedTransformer6<A, B, C, D, E, F, R>) dag);

    ProducerToValueMap producerToValueMap =
        new ProducerToValueMap(dagTransformer.producers().map(LinkedStack::peek).collect(Collectors.toList()),
            renderExampleValuesPredicate);

    // we shouldn't really have to cast to (Placeholder<?>), but the compiler is most insistent
    List<Placeholder<?>> placeholders =
        dagTransformer.producers(Placeholder.class).map(LinkedStack::peek).map(p -> (Placeholder<?>) p)
            .collect(Collectors.toList());

    // execute the DAG to collect producer output values
    @SuppressWarnings("unchecked")
    final List<Map<Producer<?>, Object>> mapList =
        new ArrayList<>((dagTransformer instanceof PreparableDAGTransformer) ? DAG
            .withPlaceholders((Placeholder<A>) placeholders.get(0), (Placeholder<B>) placeholders.get(1),
                (Placeholder<C>) placeholders.get(2), (Placeholder<D>) placeholders.get(3),
                (Placeholder<E>) placeholders.get(4), (Placeholder<F>) placeholders.get(5))
            .withOutput(producerToValueMap).prepareAndApply(values1, values2, values3, values4, values5, values6)
            .toCollection() : DAG.Prepared
            .withPlaceholders((Placeholder<A>) placeholders.get(0), (Placeholder<B>) placeholders.get(1),
                (Placeholder<C>) placeholders.get(2), (Placeholder<D>) placeholders.get(3),
                (Placeholder<E>) placeholders.get(4), (Placeholder<F>) placeholders.get(5))
            .withOutput(producerToValueMap).applyAll(values1, values2, values3, values4, values5, values6)
            .toCollection());

    // filter any empty maps (corresponding to examples that were not selected by the render example predicate)
    mapList.removeIf(Objects::isNull);

    return render(dagTransformer.graph(), mapList);
  }

  /**
   * Given a {@link Graph} (such as that from a DAG class, e.g. DAG3x2), returns an object that is a rendered
   * visualization of that graph.
   *
   * In addition to the graph, the input, intermediate and output values for a single example (whose placeholder values
   * are provided as arguments) will be rendered as part of the graph.
   *
   * @param value1 the example's value for the first {@link Placeholder} in the DAG.
   * @param value2 the example's value for the second {@link Placeholder} in the DAG.
   * @param value3 the example's value for the third {@link Placeholder} in the DAG.
   * @param value4 the example's value for the fourth {@link Placeholder} in the DAG.
   * @param value5 the example's value for the fifth {@link Placeholder} in the DAG.
   * @param value6 the example's value for the sixth {@link Placeholder} in the DAG.
   * @param value7 the example's value for the seventh {@link Placeholder} in the DAG.
   * @param dag a DAG or other transformer to render; if a (non-DAG) transformer is provided, it is rendered as a DAG
   *        containing that transformer as its sole output and automatically-generated placeholders.
   * @return the rendered graph
   */
  public <A, B, C, D, E, F, G, R> T render(Transformer7<A, B, C, D, E, F, G, R> dag, A value1, B value2, C value3,
      D value4, E value5, F value6, G value7) {
    return render(dag, ObjectReader.singleton(value1), ObjectReader.singleton(value2), ObjectReader.singleton(value3),
        ObjectReader.singleton(value4), ObjectReader.singleton(value5), ObjectReader.singleton(value6),
        ObjectReader.singleton(value7));
  }

  /**
   * Given a {@link Graph} (such as that from a DAG class, e.g. DAG3x2), returns an object that is a rendered
   * visualization of that graph.
   *
   * The inputs to this method take the form of parallel sequences of values.  Each sequence will provide the values
   * for a particular {@link Placeholder} in the DAG (the ordering of the {@link Placeholder}s in a DAG is determined
   * by their ordering in the call to "DAG.withPlaceholders(...)...." that created it).  They are "parallel" because,
   * e.g. all the values corresponding to the fourth example will be the fourth value in their respective input
   * sequences (all sequences must, of course, be equal in size).
   *
   * Only the first example will have its input, intermediate and output values rendered.
   *
   * @param values1 the sequence of values for the first {@link Placeholder} in the DAG.
   * @param values2 the sequence of values for the second {@link Placeholder} in the DAG.
   * @param values3 the sequence of values for the third {@link Placeholder} in the DAG.
   * @param values4 the sequence of values for the fourth {@link Placeholder} in the DAG.
   * @param values5 the sequence of values for the fifth {@link Placeholder} in the DAG.
   * @param values6 the sequence of values for the sixth {@link Placeholder} in the DAG.
   * @param values7 the sequence of values for the seventh {@link Placeholder} in the DAG.
   * @param dag a DAG or other transformer to render; if a (non-DAG) transformer is provided, it is rendered as a DAG
   *        containing that transformer as its sole output and automatically-generated placeholders.
   * @return the rendered graph
   */
  public <A, B, C, D, E, F, G, R> T render(Transformer7<A, B, C, D, E, F, G, R> dag, Iterable<? extends A> values1,
      Iterable<? extends B> values2, Iterable<? extends C> values3, Iterable<? extends D> values4,
      Iterable<? extends E> values5, Iterable<? extends F> values6, Iterable<? extends G> values7) {
    return render(dag, index -> index == 0, values1, values2, values3, values4, values5, values6, values7);
  }

  /**
   * Given a {@link Graph} (such as that from a DAG class, e.g. DAG3x2), returns an object that is a rendered
   * visualization of that graph.
   *
   * The inputs to this method take the form of parallel sequences of values.  Each sequence will provide the values
   * for a particular {@link Placeholder} in the DAG (the ordering of the {@link Placeholder}s in a DAG is determined
   * by their ordering in the call to "DAG.withPlaceholders(...)...." that created it).  They are "parallel" because,
   * e.g. all the values corresponding to the fourth example will be the fourth value in their respective input
   * sequences (all sequences must, of course, be equal in size).
   *
   * @param renderExampleValuesPredicate a predicate that returns true when passed an example index iff that example's
   *        input, intermediate and output values should be included as part of rendered graph
   * @param values1 the sequence of values for the first {@link Placeholder} in the DAG.
   * @param values2 the sequence of values for the second {@link Placeholder} in the DAG.
   * @param values3 the sequence of values for the third {@link Placeholder} in the DAG.
   * @param values4 the sequence of values for the fourth {@link Placeholder} in the DAG.
   * @param values5 the sequence of values for the fifth {@link Placeholder} in the DAG.
   * @param values6 the sequence of values for the sixth {@link Placeholder} in the DAG.
   * @param values7 the sequence of values for the seventh {@link Placeholder} in the DAG.
   * @param dag a DAG or other transformer to render; if a (non-DAG) transformer is provided, it is rendered as a DAG
   *        containing that transformer as its sole output and automatically-generated placeholders.
   * @return the rendered graph
   */
  public <A, B, C, D, E, F, G, R> T render(Transformer7<A, B, C, D, E, F, G, R> dag,
      LongPredicate renderExampleValuesPredicate, Iterable<? extends A> values1, Iterable<? extends B> values2,
      Iterable<? extends C> values3, Iterable<? extends D> values4, Iterable<? extends E> values5,
      Iterable<? extends F> values6, Iterable<? extends G> values7) {
    // make sure we have a DAG
    DAGTransformer<R, ?> dagTransformer =
        dag instanceof PreparableTransformer7 ? PreparableTransformer7
            .toDAG((PreparableTransformer7<A, B, C, D, E, F, G, R, ?>) dag) : PreparedTransformer7
            .toDAG((PreparedTransformer7<A, B, C, D, E, F, G, R>) dag);

    ProducerToValueMap producerToValueMap =
        new ProducerToValueMap(dagTransformer.producers().map(LinkedStack::peek).collect(Collectors.toList()),
            renderExampleValuesPredicate);

    // we shouldn't really have to cast to (Placeholder<?>), but the compiler is most insistent
    List<Placeholder<?>> placeholders =
        dagTransformer.producers(Placeholder.class).map(LinkedStack::peek).map(p -> (Placeholder<?>) p)
            .collect(Collectors.toList());

    // execute the DAG to collect producer output values
    @SuppressWarnings("unchecked")
    final List<Map<Producer<?>, Object>> mapList =
        new ArrayList<>((dagTransformer instanceof PreparableDAGTransformer) ? DAG
            .withPlaceholders((Placeholder<A>) placeholders.get(0), (Placeholder<B>) placeholders.get(1),
                (Placeholder<C>) placeholders.get(2), (Placeholder<D>) placeholders.get(3),
                (Placeholder<E>) placeholders.get(4), (Placeholder<F>) placeholders.get(5),
                (Placeholder<G>) placeholders.get(6)).withOutput(producerToValueMap)
            .prepareAndApply(values1, values2, values3, values4, values5, values6, values7).toCollection()
            : DAG.Prepared
                .withPlaceholders((Placeholder<A>) placeholders.get(0), (Placeholder<B>) placeholders.get(1),
                    (Placeholder<C>) placeholders.get(2), (Placeholder<D>) placeholders.get(3),
                    (Placeholder<E>) placeholders.get(4), (Placeholder<F>) placeholders.get(5),
                    (Placeholder<G>) placeholders.get(6)).withOutput(producerToValueMap)
                .applyAll(values1, values2, values3, values4, values5, values6, values7).toCollection());

    // filter any empty maps (corresponding to examples that were not selected by the render example predicate)
    mapList.removeIf(Objects::isNull);

    return render(dagTransformer.graph(), mapList);
  }

  /**
   * Given a {@link Graph} (such as that from a DAG class, e.g. DAG3x2), returns an object that is a rendered
   * visualization of that graph.
   *
   * In addition to the graph, the input, intermediate and output values for a single example (whose placeholder values
   * are provided as arguments) will be rendered as part of the graph.
   *
   * @param value1 the example's value for the first {@link Placeholder} in the DAG.
   * @param value2 the example's value for the second {@link Placeholder} in the DAG.
   * @param value3 the example's value for the third {@link Placeholder} in the DAG.
   * @param value4 the example's value for the fourth {@link Placeholder} in the DAG.
   * @param value5 the example's value for the fifth {@link Placeholder} in the DAG.
   * @param value6 the example's value for the sixth {@link Placeholder} in the DAG.
   * @param value7 the example's value for the seventh {@link Placeholder} in the DAG.
   * @param value8 the example's value for the eighth {@link Placeholder} in the DAG.
   * @param dag a DAG or other transformer to render; if a (non-DAG) transformer is provided, it is rendered as a DAG
   *        containing that transformer as its sole output and automatically-generated placeholders.
   * @return the rendered graph
   */
  public <A, B, C, D, E, F, G, H, R> T render(Transformer8<A, B, C, D, E, F, G, H, R> dag, A value1, B value2,
      C value3, D value4, E value5, F value6, G value7, H value8) {
    return render(dag, ObjectReader.singleton(value1), ObjectReader.singleton(value2), ObjectReader.singleton(value3),
        ObjectReader.singleton(value4), ObjectReader.singleton(value5), ObjectReader.singleton(value6),
        ObjectReader.singleton(value7), ObjectReader.singleton(value8));
  }

  /**
   * Given a {@link Graph} (such as that from a DAG class, e.g. DAG3x2), returns an object that is a rendered
   * visualization of that graph.
   *
   * The inputs to this method take the form of parallel sequences of values.  Each sequence will provide the values
   * for a particular {@link Placeholder} in the DAG (the ordering of the {@link Placeholder}s in a DAG is determined
   * by their ordering in the call to "DAG.withPlaceholders(...)...." that created it).  They are "parallel" because,
   * e.g. all the values corresponding to the fourth example will be the fourth value in their respective input
   * sequences (all sequences must, of course, be equal in size).
   *
   * Only the first example will have its input, intermediate and output values rendered.
   *
   * @param values1 the sequence of values for the first {@link Placeholder} in the DAG.
   * @param values2 the sequence of values for the second {@link Placeholder} in the DAG.
   * @param values3 the sequence of values for the third {@link Placeholder} in the DAG.
   * @param values4 the sequence of values for the fourth {@link Placeholder} in the DAG.
   * @param values5 the sequence of values for the fifth {@link Placeholder} in the DAG.
   * @param values6 the sequence of values for the sixth {@link Placeholder} in the DAG.
   * @param values7 the sequence of values for the seventh {@link Placeholder} in the DAG.
   * @param values8 the sequence of values for the eighth {@link Placeholder} in the DAG.
   * @param dag a DAG or other transformer to render; if a (non-DAG) transformer is provided, it is rendered as a DAG
   *        containing that transformer as its sole output and automatically-generated placeholders.
   * @return the rendered graph
   */
  public <A, B, C, D, E, F, G, H, R> T render(Transformer8<A, B, C, D, E, F, G, H, R> dag,
      Iterable<? extends A> values1, Iterable<? extends B> values2, Iterable<? extends C> values3,
      Iterable<? extends D> values4, Iterable<? extends E> values5, Iterable<? extends F> values6,
      Iterable<? extends G> values7, Iterable<? extends H> values8) {
    return render(dag, index -> index == 0, values1, values2, values3, values4, values5, values6, values7, values8);
  }

  /**
   * Given a {@link Graph} (such as that from a DAG class, e.g. DAG3x2), returns an object that is a rendered
   * visualization of that graph.
   *
   * The inputs to this method take the form of parallel sequences of values.  Each sequence will provide the values
   * for a particular {@link Placeholder} in the DAG (the ordering of the {@link Placeholder}s in a DAG is determined
   * by their ordering in the call to "DAG.withPlaceholders(...)...." that created it).  They are "parallel" because,
   * e.g. all the values corresponding to the fourth example will be the fourth value in their respective input
   * sequences (all sequences must, of course, be equal in size).
   *
   * @param renderExampleValuesPredicate a predicate that returns true when passed an example index iff that example's
   *        input, intermediate and output values should be included as part of rendered graph
   * @param values1 the sequence of values for the first {@link Placeholder} in the DAG.
   * @param values2 the sequence of values for the second {@link Placeholder} in the DAG.
   * @param values3 the sequence of values for the third {@link Placeholder} in the DAG.
   * @param values4 the sequence of values for the fourth {@link Placeholder} in the DAG.
   * @param values5 the sequence of values for the fifth {@link Placeholder} in the DAG.
   * @param values6 the sequence of values for the sixth {@link Placeholder} in the DAG.
   * @param values7 the sequence of values for the seventh {@link Placeholder} in the DAG.
   * @param values8 the sequence of values for the eighth {@link Placeholder} in the DAG.
   * @param dag a DAG or other transformer to render; if a (non-DAG) transformer is provided, it is rendered as a DAG
   *        containing that transformer as its sole output and automatically-generated placeholders.
   * @return the rendered graph
   */
  public <A, B, C, D, E, F, G, H, R> T render(Transformer8<A, B, C, D, E, F, G, H, R> dag,
      LongPredicate renderExampleValuesPredicate, Iterable<? extends A> values1, Iterable<? extends B> values2,
      Iterable<? extends C> values3, Iterable<? extends D> values4, Iterable<? extends E> values5,
      Iterable<? extends F> values6, Iterable<? extends G> values7, Iterable<? extends H> values8) {
    // make sure we have a DAG
    DAGTransformer<R, ?> dagTransformer =
        dag instanceof PreparableTransformer8 ? PreparableTransformer8
            .toDAG((PreparableTransformer8<A, B, C, D, E, F, G, H, R, ?>) dag) : PreparedTransformer8
            .toDAG((PreparedTransformer8<A, B, C, D, E, F, G, H, R>) dag);

    ProducerToValueMap producerToValueMap =
        new ProducerToValueMap(dagTransformer.producers().map(LinkedStack::peek).collect(Collectors.toList()),
            renderExampleValuesPredicate);

    // we shouldn't really have to cast to (Placeholder<?>), but the compiler is most insistent
    List<Placeholder<?>> placeholders =
        dagTransformer.producers(Placeholder.class).map(LinkedStack::peek).map(p -> (Placeholder<?>) p)
            .collect(Collectors.toList());

    // execute the DAG to collect producer output values
    @SuppressWarnings("unchecked")
    final List<Map<Producer<?>, Object>> mapList =
        new ArrayList<>((dagTransformer instanceof PreparableDAGTransformer) ? DAG
            .withPlaceholders((Placeholder<A>) placeholders.get(0), (Placeholder<B>) placeholders.get(1),
                (Placeholder<C>) placeholders.get(2), (Placeholder<D>) placeholders.get(3),
                (Placeholder<E>) placeholders.get(4), (Placeholder<F>) placeholders.get(5),
                (Placeholder<G>) placeholders.get(6), (Placeholder<H>) placeholders.get(7))
            .withOutput(producerToValueMap)
            .prepareAndApply(values1, values2, values3, values4, values5, values6, values7, values8).toCollection()
            : DAG.Prepared
                .withPlaceholders((Placeholder<A>) placeholders.get(0), (Placeholder<B>) placeholders.get(1),
                    (Placeholder<C>) placeholders.get(2), (Placeholder<D>) placeholders.get(3),
                    (Placeholder<E>) placeholders.get(4), (Placeholder<F>) placeholders.get(5),
                    (Placeholder<G>) placeholders.get(6), (Placeholder<H>) placeholders.get(7))
                .withOutput(producerToValueMap)
                .applyAll(values1, values2, values3, values4, values5, values6, values7, values8).toCollection());

    // filter any empty maps (corresponding to examples that were not selected by the render example predicate)
    mapList.removeIf(Objects::isNull);

    return render(dagTransformer.graph(), mapList);
  }

  /**
   * Given a {@link Graph} (such as that from a DAG class, e.g. DAG3x2), returns an object that is a rendered
   * visualization of that graph.
   *
   * In addition to the graph, the input, intermediate and output values for a single example (whose placeholder values
   * are provided as arguments) will be rendered as part of the graph.
   *
   * @param value1 the example's value for the first {@link Placeholder} in the DAG.
   * @param value2 the example's value for the second {@link Placeholder} in the DAG.
   * @param value3 the example's value for the third {@link Placeholder} in the DAG.
   * @param value4 the example's value for the fourth {@link Placeholder} in the DAG.
   * @param value5 the example's value for the fifth {@link Placeholder} in the DAG.
   * @param value6 the example's value for the sixth {@link Placeholder} in the DAG.
   * @param value7 the example's value for the seventh {@link Placeholder} in the DAG.
   * @param value8 the example's value for the eighth {@link Placeholder} in the DAG.
   * @param value9 the example's value for the ninth {@link Placeholder} in the DAG.
   * @param dag a DAG or other transformer to render; if a (non-DAG) transformer is provided, it is rendered as a DAG
   *        containing that transformer as its sole output and automatically-generated placeholders.
   * @return the rendered graph
   */
  public <A, B, C, D, E, F, G, H, I, R> T render(Transformer9<A, B, C, D, E, F, G, H, I, R> dag, A value1, B value2,
      C value3, D value4, E value5, F value6, G value7, H value8, I value9) {
    return render(dag, ObjectReader.singleton(value1), ObjectReader.singleton(value2), ObjectReader.singleton(value3),
        ObjectReader.singleton(value4), ObjectReader.singleton(value5), ObjectReader.singleton(value6),
        ObjectReader.singleton(value7), ObjectReader.singleton(value8), ObjectReader.singleton(value9));
  }

  /**
   * Given a {@link Graph} (such as that from a DAG class, e.g. DAG3x2), returns an object that is a rendered
   * visualization of that graph.
   *
   * The inputs to this method take the form of parallel sequences of values.  Each sequence will provide the values
   * for a particular {@link Placeholder} in the DAG (the ordering of the {@link Placeholder}s in a DAG is determined
   * by their ordering in the call to "DAG.withPlaceholders(...)...." that created it).  They are "parallel" because,
   * e.g. all the values corresponding to the fourth example will be the fourth value in their respective input
   * sequences (all sequences must, of course, be equal in size).
   *
   * Only the first example will have its input, intermediate and output values rendered.
   *
   * @param values1 the sequence of values for the first {@link Placeholder} in the DAG.
   * @param values2 the sequence of values for the second {@link Placeholder} in the DAG.
   * @param values3 the sequence of values for the third {@link Placeholder} in the DAG.
   * @param values4 the sequence of values for the fourth {@link Placeholder} in the DAG.
   * @param values5 the sequence of values for the fifth {@link Placeholder} in the DAG.
   * @param values6 the sequence of values for the sixth {@link Placeholder} in the DAG.
   * @param values7 the sequence of values for the seventh {@link Placeholder} in the DAG.
   * @param values8 the sequence of values for the eighth {@link Placeholder} in the DAG.
   * @param values9 the sequence of values for the ninth {@link Placeholder} in the DAG.
   * @param dag a DAG or other transformer to render; if a (non-DAG) transformer is provided, it is rendered as a DAG
   *        containing that transformer as its sole output and automatically-generated placeholders.
   * @return the rendered graph
   */
  public <A, B, C, D, E, F, G, H, I, R> T render(Transformer9<A, B, C, D, E, F, G, H, I, R> dag,
      Iterable<? extends A> values1, Iterable<? extends B> values2, Iterable<? extends C> values3,
      Iterable<? extends D> values4, Iterable<? extends E> values5, Iterable<? extends F> values6,
      Iterable<? extends G> values7, Iterable<? extends H> values8, Iterable<? extends I> values9) {
    return render(dag, index -> index == 0, values1, values2, values3, values4, values5, values6, values7, values8,
        values9);
  }

  /**
   * Given a {@link Graph} (such as that from a DAG class, e.g. DAG3x2), returns an object that is a rendered
   * visualization of that graph.
   *
   * The inputs to this method take the form of parallel sequences of values.  Each sequence will provide the values
   * for a particular {@link Placeholder} in the DAG (the ordering of the {@link Placeholder}s in a DAG is determined
   * by their ordering in the call to "DAG.withPlaceholders(...)...." that created it).  They are "parallel" because,
   * e.g. all the values corresponding to the fourth example will be the fourth value in their respective input
   * sequences (all sequences must, of course, be equal in size).
   *
   * @param renderExampleValuesPredicate a predicate that returns true when passed an example index iff that example's
   *        input, intermediate and output values should be included as part of rendered graph
   * @param values1 the sequence of values for the first {@link Placeholder} in the DAG.
   * @param values2 the sequence of values for the second {@link Placeholder} in the DAG.
   * @param values3 the sequence of values for the third {@link Placeholder} in the DAG.
   * @param values4 the sequence of values for the fourth {@link Placeholder} in the DAG.
   * @param values5 the sequence of values for the fifth {@link Placeholder} in the DAG.
   * @param values6 the sequence of values for the sixth {@link Placeholder} in the DAG.
   * @param values7 the sequence of values for the seventh {@link Placeholder} in the DAG.
   * @param values8 the sequence of values for the eighth {@link Placeholder} in the DAG.
   * @param values9 the sequence of values for the ninth {@link Placeholder} in the DAG.
   * @param dag a DAG or other transformer to render; if a (non-DAG) transformer is provided, it is rendered as a DAG
   *        containing that transformer as its sole output and automatically-generated placeholders.
   * @return the rendered graph
   */
  public <A, B, C, D, E, F, G, H, I, R> T render(Transformer9<A, B, C, D, E, F, G, H, I, R> dag,
      LongPredicate renderExampleValuesPredicate, Iterable<? extends A> values1, Iterable<? extends B> values2,
      Iterable<? extends C> values3, Iterable<? extends D> values4, Iterable<? extends E> values5,
      Iterable<? extends F> values6, Iterable<? extends G> values7, Iterable<? extends H> values8,
      Iterable<? extends I> values9) {
    // make sure we have a DAG
    DAGTransformer<R, ?> dagTransformer =
        dag instanceof PreparableTransformer9 ? PreparableTransformer9
            .toDAG((PreparableTransformer9<A, B, C, D, E, F, G, H, I, R, ?>) dag) : PreparedTransformer9
            .toDAG((PreparedTransformer9<A, B, C, D, E, F, G, H, I, R>) dag);

    ProducerToValueMap producerToValueMap =
        new ProducerToValueMap(dagTransformer.producers().map(LinkedStack::peek).collect(Collectors.toList()),
            renderExampleValuesPredicate);

    // we shouldn't really have to cast to (Placeholder<?>), but the compiler is most insistent
    List<Placeholder<?>> placeholders =
        dagTransformer.producers(Placeholder.class).map(LinkedStack::peek).map(p -> (Placeholder<?>) p)
            .collect(Collectors.toList());

    // execute the DAG to collect producer output values
    @SuppressWarnings("unchecked")
    final List<Map<Producer<?>, Object>> mapList =
        new ArrayList<>((dagTransformer instanceof PreparableDAGTransformer) ? DAG
            .withPlaceholders((Placeholder<A>) placeholders.get(0), (Placeholder<B>) placeholders.get(1),
                (Placeholder<C>) placeholders.get(2), (Placeholder<D>) placeholders.get(3),
                (Placeholder<E>) placeholders.get(4), (Placeholder<F>) placeholders.get(5),
                (Placeholder<G>) placeholders.get(6), (Placeholder<H>) placeholders.get(7),
                (Placeholder<I>) placeholders.get(8)).withOutput(producerToValueMap)
            .prepareAndApply(values1, values2, values3, values4, values5, values6, values7, values8, values9)
            .toCollection() : DAG.Prepared
            .withPlaceholders((Placeholder<A>) placeholders.get(0), (Placeholder<B>) placeholders.get(1),
                (Placeholder<C>) placeholders.get(2), (Placeholder<D>) placeholders.get(3),
                (Placeholder<E>) placeholders.get(4), (Placeholder<F>) placeholders.get(5),
                (Placeholder<G>) placeholders.get(6), (Placeholder<H>) placeholders.get(7),
                (Placeholder<I>) placeholders.get(8)).withOutput(producerToValueMap)
            .applyAll(values1, values2, values3, values4, values5, values6, values7, values8, values9).toCollection());

    // filter any empty maps (corresponding to examples that were not selected by the render example predicate)
    mapList.removeIf(Objects::isNull);

    return render(dagTransformer.graph(), mapList);
  }

  /**
   * Given a {@link Graph} (such as that from a DAG class, e.g. DAG3x2), returns an object that is a rendered
   * visualization of that graph.
   *
   * In addition to the graph, the input, intermediate and output values for a single example (whose placeholder values
   * are provided as arguments) will be rendered as part of the graph.
   *
   * @param value1 the example's value for the first {@link Placeholder} in the DAG.
   * @param value2 the example's value for the second {@link Placeholder} in the DAG.
   * @param value3 the example's value for the third {@link Placeholder} in the DAG.
   * @param value4 the example's value for the fourth {@link Placeholder} in the DAG.
   * @param value5 the example's value for the fifth {@link Placeholder} in the DAG.
   * @param value6 the example's value for the sixth {@link Placeholder} in the DAG.
   * @param value7 the example's value for the seventh {@link Placeholder} in the DAG.
   * @param value8 the example's value for the eighth {@link Placeholder} in the DAG.
   * @param value9 the example's value for the ninth {@link Placeholder} in the DAG.
   * @param value10 the example's value for the tenth {@link Placeholder} in the DAG.
   * @param dag a DAG or other transformer to render; if a (non-DAG) transformer is provided, it is rendered as a DAG
   *        containing that transformer as its sole output and automatically-generated placeholders.
   * @return the rendered graph
   */
  public <A, B, C, D, E, F, G, H, I, J, R> T render(Transformer10<A, B, C, D, E, F, G, H, I, J, R> dag, A value1,
      B value2, C value3, D value4, E value5, F value6, G value7, H value8, I value9, J value10) {
    return render(dag, ObjectReader.singleton(value1), ObjectReader.singleton(value2), ObjectReader.singleton(value3),
        ObjectReader.singleton(value4), ObjectReader.singleton(value5), ObjectReader.singleton(value6),
        ObjectReader.singleton(value7), ObjectReader.singleton(value8), ObjectReader.singleton(value9),
        ObjectReader.singleton(value10));
  }

  /**
   * Given a {@link Graph} (such as that from a DAG class, e.g. DAG3x2), returns an object that is a rendered
   * visualization of that graph.
   *
   * The inputs to this method take the form of parallel sequences of values.  Each sequence will provide the values
   * for a particular {@link Placeholder} in the DAG (the ordering of the {@link Placeholder}s in a DAG is determined
   * by their ordering in the call to "DAG.withPlaceholders(...)...." that created it).  They are "parallel" because,
   * e.g. all the values corresponding to the fourth example will be the fourth value in their respective input
   * sequences (all sequences must, of course, be equal in size).
   *
   * Only the first example will have its input, intermediate and output values rendered.
   *
   * @param values1 the sequence of values for the first {@link Placeholder} in the DAG.
   * @param values2 the sequence of values for the second {@link Placeholder} in the DAG.
   * @param values3 the sequence of values for the third {@link Placeholder} in the DAG.
   * @param values4 the sequence of values for the fourth {@link Placeholder} in the DAG.
   * @param values5 the sequence of values for the fifth {@link Placeholder} in the DAG.
   * @param values6 the sequence of values for the sixth {@link Placeholder} in the DAG.
   * @param values7 the sequence of values for the seventh {@link Placeholder} in the DAG.
   * @param values8 the sequence of values for the eighth {@link Placeholder} in the DAG.
   * @param values9 the sequence of values for the ninth {@link Placeholder} in the DAG.
   * @param values10 the sequence of values for the tenth {@link Placeholder} in the DAG.
   * @param dag a DAG or other transformer to render; if a (non-DAG) transformer is provided, it is rendered as a DAG
   *        containing that transformer as its sole output and automatically-generated placeholders.
   * @return the rendered graph
   */
  public <A, B, C, D, E, F, G, H, I, J, R> T render(Transformer10<A, B, C, D, E, F, G, H, I, J, R> dag,
      Iterable<? extends A> values1, Iterable<? extends B> values2, Iterable<? extends C> values3,
      Iterable<? extends D> values4, Iterable<? extends E> values5, Iterable<? extends F> values6,
      Iterable<? extends G> values7, Iterable<? extends H> values8, Iterable<? extends I> values9,
      Iterable<? extends J> values10) {
    return render(dag, index -> index == 0, values1, values2, values3, values4, values5, values6, values7, values8,
        values9, values10);
  }

  /**
   * Given a {@link Graph} (such as that from a DAG class, e.g. DAG3x2), returns an object that is a rendered
   * visualization of that graph.
   *
   * The inputs to this method take the form of parallel sequences of values.  Each sequence will provide the values
   * for a particular {@link Placeholder} in the DAG (the ordering of the {@link Placeholder}s in a DAG is determined
   * by their ordering in the call to "DAG.withPlaceholders(...)...." that created it).  They are "parallel" because,
   * e.g. all the values corresponding to the fourth example will be the fourth value in their respective input
   * sequences (all sequences must, of course, be equal in size).
   *
   * @param renderExampleValuesPredicate a predicate that returns true when passed an example index iff that example's
   *        input, intermediate and output values should be included as part of rendered graph
   * @param values1 the sequence of values for the first {@link Placeholder} in the DAG.
   * @param values2 the sequence of values for the second {@link Placeholder} in the DAG.
   * @param values3 the sequence of values for the third {@link Placeholder} in the DAG.
   * @param values4 the sequence of values for the fourth {@link Placeholder} in the DAG.
   * @param values5 the sequence of values for the fifth {@link Placeholder} in the DAG.
   * @param values6 the sequence of values for the sixth {@link Placeholder} in the DAG.
   * @param values7 the sequence of values for the seventh {@link Placeholder} in the DAG.
   * @param values8 the sequence of values for the eighth {@link Placeholder} in the DAG.
   * @param values9 the sequence of values for the ninth {@link Placeholder} in the DAG.
   * @param values10 the sequence of values for the tenth {@link Placeholder} in the DAG.
   * @param dag a DAG or other transformer to render; if a (non-DAG) transformer is provided, it is rendered as a DAG
   *        containing that transformer as its sole output and automatically-generated placeholders.
   * @return the rendered graph
   */
  public <A, B, C, D, E, F, G, H, I, J, R> T render(Transformer10<A, B, C, D, E, F, G, H, I, J, R> dag,
      LongPredicate renderExampleValuesPredicate, Iterable<? extends A> values1, Iterable<? extends B> values2,
      Iterable<? extends C> values3, Iterable<? extends D> values4, Iterable<? extends E> values5,
      Iterable<? extends F> values6, Iterable<? extends G> values7, Iterable<? extends H> values8,
      Iterable<? extends I> values9, Iterable<? extends J> values10) {
    // make sure we have a DAG
    DAGTransformer<R, ?> dagTransformer =
        dag instanceof PreparableTransformer10 ? PreparableTransformer10
            .toDAG((PreparableTransformer10<A, B, C, D, E, F, G, H, I, J, R, ?>) dag) : PreparedTransformer10
            .toDAG((PreparedTransformer10<A, B, C, D, E, F, G, H, I, J, R>) dag);

    ProducerToValueMap producerToValueMap =
        new ProducerToValueMap(dagTransformer.producers().map(LinkedStack::peek).collect(Collectors.toList()),
            renderExampleValuesPredicate);

    // we shouldn't really have to cast to (Placeholder<?>), but the compiler is most insistent
    List<Placeholder<?>> placeholders =
        dagTransformer.producers(Placeholder.class).map(LinkedStack::peek).map(p -> (Placeholder<?>) p)
            .collect(Collectors.toList());

    // execute the DAG to collect producer output values
    @SuppressWarnings("unchecked")
    final List<Map<Producer<?>, Object>> mapList =
        new ArrayList<>((dagTransformer instanceof PreparableDAGTransformer) ? DAG
            .withPlaceholders((Placeholder<A>) placeholders.get(0), (Placeholder<B>) placeholders.get(1),
                (Placeholder<C>) placeholders.get(2), (Placeholder<D>) placeholders.get(3),
                (Placeholder<E>) placeholders.get(4), (Placeholder<F>) placeholders.get(5),
                (Placeholder<G>) placeholders.get(6), (Placeholder<H>) placeholders.get(7),
                (Placeholder<I>) placeholders.get(8), (Placeholder<J>) placeholders.get(9))
            .withOutput(producerToValueMap)
            .prepareAndApply(values1, values2, values3, values4, values5, values6, values7, values8, values9, values10)
            .toCollection() : DAG.Prepared
            .withPlaceholders((Placeholder<A>) placeholders.get(0), (Placeholder<B>) placeholders.get(1),
                (Placeholder<C>) placeholders.get(2), (Placeholder<D>) placeholders.get(3),
                (Placeholder<E>) placeholders.get(4), (Placeholder<F>) placeholders.get(5),
                (Placeholder<G>) placeholders.get(6), (Placeholder<H>) placeholders.get(7),
                (Placeholder<I>) placeholders.get(8), (Placeholder<J>) placeholders.get(9))
            .withOutput(producerToValueMap)
            .applyAll(values1, values2, values3, values4, values5, values6, values7, values8, values9, values10)
            .toCollection());

    // filter any empty maps (corresponding to examples that were not selected by the render example predicate)
    mapList.removeIf(Objects::isNull);

    return render(dagTransformer.graph(), mapList);
  }
}
