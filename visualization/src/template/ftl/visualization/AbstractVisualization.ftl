<#import "/@core/common.ftl" as c />
<@c.AutoGeneratedWarning />
package com.linkedin.dagli.visualization;

import com.linkedin.dagli.util.cloneable.AbstractCloneable;
import com.linkedin.dagli.util.collection.LinkedStack;
import com.linkedin.dagli.util.function.Function1;
import com.linkedin.dagli.util.named.Named;
import com.linkedin.dagli.objectio.ObjectReader;
<#list 1..c.maxArity as arity>
import com.linkedin.dagli.transformer.PreparableTransformer${arity};
import com.linkedin.dagli.transformer.PreparedTransformer${arity};
import com.linkedin.dagli.transformer.Transformer${arity};
</#list>
import com.linkedin.dagli.dag.DAG;
import com.linkedin.dagli.dag.DAGTransformer;
import com.linkedin.dagli.dag.Graph;
import com.linkedin.dagli.dag.PreparableDAGTransformer;
import com.linkedin.dagli.placeholder.Placeholder;
import com.linkedin.dagli.producer.Producer;
import java.util.function.LongPredicate;
import java.util.stream.Collectors;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Map;
import java.util.Objects;

<#-- Use a macro for this Javadoc blurb to avoid repeating in multiple times -->
<#macro RenderJavadocInputSequences>
 * The inputs to this method take the form of parallel sequences of values.  Each sequence will provide the values
 * for a particular {@link Placeholder} in the DAG (the ordering of the {@link Placeholder}s in a DAG is determined
 * by their ordering in the call to "DAG.withPlaceholders(...)...." that created it).  They are "parallel" because,
 * e.g. all the values corresponding to the fourth example will be the fourth value in their respective input
 * sequences (all sequences must, of course, be equal in size).
</#macro>

<#-- Common Javadoc Blurb Macros -->
<#macro RenderJavadocBegin>
/**
 * Given a {@link Graph} (such as that from a DAG class, e.g. DAG3x2), returns an object that is a rendered
 * visualization of that graph.
</#macro>
<#macro RenderJavadocEnd>
 * @param dag a DAG or other transformer to render; if a (non-DAG) transformer is provided, it is rendered as a DAG
 *        containing that transformer as its sole output and automatically-generated placeholders.
 * @return the rendered graph
 */
</#macro>
<#macro RenderJavadocInputSequenceParameters arity>
<#list 1..arity as index>
 * @param values${c.InputSuffix(index)} the sequence of values for the ${c.positionNames[index]} {@link Placeholder} in the DAG.
</#list>
</#macro>

/**
 * Base class for DAG visualizers, which render a DAG into a (typically human readable) format for documentation and
 * debugging purposes.
 *
 * In addition to the directed acyclic graph of producers, visualizers may also support rendering example data (input,
 * intermediate and output values) as well as <i>subgraphs</i>, which provide a more detailed breakdown of producers
 * (e.g. the architecture of a neural network model).
 *
 * Derived classes just need to implement {@link #render(Graph, List)}.  Visualizers are not required to render all
 * available information (e.g. if unsupported or if rendering everything would mangle the visualization).
 *
 * @param <T> the type of the rendered visualization (e.g. a String or a Bitmap)
 * @param <S> the derived type of visualizer
  */
public abstract class AbstractVisualization<T, S extends AbstractVisualization<T, S>> extends AbstractCloneable<S> {
  private static final long serialVersionUID = 1;

  private Function1.Serializable<Producer<?>, String> _producerToStringFunction =
      Function1.safelySerializable(Producer::getShortName);
  private Function1.Serializable<Object, String> _valueToStringFunction =
      Function1.safelySerializable(Named::getShortName);
  private Function1.Serializable<Object, String> _subgraphNodeToStringFunction =
      Function1.safelySerializable(Named::getShortName);
  private int _maxProducerStringLength = 100;
  private int _maxValueStringLength = 100;
  private int _maxSubgraphNodeStringLength = 100;

  /**
   * Renders a DAG (expressed as a {@link Graph}).
   *
   * This is the only method that derived classes need to implement.
   *
   * @param graph the DAG to be rendered
   * @param producerOutputs a (possibly empty) list of maps, each corresponding to a distinct example, that provide the
   *                        output value for each producer for that example; there is no requirement that outputs for
   *                        all producers must be provided, and there may be extraneous producers present that are not
   *                        part of the DAG
   * @return the rendered DAG
   */
  protected abstract T render(Graph<Producer<?>> graph, List<Map<Producer<?>, Object>> producerOutputs);

  /**
   * Renders a DAG (expressed as a {@link Graph}).
   *
   * @param graph the DAG to be rendered
   * @return the rendered DAG
   */
  public T render(Graph<Producer<?>> graph) {
    return render(graph, Collections.emptyList());
  }

  /**
   * Renders a DAG.
   *
   * @param dag the DAG to be rendered
   * @return the rendered DAG
   */
  public T render(DAGTransformer<?, ?> dag) {
    return render(dag.graph(), Collections.emptyList());
  }

  /**
   * Truncates a String to a maximum length of logical characters (code points).
   *
   * @param string the string that may be truncated if it is indeed longer than the maximum length
   * @param maxLength the maximum length
   * @return the possibly-truncated string, with an added ellipsis ("...") if it was indeed truncated
   */
  private static String truncateToLogicalChars(String string, int maxLength) {
    // get the logical length (in code points)
    return (string.codePointCount(0, string.length()) <= maxLength) ? string
        : string.substring(0, string.offsetByCodePoints(0, Math.max(0, maxLength - 2))) + "...";
  }

  /**
   * @param producer the producer to "render"
   * @return the String representation for the provided {@link Producer}
   */
  protected String renderProducerAsString(Producer<?> producer) {
    return truncateToLogicalChars(_producerToStringFunction.apply(producer), _maxProducerStringLength);
  }

  /**
   * @param value the value to "render"
   * @return the String representation for the provided value
   */
  protected String renderValueAsString(Object value) {
    return truncateToLogicalChars(_valueToStringFunction.apply(value), _maxValueStringLength);
  }

  /**
   * @param node a node from a subgraph that should be "rendered" into a String; subgraph nodes may be of any type
   * @return the String representation for the provided graph node
   */
  protected String renderSubgraphNodeAsString(Object node) {
    return truncateToLogicalChars(_subgraphNodeToStringFunction.apply(node), _maxSubgraphNodeStringLength);
  }

  /**
   * Returns a copy of this instance that will restrict the maximum length of the producer's rendered string description
   * to the specified number of (logical) characters, applying an ellipsis (...) to the end when truncation occurs.  The
   * actual number of displayed characters may still be less due to limits of the visualization medium, however.
   *
   * The default maximum is 100.
   *
   * @param maxLength the maximum number of logical characters to render
   * @return a copy of this instance that will restrict the maximum length of the producer's rendered string description
   */
  public S withMaxProducerStringLength(int maxLength) {
    return clone(c -> ((AbstractVisualization<?, ?>) c)._maxProducerStringLength = maxLength);
  }

  /**
   * Returns a copy of this instance that will restrict the maximum length of each input, intermediate and output
   * value's interpretation as a string to the specified number of (logical) characters, applying an ellipsis (...) to
   * the end when truncation occurs.  The actual number of displayed characters may still be less due to limits of the
   * visualization medium, however.
   *
   * The default maximum is 100.
   *
   * @param maxLength the maximum number of logical characters to render
   * @return a copy of this instance that will restrict the maximum length of the string interpretation of each value
   */
  public S withMaxValueStringLength(int maxLength) {
    return clone(c -> ((AbstractVisualization<?, ?>) c)._maxValueStringLength = maxLength);
  }

  /**
   * Returns a copy of this instance that will restrict the maximum length of each subgraph node's String representation
   * in the rendered visualization to the specified number of (logical) characters, applying an ellipsis (...) to
   * the end when truncation occurs.  The actual number of displayed characters may still be less due to limits of the
   * visualization medium, however.
   *
   * The default maximum is 100.
   *
   * @param maxLength the maximum number of logical characters to render
   * @return a copy of this instance that will restrict the maximum length of the string interpretation of each subgraph
   *         node
   */
  public S withMaxSubgraphNodeStringLength(int maxLength) {
    return clone(c -> ((AbstractVisualization<?, ?>) c)._maxSubgraphNodeStringLength = maxLength);
  }

  /**
   * Creates and returns a copy of this visualizer that will use the specified function to obtain a String
   * representation from each {@link Producer} in the graph.  The default function is {@link Producer#getShortName()}.
   *
   * @param function the Producer-to-String mapping function
   * @return a copy of this visualizer that will use the specified Producer-to-String function
   */
  public S withProducerToStringFunction(Function1.Serializable<Producer<?>, String> function) {
    return clone(c -> ((AbstractVisualization<?, ?>) c)._producerToStringFunction = function);
  }

  /**
   * Creates and returns a copy of this visualizer that will use the specified function to obtain a String
   * representation for example data (input, intermediate and output values).  The default function is
   * {@link Named#getShortName(Object)}.
   *
   * @param function the value-to-String mapping function
   * @return a copy of this visualizer that will use the specified value-to-String function
   */
  public S withValueToStringFunction(Function1.Serializable<Object, String> function) {
    return clone(c -> ((AbstractVisualization<?, ?>) c)._valueToStringFunction = function);
  }

  /**
   * Creates and returns a copy of this visualizer that will use the specified function to obtain a String
   * representation for each subgraph node.  The default function is {@link Named#getShortName(Object)}.
   *
   * @param function the subgraph-node-to-String mapping function
   * @return a copy of this visualizer that will use the specified subgraph-node-to-String function
   */
  public S withSubgraphNodeToStringFunction(Function1.Serializable<Object, String> function) {
    return clone(c -> ((AbstractVisualization<?, ?>) c)._subgraphNodeToStringFunction = function);
  }

<#list 1..c.maxArity as arity>

  <@RenderJavadocBegin />
 *
 * In addition to the graph, the input, intermediate and output values for a single example (whose placeholder values
 * are provided as arguments) will be rendered as part of the graph.
 *
<#list 1..arity as index>
 * @param value${c.InputSuffix(index)} the example's value for the ${c.positionNames[index]} {@link Placeholder} in the DAG.
</#list>
  <@RenderJavadocEnd />
  public <<@c.InputGenericArguments arity />, R> T render(<@c.Transformer arity /> dag, <@c.InputValueList arity />) {
    return render(dag, <#list 1..arity as index>ObjectReader.singleton(value${index})<#sep>, </#list>);
  }

  <@RenderJavadocBegin />
 *
  <@RenderJavadocInputSequences />
 *
 * Only the first example will have its input, intermediate and output values rendered.
 *
  <@RenderJavadocInputSequenceParameters arity />
  <@RenderJavadocEnd />
  public <<@c.InputGenericArguments arity />, R> T render(<@c.Transformer arity /> dag, <@c.ValuesArguments "Iterable" arity />) {
    return render(dag, index -> index == 0, <#list 1..arity as index>values${index}<#sep>, </#list>);
  }

  <@RenderJavadocBegin />
 *
  <@RenderJavadocInputSequences />
 *
 * @param renderExampleValuesPredicate a predicate that returns true when passed an example index iff that example's
 *        input, intermediate and output values should be included as part of rendered graph
  <@RenderJavadocInputSequenceParameters arity />
  <@RenderJavadocEnd />
  public <<@c.InputGenericArguments arity />, R> T render(<@c.Transformer arity /> dag, LongPredicate renderExampleValuesPredicate, <@c.ValuesArguments "Iterable" arity />) {
    // make sure we have a DAG
    DAGTransformer<R, ?> dagTransformer = dag instanceof PreparableTransformer${arity} ? PreparableTransformer${arity}.toDAG((<@c.PreparableTransformer arity "?" />) dag)
        : PreparedTransformer${arity}.toDAG((<@c.PreparedTransformer arity />) dag);

    ProducerToValueMap producerToValueMap = new ProducerToValueMap(
        dagTransformer.producers().map(LinkedStack::peek).collect(Collectors.toList()), renderExampleValuesPredicate);

    // we shouldn't really have to cast to (Placeholder<?>), but the compiler is most insistent
    List<Placeholder<?>> placeholders = dagTransformer.producers(Placeholder.class).map(LinkedStack::peek).map(p -> (Placeholder<?>) p).collect(Collectors.toList());

    // execute the DAG to collect producer output values
    @SuppressWarnings("unchecked")
    final List<Map<Producer<?>, Object>> mapList = new ArrayList<>((dagTransformer instanceof PreparableDAGTransformer) ?
      DAG.withPlaceholders(<#list 1..arity as index>(Placeholder<${c.InputGenericArgument(index)}>) placeholders.get(${index - 1})<#sep>, </#list>)
          .withOutput(producerToValueMap)
          .prepareAndApply(<#list 1..arity as index>values${index}<#sep>, </#list>)
          .toCollection() :
      DAG.Prepared.withPlaceholders(<#list 1..arity as index>(Placeholder<${c.InputGenericArgument(index)}>) placeholders.get(${index - 1})<#sep>, </#list>)
          .withOutput(producerToValueMap)
          .applyAll(<#list 1..arity as index>values${index}<#sep>, </#list>)
          .toCollection());

    // filter any empty maps (corresponding to examples that were not selected by the render example predicate)
    mapList.removeIf(Objects::isNull);

    return render(dagTransformer.graph(), mapList);
  }
</#list>
}
