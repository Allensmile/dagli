// AUTOGENERATED CODE.  DO NOT MODIFY DIRECTLY!  Instead, please modify the math/vector/DenseXBufferVector.ftl file.
// See the README in the module's src/template directory for details.
package com.linkedin.dagli.math.vector;

import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.nio.DoubleBuffer;
import java.util.Arrays;


/**
 * Implementation of a {@link Vector} where the indices of non-zero values are all {@code >= 0}; these values correspond
 * to a specified range within a {@link DoubleBuffer}.  This class can be substantially more efficient than {@link DenseDoubleArrayVector}
 * when the number and length of your vectors are known in advance, because allocating one large {@link DoubleBuffer} to store
 * all the elements is cheaper than allocating many smaller arrays; you also have the opportunity to allocate the
 * {@link DoubleBuffer} as a direct (off-heap) buffer.
 *
 * To attempt to allocate a direct, off-heap {@link DoubleBuffer}, call:
 * <code>ByteBuffer.allocateDirect(4 * [# elements desired]).asDoubleBuffer()</code>
 * (We say "attempt" because in principle not all platforms are guaranteed to support direct allocation.)
 *
 * If serialized, only the portion of the buffer containing vector data is saved, and these values are not "shared"
 * across multiple serialized {@link DenseDoubleBufferVector}s.  Consequently, if you are serializing
 * a large number of "overlapping" vectors, this may require many more serialized bytes than the original memory
 * footprint.  Additionally, when deserialized, the memory footprint may likewise be much larger than the original.
 *
 * Note that the {@link DenseDoubleBufferVector} is tied to the {@link DoubleBuffer} storing its elements; changes to one affect the other.
 */
public final class DenseDoubleBufferVector extends AbstractVector implements MutableDenseVector {
  private static final long serialVersionUID = 1;

  private transient int _offset; // not final so it can be set by readObject
  private final int _length;
  private transient DoubleBuffer _buffer; // not final so it can be set by readObject

  /**
   * Creates a {@link DenseDoubleBufferVector} backed by the provided {@link DoubleBuffer}.  The vector takes as its initial
   * values whatever values there are in the corresponding portion of the DoubleBuffer backing it, and subsequent changes
   * to one will affect the other.  Although the offset may be greater than 0 to point to where the start of the
   * vector's data is in the buffer, the corresponding first element in the created vector always has index 0.
   *
   * @param buffer the underlying {@link DoubleBuffer} that backs this vector
   * @param offset the offset within the DoubleBuffer where this vector begins
   * @param length the length of this vector
   */
  public DenseDoubleBufferVector(DoubleBuffer buffer, int offset, int length) {
    if (buffer == null) {
      throw new NullPointerException("buffer must not be null");
    }
    if (offset < 0) {
      throw new IllegalArgumentException("offset must be >= 0");
    }
    if (length < 0) {
      throw new IllegalArgumentException("length must be >= 0");
    }
    if (offset + length > buffer.capacity()) {
      throw new IllegalArgumentException("the offset + length must not exceed the buffer's capacity");
    }

    _buffer = buffer;
    _offset = offset;
    _length = length;
  }

  private void writeObject(ObjectOutputStream out) throws IOException {
    out.defaultWriteObject(); // writes the length
    for (int i = _offset; i < _offset + _length; i++) {
      out.writeDouble(_buffer.get(i));
    }
  }

  private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
    in.defaultReadObject(); // reads the length
    _offset = 0;
    double[] data = new double[_length];
    for (int i = 0; i < _length; i++) {
      data[i] = in.readDouble();
    }
    _buffer = DoubleBuffer.wrap(data);
  }

  @Override
  public Class<? extends Number> valueType() {
    return double.class;
  }

  @Override
  public double get(long index) {
    if (index >= _length || index < 0) {
      return 0;
    } else {
      return getInternal((int) index);
    }
  }

  @Override
  public void copyTo(double[] dest, int start, int length) {
    _buffer.position(_offset);
    _buffer.get(dest, start, Math.min(_length, length));
    if (length > _length) {
      // zero out remaining array elements
      Arrays.fill(dest, start + _length, start + length, 0);
    }
  }

  @Override
  public VectorElementIterator iterator() {
    return new Iterator();
  }

  @Override
  public VectorElementIterator reverseIterator() {
    return new ReverseIterator();
  }

  @Override
  public long capacity() {
    return _length;
  }

  @Override
  public long maxCapacity() {
    return capacity();
  }

  @Override
  public void put(long index, double value) {
    if (index >= _length) {
      throw new IllegalArgumentException("Index is beyond the mutable length of the vector");
    }

    putInternal((int) index, value);
  }

  private void putInternal(int index, double value) {
    _buffer.put(_offset + index, value);
  }

  private double getInternal(int index) {
    return _buffer.get(_offset + index);
  }

  @Override
  public void transformInPlace(VectorElementTransformer transformer) {
    for (int i = 0; i < _length; i++) {
      double value = getInternal(i);
      if (value != 0) {
        putInternal(i, transformer.transform(i, value));
      }
    }
  }

  @Override
  public void addInPlace(Vector other) {
    if (other instanceof DenseDoubleBufferVector) { // an opportunity to optimize aplenty
      addInPlace((DenseDoubleBufferVector) other);
    } else { // do the standard thing
      MutableDenseVector.super.addInPlace(other);
    }
  }

  public void addInPlace(DenseDoubleBufferVector vec) {
    for (int i = 0; i < _length; i++) {
      putInternal(i, getInternal(i) + vec.getInternal(i));
    }
    for (int i = _length; i < vec._length; i++) {
      if (vec.getInternal(i) != 0.0f) {
        throw new IndexOutOfBoundsException(
            "Attempted to modify DenseDoubleBufferVector vector element beyond its length");
      }
    }
  }

  private class Iterator implements VectorElementIterator {
    private int _index = 0;

    @Override
    public void forEachRemaining(VectorElementConsumer consumer) {
      for (; _index < _length; _index++) {
        double val = getInternal(_index);
        if (val != 0) {
          consumer.consume(_index, val);
        }
      }
    }

    @Override
    public <T> T mapNext(VectorElementFunction<T> mapper) {
      double val;
      while ((val = getInternal(_index)) == 0) {
        _index++;
      }
      return mapper.apply(_index++, val);
    }

    @Override
    public void next(VectorElementConsumer consumer) {
      double val;
      while ((val = getInternal(_index)) == 0) {
        _index++;
      }
      consumer.consume(_index++, val);
    }

    @Override
    public boolean hasNext() {
      for (; _index < _length; _index++) {
        if (getInternal(_index) != 0) {
          return true;
        }
      }

      return false;
    }
  }

  private class ReverseIterator implements VectorElementIterator {
    private int _index = _length - 1;

    @Override
    public void forEachRemaining(VectorElementConsumer consumer) {
      for (; _index >= 0; _index--) {
        double val = getInternal(_index);
        if (val != 0) {
          consumer.consume(_index, val);
        }
      }
    }

    @Override
    public <T> T mapNext(VectorElementFunction<T> mapper) {
      double val;
      while ((val = getInternal(_index)) == 0) {
        _index--;
      }
      return mapper.apply(_index--, val);
    }

    @Override
    public void next(VectorElementConsumer consumer) {
      double val;
      while ((val = getInternal(_index)) == 0) {
        _index--;
      }
      consumer.consume(_index--, val);
    }

    @Override
    public boolean hasNext() {
      for (; _index >= 0; _index--) {
        if (getInternal(_index) != 0) {
          return true;
        }
      }

      return false;
    }
  }
}
