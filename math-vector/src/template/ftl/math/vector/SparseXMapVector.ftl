<#import "../../common.ftl" as c />
<#import "common.ftl" as v />
<@c.AutoGeneratedWarning />
package com.linkedin.dagli.math.vector;

<#assign primitiveType = v.primitiveTypes[typeIndex]>
<#assign boxedType = v.boxedTypes[typeIndex]>
<#assign bufferType = v.bufferType(typeIndex)>

import it.unimi.dsi.fastutil.Hash;
import it.unimi.dsi.fastutil.longs.Long2${boxedType}Map;
import it.unimi.dsi.fastutil.longs.Long2${boxedType}OpenHashMap;
import it.unimi.dsi.fastutil.longs.LongArrayList;
import it.unimi.dsi.fastutil.objects.ObjectIterator;
import java.io.Serializable;


/**
 * Implementation of a (sparse) {@link Vector} using ${primitiveType} values and backed by a hashtable.
 *
 * This implementation is efficient when modification and iteration are not interleaved: the elements must be resorted
 * when {@link #iterator()} or {@link #reverseIterator()} is called if the vector has changed since the previous call.
 * Note that caching the sorted values means that this class is also relatively memory inefficient compared to a
 * {@link <@v.SparseArrayVector typeIndex />}.
 */
public class <@v.SparseMapVector typeIndex /> extends AbstractVector implements MutableVector, Serializable {
  private static final long serialVersionUID = 1;

  private final Long2${boxedType}OpenHashMap _vectorMap;

  // used to cache a SparseArrayVector that provides sorted element iterators when needed; this must be recalculated
  // whenever an entry is added or removed to the _vectorMap.  Using a self-balancing tree as our primary data
  // structure would avoid the need for this extra cached data, but we operate under the premise that iteration and
  // modification are almost never interleaved.
  private transient <@v.SparseArrayVector typeIndex /> _cachedSparseArrayVector = null;

  /**
   * Create a new vector with the default initial capacity.
   */
  public <@v.SparseMapVector typeIndex />() {
    this(Hash.DEFAULT_INITIAL_SIZE);
  }

  /**
   * Create a new vector with the specified initial capacity.
   *
   * @param initialCapacity the number of vector components to pre-allocate space for.  The vector can still have more
   *                        entries than this, of course--it will automatically grow as needed.
   */
  public <@v.SparseMapVector typeIndex />(int initialCapacity) {
    _vectorMap = new Long2${boxedType}OpenHashMap(initialCapacity);
  }

  @Override
  public Class<? extends Number> valueType() {
    return ${primitiveType}.class;
  }

  @Override
  public long size64() {
    return _vectorMap.size();
  }

  @Override
  public double increase(long index, double amount) {
    // addTo returns the *previous* value
    ${primitiveType} result = _vectorMap.addTo(index, <@v.CastDoubleToType typeIndex>amount</@v.CastDoubleToType>);
    if (result == 0) { // adding new entry
      _cachedSparseArrayVector = null;
    }
    if ((result + (<@v.CastDoubleToType typeIndex>amount</@v.CastDoubleToType>)) == 0) {
      _cachedSparseArrayVector = null;
      _vectorMap.remove(index);
    }
    return result;
  }

  @Override
  public double get(long index) {
    return _vectorMap.get(index);
  }


  /**
   * Sets the value of a particular index in the vector.  Values of 0 are not stored explicitly; putting a value of 0
   * thus removes the element from this instance's backing hashtable.
   *
   * @param index the index of the value
   * @param value the value to be put
   * @return the value previously associated with the index
   */
  public ${primitiveType} getAndSet(long index, ${primitiveType} value) {
    final ${primitiveType} result;
    if (value == 0) {
      result = _vectorMap.remove(index);
      if (result != 0) { // deleted an entry
        _cachedSparseArrayVector = null;
      }
    } else {
      result = _vectorMap.put(index, value);
      if (result == 0) { // added an entry
        _cachedSparseArrayVector = null;
      }
    }
    return result;
  }

  @Override
  public void put(long index, double value) {
    getAndSet(index, <@v.CastDoubleToType typeIndex>value</@v.CastDoubleToType>);
  }

  @Override
  public void transformInPlace(VectorElementTransformer transformer) {
    LongArrayList lal = new LongArrayList(4);
    _vectorMap.long2${boxedType}EntrySet().fastForEach(keyAndValuePair -> {
      long key = keyAndValuePair.getLongKey();

      ${primitiveType} res = <@v.CastDoubleToType typeIndex>transformer.transform(key, keyAndValuePair.get${boxedType}Value())</@v.CastDoubleToType>;
      if (res != 0) {
        // can safely modify entries while iterating
        _vectorMap.put(key, res);
      } else {
        // cannot safely delete here, because the map enforces a minimum load factor and might resize
        lal.add(key);
      }
    });

    lal.forEach((long v) -> _vectorMap.remove(v));
  }

  private class UnorderedIterator implements VectorElementIterator {
    private ObjectIterator<Long2${boxedType}OpenHashMap.Entry> _iterator = _vectorMap.long2${boxedType}EntrySet().fastIterator();

    @Override
    public <T> T mapNext(VectorElementFunction<T> mapper) {
      Long2${boxedType}OpenHashMap.Entry nextVal = _iterator.next();
      return mapper.apply(nextVal.getLongKey(), nextVal.get${boxedType}Value());
    }

    @Override
    public void next(VectorElementConsumer consumer) {
      Long2${boxedType}OpenHashMap.Entry nextVal = _iterator.next();
      consumer.consume(nextVal.getLongKey(), nextVal.get${boxedType}Value());
    }

    @Override
    public boolean hasNext() {
      return _iterator.hasNext();
    }
  }

  private void ensureCachedSparseArrayVector() {
    if (_cachedSparseArrayVector == null) {
      long[] indices = new long[_vectorMap.size()];
      ${primitiveType}[] values = new ${primitiveType}[_vectorMap.size()];

      ObjectIterator<Long2${boxedType}Map.Entry> iterator = _vectorMap.long2${boxedType}EntrySet().fastIterator();
      for (int offset = 0; offset < indices.length; offset++) {
        Long2${boxedType}Map.Entry entry = iterator.next();
        indices[offset] = entry.getLongKey();
        values[offset] = entry.get${boxedType}Value();
      }

      _cachedSparseArrayVector = <@v.SparseArrayVector typeIndex />.wrap(indices, values);
    }
  }

  @Override
  public VectorElementIterator unorderedIterator() {
    return new UnorderedIterator();
  }

  @Override
  public VectorElementIterator iterator() {
    ensureCachedSparseArrayVector();
    return _cachedSparseArrayVector.iterator();
  }

  @Override
  public VectorElementIterator reverseIterator() {
    ensureCachedSparseArrayVector();
    return _cachedSparseArrayVector.reverseIterator();
  }
}

