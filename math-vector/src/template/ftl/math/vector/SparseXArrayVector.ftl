<#import "../../common.ftl" as c />
<#import "common.ftl" as v />
<@c.AutoGeneratedWarning />
package com.linkedin.dagli.math.vector;

<#assign primitiveType = v.primitiveTypes[typeIndex]>
<#assign boxedType = v.boxedTypes[typeIndex]>
<#assign bufferType = v.bufferType(typeIndex)>

import com.linkedin.dagli.tuple.Tuple2;
import com.linkedin.dagli.util.array.ArraysEx;
import java.io.Serializable;
import java.util.Arrays;
import java.util.OptionalLong;

/**
 * Memory-efficient, read-only sparse vector that stores its data in sorted arrays.
 */
public class <@v.SparseArrayVector typeIndex /> extends AbstractVector implements Serializable {
  private static final long serialVersionUID = 1;

  private final long[] _indices;
  private final ${primitiveType}[] _values;

  /**
   * Creates a sparse sorted vector with by copying elements from another vector.  The copied vector must not have more
   * non-zero elements than the largest array size supported by the JVM (usually slightly less than
   * {@link Integer#MAX_VALUE}).
   *
   * @param other A vector whose values will be copied.
   */
  public <@v.SparseArrayVector typeIndex />(Vector other) {
    this(other.iterator(), Math.toIntExact(other.size64()));
  }

  /**
   * Creates a sparse sorted vector by copying the elements in a com.linkedin.dagli.util.stream of VectorElements.
   *
   * @param iterator An iterator over the vector elements.  Zero-valued elements will be filtered out.
   * @param nonZeroCount The estimated number of non-zero valued elements in this com.linkedin.dagli.util.stream.  Must be greater or equal to
   *                     the true number of non-zeros or an out-of-range exception will result.
   */
  private <@v.SparseArrayVector typeIndex />(VectorElementIterator iterator, int nonZeroCount) {
    this(indexAndValueArraysFromVectorIterator(iterator, nonZeroCount));
  }

  /**
   * Unpacks index and value arrays from tuple and forwards them to the appropriate constructor
   */
  private <@v.SparseArrayVector typeIndex />(Tuple2<long[], ${primitiveType}[]> indexAndValueArrays) {
    this(indexAndValueArrays.get0(), indexAndValueArrays.get1(), true);
  }

  private static Tuple2<long[], ${primitiveType}[]> indexAndValueArraysFromVectorIterator(VectorElementIterator iterator,
      int nonZeroCount) {
    final long[] indices = new long[nonZeroCount];
    final ${primitiveType}[] values = new ${primitiveType}[nonZeroCount];
    int[] offset = new int[1];

    iterator.forEachRemaining((index, value) -> {
      indices[offset[0]] = index;
      values[offset[0]] = <@v.CastDoubleToType typeIndex>value</@v.CastDoubleToType>;
      offset[0]++;
    });

    return filterSortAndDeduplicateArrays(indices, values);
  }

  /**
   * Creates a {@link <@v.SparseArrayVector typeIndex />} from the provided arrays, which need not be sorted and can contain zero
   * values.  If duplicate indices are present and correspond to different non-zero values, which value is used is
   * determined arbitrarily.
   *
   * Unlike {@link #<@v.SparseArrayVector typeIndex />(long[], ${primitiveType}[])}, here <strong>the vector takes ownership of the passed
   * arrays</strong>: they may be modified and possibly stored by the vector, and must not be subsequently used by the
   * client.  The benefit of this method is increased efficiency, as it reduces the number of array copies made.
   *
   * @param indices Indices of the vector elements
   * @param values The (non-zero) values corresponding to the indices.
   */
  public static <@v.SparseArrayVector typeIndex /> wrap(long[] indices, ${primitiveType}[] values) {
    return new <@v.SparseArrayVector typeIndex />(filterSortAndDeduplicateArrays(indices, values));
  }

  /**
   * Creates a {@link <@v.SparseArrayVector typeIndex />} from the provided arrays, which need not be sorted and can contain zero
   * values.  If duplicate indices are present and correspond to different non-zero values, which value is used is
   * determined arbitrarily.
   *
   * @param indices Indices of the vector elements
   * @param values The values corresponding to the indices.
   */
  public <@v.SparseArrayVector typeIndex />(long[] indices, ${primitiveType}[] values) {
    this(filterSortAndDeduplicateArrays(indices.clone(), values.clone()));
  }

  /**
   * Prepares index and value arrays for use in this class by:
   * (1) Removing zero-value elements
   * (2) Sorting elements by index
   * (3) Removing duplicate-index elements
   *
   * <strong>Passed arrays will be modified.</strong>
   *
   * @param indices Indices of the vector elements
   * @param values The values corresponding to the indices.
   * @return a tuple containing the final index and value arrays; these may not be the same as those passed to this
   *         method.
   */
  private static Tuple2<long[], ${primitiveType}[]> filterSortAndDeduplicateArrays(long[] indices, ${primitiveType}[] values) {
    // sort the input indices
    ArraysEx.sort(indices, values);

    // look for duplicates and zeros; discard any that are found
    int shift = 0;
    long previous = 0; // value doesn't matter
    boolean hasPrevious = false;
    for (int i = 0; i < indices.length; i++) {
      if ((indices[i] == previous && hasPrevious) || values[i] == 0) {
        shift++;
        continue;
      }

      if (shift > 0) {
        indices[i - shift] = indices[i];
        values[i - shift] = values[i];
      }
      previous = indices[i];
      hasPrevious = true;
    }

    if (shift > 0) {
      indices = Arrays.copyOf(indices, indices.length - shift);
      values = Arrays.copyOf(values, values.length - shift);
    }

    return Tuple2.of(indices, values);
  }

  /**
   * Creates a {@link <@v.SparseArrayVector typeIndex />} from the provided arrays where:
   * (1) "indices" is sorted
   * (2) "values" has only non-zero values
   * (3) "indices" has no duplicates
   *
   * The passed arrays, and not copies, are stored, and must not subsequently be modified--the vector takes ownership of
   * them.
   *
   * @param indices Indices of the vector elements
   * @param values The (non-zero) values corresponding to the indices
   * @param dummyVar dummy parameter to distinguish from the otherwise-identical public constructor
   */
  private <@v.SparseArrayVector typeIndex />(long[] indices, ${primitiveType}[] values, boolean dummyVar) {
    _indices = indices;
    _values = values;
  }

  /**
   * Private no-args constructor specifically for the benefit of Kryo
   */
  private <@v.SparseArrayVector typeIndex />() {
    this(null, null, true); // nulls ensure deserialization failures are obvious
  }

  @Override
  public Class<? extends Number> valueType() {
    return ${primitiveType}.class;
  }

  @Override
  public long size64() {
    return _indices.length;
  }

  private class Iterator implements VectorElementIterator {
    private int _offset = 0;

    @Override
    public <T> T mapNext(VectorElementFunction<T> mapper) {
      return mapper.apply(_indices[_offset], _values[_offset++]);
    }

    @Override
    public void next(VectorElementConsumer consumer) {
      consumer.consume(_indices[_offset], _values[_offset++]);
    }

    @Override
    public boolean hasNext() {
      return _offset < _indices.length;
    }
  }

  private class ReverseIterator implements VectorElementIterator {
    private int _offset = _indices.length - 1;

    @Override
    public <T> T mapNext(VectorElementFunction<T> mapper) {
      return mapper.apply(_indices[_offset], _values[_offset--]);
    }

    @Override
    public void next(VectorElementConsumer consumer) {
      consumer.consume(_indices[_offset], _values[_offset--]);
    }

    @Override
    public boolean hasNext() {
      return _offset >= 0;
    }
  }

  @Override
  public VectorElementIterator iterator() {
    return new Iterator();
  }

  @Override
  public VectorElementIterator reverseIterator() {
    return new ReverseIterator();
  }

  @Override
  public double get(long index) {
    int offset = Arrays.binarySearch(_indices, index);
    return offset < 0 ? 0.0 : _values[offset];
  }

  @Override
  public OptionalLong minNonZeroElementIndex() {
    return _indices.length > 0 ? OptionalLong.of(_indices[0]) : OptionalLong.empty();
  }

  @Override
  public OptionalLong maxNonZeroElementIndex() {
    return _indices.length > 0 ? OptionalLong.of(_indices[_indices.length - 1]) : OptionalLong.empty();
  }
}
