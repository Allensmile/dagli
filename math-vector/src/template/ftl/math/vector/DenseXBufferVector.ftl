<#import "../../common.ftl" as c />
<#import "common.ftl" as v />
<@c.AutoGeneratedWarning />
package com.linkedin.dagli.math.vector;

<#assign primitiveType = v.primitiveTypes[typeIndex]>
<#assign boxedType = v.boxedTypes[typeIndex]>
<#assign bufferType = v.bufferType(typeIndex)>

import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.nio.${bufferType};
import java.util.Arrays;

/**
 * Implementation of a {@link Vector} where the indices of non-zero values are all >= 0; these values correspond to
 * a specified range within a {@link ${bufferType}}.  This class can be substantially more efficient than {@link <@v.DenseVector typeIndex />}
 * when the number and length of your vectors are known in advance, because allocating one large {@link ${bufferType}} to store
 * all the elements is cheaper than allocating many smaller arrays; you also have the opportunity to allocate the
 * {@link ${bufferType}} as a direct (off-heap) buffer.
 *
 * To attempt to allocate a direct, off-heap {@link ${bufferType}}, call:
 * <code>ByteBuffer.allocateDirect(4 * [# elements desired]).as${bufferType}()</code>
 * (We say "attempt" because in principle not all platforms are guaranteed to support direct allocation.)
 *
 * If serialized, only the portion of the buffer containing vector data is saved, and these values are not "shared"
 * across multiple serialized {@link <@v.DenseBufferVector typeIndex />}s.  Consequently, if you are serializing
 * a large number of "overlapping" vectors, this may require many more serialized bytes than the original memory
 * footprint.  Additionally, when deserialized, the memory footprint may likewise be much larger than the original.
 *
 * Note that the {@link <@v.DenseBufferVector typeIndex />} is tied to the {@link ${bufferType}} storing its elements; changes to one affect the other.
 */
public final class <@v.DenseBufferVector typeIndex /> extends AbstractVector implements MutableDenseVector {
  private static final long serialVersionUID = 1;

  private transient int _offset; // not final so it can be set by readObject
  private final int _length;
  private transient ${bufferType} _buffer; // not final so it can be set by readObject

  /**
   * Creates a {@link <@v.DenseBufferVector typeIndex />} backed by the provided {@link ${bufferType}}.  The vector takes as its initial
   * values whatever values there are in the corresponding portion of the ${bufferType} backing it, and subsequent changes
   * to one will affect the other.  Although offset may be > 0 to point to where the start of the vector's data is in
   * the buffer, the corresponding first element in the created vector always has index 0.
   *
   * @param buffer the underlying {@link ${bufferType}} that backs this vector
   * @param offset the offset within the ${bufferType} where this vector begins
   * @param length the length of this vector
   */
  public <@v.DenseBufferVector typeIndex />(${bufferType} buffer, int offset, int length) {
    if (buffer == null) {
      throw new NullPointerException("buffer must not be null");
    }
    if (offset < 0) {
      throw new IllegalArgumentException("offset must be >= 0");
    }
    if (length < 0) {
      throw new IllegalArgumentException("length must be >= 0");
    }
    if (offset + length > buffer.capacity()) {
      throw new IllegalArgumentException("the offset + length must not exceed the buffer's capacity");
    }

    _buffer = buffer;
    _offset = offset;
    _length = length;
  }

  private void writeObject(ObjectOutputStream out) throws IOException {
    out.defaultWriteObject(); // writes the length
    for (int i = _offset; i < _offset + _length; i++) {
      out.write${boxedType}(_buffer.get(i));
    }
  }

  private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
    in.defaultReadObject(); // reads the length
    _offset = 0;
    ${primitiveType}[] data = new ${primitiveType}[_length];
    for (int i = 0; i < _length; i++) {
      data[i] = in.read${boxedType}();
    }
    _buffer = ${bufferType}.wrap(data);
  }

  @Override
  public Class<? extends Number> valueType() {
    return ${primitiveType}.class;
  }

  @Override
  public double get(long index) {
    if (index >= _length || index < 0) {
      return 0;
    } else {
      return getInternal((int) index);
    }
  }

  @Override
  public void copyTo(${primitiveType}[] dest, int start, int length) {
    _buffer.position(_offset);
    _buffer.get(dest, start, Math.min(_length, length));
    if (length > _length) {
      // zero out remaining array elements
      Arrays.fill(dest, start + _length, start + length, 0);
    }
  }

  @Override
  public VectorElementIterator iterator() {
    return new Iterator();
  }

  @Override
  public VectorElementIterator reverseIterator() {
    return new ReverseIterator();
  }

  @Override
  public long capacity() {
    return _length;
  }

  @Override
  public long maxCapacity() {
    return capacity();
  }

  @Override
  public void put(long index, double value) {
    if (index >= _length) {
      throw new IllegalArgumentException("Index is beyond the mutable length of the vector");
    }

    putInternal((int) index, <@v.CastDoubleToType typeIndex>value</@v.CastDoubleToType>);
  }

  private void putInternal(int index, ${primitiveType} value) {
    _buffer.put(_offset + index, value);
  }

  private ${primitiveType} getInternal(int index) {
    return _buffer.get(_offset + index);
  }

  @Override
  public void transformInPlace(VectorElementTransformer transformer) {
    for (int i = 0; i < _length; i++) {
      ${primitiveType} value = getInternal(i);
      if (value != 0) {
        putInternal(i, <@v.CastDoubleToType typeIndex>transformer.transform(i, value)</@v.CastDoubleToType>);
      }
    }
  }

  @Override
  public void addInPlace(Vector other) {
    if (other instanceof <@v.DenseBufferVector typeIndex />) { // an opportunity to optimize aplenty
      addInPlace((<@v.DenseBufferVector typeIndex />) other);
    } else { // do the standard thing
      MutableDenseVector.super.addInPlace(other);
    }
  }

  public void addInPlace(<@v.DenseBufferVector typeIndex /> vec) {
    for (int i = 0; i < _length; i++) {
      putInternal(i, getInternal(i) + vec.getInternal(i));
    }
    for (int i = _length; i < vec._length; i++) {
      if (vec.getInternal(i) != 0.0f) {
        throw new IndexOutOfBoundsException(
            "Attempted to modify <@v.DenseBufferVector typeIndex /> vector element beyond its length");
      }
    }
  }

  private class Iterator implements VectorElementIterator {
    private int _index = 0;

    @Override
    public void forEachRemaining(VectorElementConsumer consumer) {
      for (; _index < _length; _index++) {
        ${primitiveType} val = getInternal(_index);
        if (val != 0) {
          consumer.consume(_index, val);
        }
      }
    }

    @Override
    public <T> T mapNext(VectorElementFunction<T> mapper) {
      ${primitiveType} val;
      while ((val = getInternal(_index)) == 0) {
        _index++;
      }
      return mapper.apply(_index++, val);
    }

    @Override
    public void next(VectorElementConsumer consumer) {
      ${primitiveType} val;
      while ((val = getInternal(_index)) == 0) {
        _index++;
      }
      consumer.consume(_index++, val);
    }

    @Override
    public boolean hasNext() {
      for (; _index < _length; _index++) {
        if (getInternal(_index) != 0) {
          return true;
        }
      }

      return false;
    }
  }

  private class ReverseIterator implements VectorElementIterator {
    private int _index = _length - 1;

    @Override
    public void forEachRemaining(VectorElementConsumer consumer) {
      for (; _index >= 0; _index--) {
        ${primitiveType} val = getInternal(_index);
        if (val != 0) {
          consumer.consume(_index, val);
        }
      }
    }

    @Override
    public <T> T mapNext(VectorElementFunction<T> mapper) {
      ${primitiveType} val;
      while ((val = getInternal(_index)) == 0) {
        _index--;
      }
      return mapper.apply(_index--, val);
    }

    @Override
    public void next(VectorElementConsumer consumer) {
      ${primitiveType} val;
      while ((val = getInternal(_index)) == 0) {
        _index--;
      }
      consumer.consume(_index--, val);
    }

    @Override
    public boolean hasNext() {
      for (; _index >= 0; _index--) {
        if (getInternal(_index) != 0) {
          return true;
        }
      }

      return false;
    }
  }
}
