<#import "../../common.ftl" as c />
<#import "common.ftl" as f />
<@c.AutoGeneratedWarning />
package com.linkedin.dagli.util.function;

import java.io.IOException;
import java.lang.invoke.LambdaMetafactory;
import java.lang.invoke.MethodHandle;
import java.lang.invoke.MethodType;

<#-- the class name of the function interface we're going to define -->
<#macro NakedFunctionName>${f.Prefix(typeIndex)}Function${arity}</#macro>
<#macro FunctionName><@NakedFunctionName /><@f.GenericArgs typeIndex arity /></#macro>
<#macro SerializableFunctionName><@NakedFunctionName />.Serializable<@f.GenericArgs typeIndex arity /></#macro>

<#macro NakedClassName>${f.Prefix(typeIndex)}MethodReference${arity}</#macro>
<#macro ClassName><@NakedClassName /><@f.GenericArgs typeIndex arity /></#macro>

/**
 * Represents a safely serializable method reference (assuming the JVM supports {@link MethodReference}, which is not
 * guaranteed).  If the JVM does not support {@link MethodReference}, an exception may be thrown when creating the
 * method reference; fortunately, however, deserialization will not be affected: if you can serialize it, you'll be able
 * to deserialize later on any JVM.
 */
class <@ClassName /> implements <@SerializableFunctionName /> {
  private static final long serialVersionUID = 1;

  // hash and equality distinguish between different types of MethodReferenceX classes even when the underlying method
  // references are identical
  private static final int CLASS_HASH = <@NakedClassName />.class.hashCode();

  private final MethodReference _methodReference;
  private transient <@FunctionName /> _cachedFunction = null;

  <@NakedClassName />(MethodReference mr) {
    _methodReference = mr;
    initCachedFunction();
  }

  /**
   * Creates a new instance.
   *
   * The passed func parameter must be a method reference, such as Object::toString or String::length.  A runtime
   * exception will be thrown if func is a function object or an anonymous lambda (e.g. "a -> a + 5").  An exception
   * may also be thrown if your JVM implementation does not support the library's internal method for retrieving
   * information about the passed method reference.
   *
   * @param func a method reference lambda to wrap.  If this function is not safely serializable, a runtime exception
   *        will be thrown.
   */
  public <@NakedClassName />(Serializable<@f.GenericArgs typeIndex arity /> func) {
    if (func instanceof <@NakedClassName />) {
      // multiple applications of this constructor are idempotent:
      _methodReference = ((<@NakedClassName />) func)._methodReference;
    } else {
      // this line will thrown an exception if func is not a method reference:
      _methodReference = new MethodReference(func);
    }
    initCachedFunction();
  }

  // deserialization hook to ensure _cachedFunction is always set
  private void readObject(java.io.ObjectInputStream in) throws IOException, ClassNotFoundException {
    in.defaultReadObject();
    initCachedFunction();
  }

  private void initCachedFunction() {
    if (_cachedFunction == null) {
      _cachedFunction = fromMethodReference();
    }
  }

  private <@FunctionName /> fromMethodReference() {
    <#if (arity <= f.MaxPublicArity)>
    if (_methodReference.isBound()) {
      ${f.Prefix(typeIndex)}MethodReference${arity + 1}<Object<#if (arity > 0)>, <@c.InputGenericArguments arity /></#if><#if (typeIndex == f.GenericFunctionIndex)>, R</#if>> unbound
        = new ${f.Prefix(typeIndex)}MethodReference${arity + 1}<>(_methodReference.unbind());
      return (<@c.InputValueList arity />) -> unbound.apply(_methodReference.getBoundInstance()<#if (arity > 0)>, <@c.InputSuffixedList "value" arity /></#if>);
    }
    </#if>

    MethodHandle mh = _methodReference.getMethodHandle();

    try {
      MethodType type = mh.type().generic()<#if typeIndex != f.GenericFunctionIndex>.changeReturnType(${f.ReturnedPrimitiveName(typeIndex)}.class)</#if>;
      return (<@FunctionName />) LambdaMetafactory.metafactory(_methodReference.getLookup(), "apply", MethodType.methodType(<@NakedFunctionName />.class), type, mh,
          mh.type().wrap()<#if typeIndex != f.GenericFunctionIndex>.changeReturnType(${f.ReturnedPrimitiveName(typeIndex)}.class)</#if>).getTarget().invokeExact();
    } catch (Throwable e) {
      throw new RuntimeException(e);
    }
  }

  public ${f.ReturnedPrimitiveName(typeIndex)} apply(<@c.InputValueList arity />) {
    <#if typeIndex != f.VoidFunctionIndex>return </#if>_cachedFunction.apply(<@c.InputSuffixedList "value" arity />);
  }

  @Override
  public int hashCode() {
    return CLASS_HASH + _methodReference.hashCode();
  }

  @Override
  public boolean equals(Object obj) {
    if (!(obj instanceof <@NakedClassName />)) {
      return false;
    }

    return _methodReference.equals(((<@NakedClassName />) obj)._methodReference);
  }

  @Override
  public String toString() {
    return _methodReference.toString();
  }
}