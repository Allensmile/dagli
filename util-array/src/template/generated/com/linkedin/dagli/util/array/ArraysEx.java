// AUTOGENERATED CODE.  DO NOT MODIFY DIRECTLY!  Instead, please modify the util/array/ArraysEx.ftl file.
// See the README in the module's src/template directory for details.

package com.linkedin.dagli.util.array;

import com.linkedin.dagli.util.closeable.Closeables;
import com.linkedin.dagli.util.collection.Iterables;
import com.linkedin.dagli.util.invariant.Arguments;
import java.lang.reflect.Array;
import java.util.Arrays;
import java.util.function.Function;
import java.util.function.IntFunction;
import java.util.Objects;
import java.util.function.Predicate;

import it.unimi.dsi.fastutil.booleans.BooleanArrayList;

import it.unimi.dsi.fastutil.bytes.ByteArrayList;

import it.unimi.dsi.fastutil.chars.CharArrayList;

import it.unimi.dsi.fastutil.shorts.ShortArrayList;

import it.unimi.dsi.fastutil.ints.IntArrayList;

import it.unimi.dsi.fastutil.longs.LongArrayList;

import it.unimi.dsi.fastutil.floats.FloatArrayList;

import it.unimi.dsi.fastutil.doubles.DoubleArrayList;


/**
 * Utility methods for working with arrays.  These methods build on those provided by the {@link java.util.Arrays}
 * class.
 */
public abstract class ArraysEx {
  private ArraysEx() {
  }

  /**
   * Filters a range of elements in an array "in-place", according to a given {@code predicate}.
   *
   * After filtering, the {@code n} elements in the range for which {@code predicate} returned true will be placed
   * at the beginning of the range (starting at position {@code offset}) while the {@code count - n} elements in the
   * range will be replaced will {@code null}s.  The relative order of the kept items will remain the same.
   *
   * All elements outside the filtered range will be unmodified.
   *
   * @param array the array whose items should be filtered
   * @param startInclusive the first index of the range in {@code array} that should be filtered
   * @param endExclusive the end of the range (exclusive) in {@code array} to be filtered
   * @param predicate the predicate used to test whether an element should be kept
   * @return the number of elements in the range that were kept
   * @param <T> the type of element in the array
   */
  public static <T> int filterInPlace(T[] array, int startInclusive, int endExclusive, Predicate<? super T> predicate) {
    int nextDestination = startInclusive;
    for (int i = startInclusive; i < endExclusive; i++) {
      if (predicate.test(array[i])) {
        array[nextDestination++] = array[i];
      }
    }

    // fill remaining elements with nulls
    Arrays.fill(array, nextDestination, endExclusive, null);

    // return number of kept items
    return nextDestination - startInclusive;
  }

  /**
   * Copies a range of elements from a source array to a new array, possibly of a different type.  This method duplicates
   * the behavior of {@link Arrays#copyOfRange( Object[], int, int, Class)}; the difference between these methods is
   * that this method accepts an array generation function (typically the array's constructor) rather than an array
   * class.
   *
   * See {@link Arrays#copyOfRange( Object[], int, int, Class)} for more details.
   *
   * @param source the original array to copy
   * @param startInclusive where copying should begin in the source array
   * @param endExclusive where copying should end in the source array, exclusive (that is, elements at indices up to, but
   *                     not including, this index)
   * @param arrayConstructor a method that, given an array length, returns an array to receive the copied elements
   * @param <S> the element type of the source array
   * @param <T> the element type of the copy array
   * @return a (partial) copy of the provided array
   */
  public static <S extends T, T> T[] copyOfRange(S[] source, int startInclusive, int endExclusive,
      IntFunction<T[]> arrayConstructor) {
    Arguments.check(startInclusive <= endExclusive, "Start position cannot be later than the end");

    T[] result = arrayConstructor.apply(endExclusive - startInclusive);
    System.arraycopy(source, startInclusive, result, 0, Math.min(source.length - startInclusive, result.length));

    return result;
  }

  /**
   * Copies a the elements of a source array to a new array, possibly of a different type.  This method duplicates
   * the behavior of {@link Arrays#copyOf( Object[], int, Class)}; the difference between these methods is
   * that this method accepts an array generation function (typically the array's constructor) rather than an array
   * class.
   *
   * See {@link Arrays#copyOf( Object[], int, Class)} for more details.
   *
   * @param source the original array to copy
   * @param newLength the length of the result that will be returned (may be longer or shorter than <code>source</code>)
   * @param arrayConstructor a method that, given an array length, returns an array to receive the copied elements
   * @param <S> the element type of the source array
   * @param <T> the element type of the copy array
   * @return a copy of the provided array with the requested length
   */
  public static <S extends T, T> T[] copyOf(S[] source, int newLength, IntFunction<T[]> arrayConstructor) {
    return copyOfRange(source, 0, newLength, arrayConstructor);
  }

  /**
   * Analogous to {@link Arrays#deepToString(Object[])}, but computes the String representation for any type of object,
   * including Object arrays, primitive arrays, and non-arrays.
   */
  public static String deepToString(Object obj) {
    if (obj instanceof Object[]) {
      return Arrays.deepToString((Object[]) obj);
    } else if (obj instanceof boolean[]) {
      return Arrays.toString((boolean[]) obj);
    } else if (obj instanceof byte[]) {
      return Arrays.toString((byte[]) obj);
    } else if (obj instanceof char[]) {
      return Arrays.toString((char[]) obj);
    } else if (obj instanceof short[]) {
      return Arrays.toString((short[]) obj);
    } else if (obj instanceof int[]) {
      return Arrays.toString((int[]) obj);
    } else if (obj instanceof long[]) {
      return Arrays.toString((long[]) obj);
    } else if (obj instanceof float[]) {
      return Arrays.toString((float[]) obj);
    } else if (obj instanceof double[]) {
      return Arrays.toString((double[]) obj);
    }

    return Objects.toString(obj);
  }

  /**
   * Concatenates one or more arrays.
   *
   * @param arrays one or more arrays to concatenate
   * @param <T> the type of the arrays
   * @return the concatenated array
   */
  @SafeVarargs
  @SuppressWarnings("unchecked")
  // we use reflection to create a result array of the right concrete type
  public static <T> T[] concat(T[]... arrays) {
    int size = 0;
    for (T[] arr : arrays) {
      size += arr.length;
    }

    T[] res =
        arrays.getClass().getComponentType().equals(Object[].class) ? (T[]) new Object[size] : (T[]) Array.newInstance(
            arrays.getClass().getComponentType().getComponentType(), size);

    int offset = 0;
    for (T[] arr : arrays) {
      System.arraycopy(arr, 0, res, offset, arr.length);
      offset += arr.length;
    }

    return res;
  }

  /**
   * Maps one array to another using a provided mapping function.
   *
   * Note that the same logic can be achieved via streams (Arrays.stream(array).map(mapper).toArray()) but this method
   * is computationally cheaper.
   *
   * @param sourceArray the original array to map
   * @param targetArrayNew a function that creates a new array of a provided size; e.g. String[]::new
   * @param mapper a mapping function that transforms the original values
   * @param <S> the element type of the source array
   * @param <T> the element type of the target array
   * @return a new, transformed array of elements
   */
  public static <S, T> T[] mapArray(S[] sourceArray, IntFunction<T[]> targetArrayNew, Function<S, T> mapper) {
    T[] res = targetArrayNew.apply(sourceArray.length);
    for (int i = 0; i < sourceArray.length; i++) {
      res[i] = mapper.apply(sourceArray[i]);
    }

    return res;
  }

  // ---------------- Begin methods for Objects ----------------

  /**
   * An instance of an empty Object array.  Using this instance rather than creating a new array each time an empty
   * array is needed avoids an unnecessary object creation.
   */
  public static final Object[] EMPTY_OBJECT_ARRAY = new Object[0];

  /**
   * Transposes a "matrix" comprised of an array of arrays; each element array[i][j] will be copied to transposed[j][i].
   *
   * If the original array of arrays is "jagged" (with subarray "rows" of differing lengths), the width of the matrix
   * will be taken as the longest of its rows and any "missing" elements in shorter rows will treated as if they were
   * null.
   *
   * @param matrix the array of arrays to transpose; the subarray "rows" do not need to be of uniform length
   * @return a new, transposed array of arrays such that each element {@code matrix[i][j]} will be copied to
   *         {@code transposed[j][i]}
   */
  public static Object[][] transpose(Object[][] matrix) {
    // find the longest row in the matrix (its number of columns)--this will be our result matrix's width
    int newHeight = 0;
    for (Object[] row : matrix) {
      newHeight = Math.max(newHeight, row.length);
    }

    Object[][] transposed = new Object[newHeight][matrix.length];
    for (int i = 0; i < matrix.length; i++) {
      Object[] row = matrix[i];
      for (int j = 0; j < row.length; j++) {
        transposed[j][i] = row[j];
      }
    }

    return transposed;
  }

  /**
   * Given a sorted array (either least to greatest or greatest to least), places all unique elements at the start of
   * the array (maintaining the original sort order and overwriting their original values) and returns the number of
   * unique elements.
   *
   * For example, if this method is called on the array [1, 2, 2, 2, 3, 3, 4], it will return 4 (the number of unique
   * elements) and the array will be modified to [1, 2, 3, 4, 3, 3, 4].  Note that only the first 4 elements of this
   * array have been changed.
   *
   * The time complexity of this method is O(n), where n is the length of the input array.
   *
   * @param array the sorted array to deduplicate
   * @return the number of unique elements in the provided array
   */
  public static int deduplicateSortedArray(Object[] array) {
    // handle empty-array edge case
    if (array.length == 0) {
      return 0;
    }

    // look for duplicates and shift elements up to overwrite any that are found
    int shift = 0;
    for (int i = 1; i < array.length; i++) {
      if (Objects.equals(array[i], array[i - 1])) {
        shift++;
      } else {
        array[i - shift] = array[i]; // if shift == 0 this is a noop
      }
    }

    return array.length - shift;
  }

  /**
   * Reverses the order of the elements of the array.
   *
   * @param array the array to be reversed
   */
  public static void reverse(Object[] array) {
    for (int i = 0; i < array.length / 2; i++) {
      Object val = array[array.length - i - 1];
      array[array.length - i - 1] = array[i];
      array[i] = val;
    }
  }

  // ---------------- Begin methods for Booleans ----------------

  /**
   * An instance of an empty boolean array.  Using this instance rather than creating a new array each time an empty
   * array is needed avoids an unnecessary object creation.
   */
  public static final boolean[] EMPTY_BOOLEAN_ARRAY = new boolean[0];

  /**
   * Concatenates one or more arrays.
   *
   * @param arrays one or more arrays to concatenate
   * @return the concatenated array
   */
  public static boolean[] concat(boolean[]... arrays) {
    int size = 0;
    for (boolean[] arr : arrays) {
      size += arr.length;
    }

    boolean[] res = new boolean[size];

    int offset = 0;
    for (boolean[] arr : arrays) {
      System.arraycopy(arr, 0, res, offset, arr.length);
      offset += arr.length;
    }

    return res;
  }

  /**
   * Wraps an array as a {@link java.util.List} just as {@link Arrays#asList(Object[])} does for reference types.
   *
   * However, unlike the list returned by {@link Arrays#asList(Object[])}, the returned list may still grow (or shrink),
   * in which case its underlying array may cease to be the {@code wrapped} array (such that changes in one will cease
   * to induce changes in the other).
   *
   * @param wrapped the array to wrap; until the list size changes, it is guaranteed that changes to the elements of
   *                the array will affect the list wrapper, and vice-versa
   * @return a list that wraps the provided array
   */
  public static BooleanArrayList asList(boolean... wrapped) {
    return BooleanArrayList.wrap(wrapped);
  }

  /**
   * Transposes a "matrix" comprised of an array of arrays; each element array[i][j] will be copied to transposed[j][i].
   *
   * If the original array of arrays is "jagged" (with subarray "rows" of differing lengths), the width of the matrix
   * will be taken as the longest of its rows and any "missing" elements in shorter rows will treated as if they were
   * false.
   *
   * @param matrix the array of arrays to transpose; the subarray "rows" do not need to be of uniform length
   * @return a new, transposed array of arrays such that each element {@code matrix[i][j]} will be copied to
   *         {@code transposed[j][i]}
   */
  public static boolean[][] transpose(boolean[][] matrix) {
    // find the longest row in the matrix (its number of columns)--this will be our result matrix's width
    int newHeight = 0;
    for (boolean[] row : matrix) {
      newHeight = Math.max(newHeight, row.length);
    }

    boolean[][] transposed = new boolean[newHeight][matrix.length];
    for (int i = 0; i < matrix.length; i++) {
      boolean[] row = matrix[i];
      for (int j = 0; j < row.length; j++) {
        transposed[j][i] = row[j];
      }
    }

    return transposed;
  }

  /**
   * Given a sorted array (either least to greatest or greatest to least), places all unique elements at the start of
   * the array (maintaining the original sort order and overwriting their original values) and returns the number of
   * unique elements.
   *
   * For example, if this method is called on the array [1, 2, 2, 2, 3, 3, 4], it will return 4 (the number of unique
   * elements) and the array will be modified to [1, 2, 3, 4, 3, 3, 4].  Note that only the first 4 elements of this
   * array have been changed.
   *
   * The time complexity of this method is O(n), where n is the length of the input array.
   *
   * @param array the sorted array to deduplicate
   * @return the number of unique elements in the provided array
   */
  public static int deduplicateSortedArray(boolean[] array) {
    // handle empty-array edge case
    if (array.length == 0) {
      return 0;
    }

    // look for duplicates and shift elements up to overwrite any that are found
    int shift = 0;
    for (int i = 1; i < array.length; i++) {
      if (array[i] == array[i - 1]) {
        shift++;
      } else {
        array[i - shift] = array[i]; // if shift == 0 this is a noop
      }
    }

    return array.length - shift;
  }

  /**
   * Reverses the order of the elements of the array.
   *
   * @param array the array to be reversed
   */
  public static void reverse(boolean[] array) {
    for (int i = 0; i < array.length / 2; i++) {
      boolean val = array[array.length - i - 1];
      array[array.length - i - 1] = array[i];
      array[i] = val;
    }
  }

  // ---------------- Begin methods for Bytes ----------------

  /**
   * An instance of an empty byte array.  Using this instance rather than creating a new array each time an empty
   * array is needed avoids an unnecessary object creation.
   */
  public static final byte[] EMPTY_BYTE_ARRAY = new byte[0];

  /**
   * Concatenates one or more arrays.
   *
   * @param arrays one or more arrays to concatenate
   * @return the concatenated array
   */
  public static byte[] concat(byte[]... arrays) {
    int size = 0;
    for (byte[] arr : arrays) {
      size += arr.length;
    }

    byte[] res = new byte[size];

    int offset = 0;
    for (byte[] arr : arrays) {
      System.arraycopy(arr, 0, res, offset, arr.length);
      offset += arr.length;
    }

    return res;
  }

  /**
   * Wraps an array as a {@link java.util.List} just as {@link Arrays#asList(Object[])} does for reference types.
   *
   * However, unlike the list returned by {@link Arrays#asList(Object[])}, the returned list may still grow (or shrink),
   * in which case its underlying array may cease to be the {@code wrapped} array (such that changes in one will cease
   * to induce changes in the other).
   *
   * @param wrapped the array to wrap; until the list size changes, it is guaranteed that changes to the elements of
   *                the array will affect the list wrapper, and vice-versa
   * @return a list that wraps the provided array
   */
  public static ByteArrayList asList(byte... wrapped) {
    return ByteArrayList.wrap(wrapped);
  }

  /**
   * Transposes a "matrix" comprised of an array of arrays; each element array[i][j] will be copied to transposed[j][i].
   *
   * If the original array of arrays is "jagged" (with subarray "rows" of differing lengths), the width of the matrix
   * will be taken as the longest of its rows and any "missing" elements in shorter rows will treated as if they were
   * 0.
   *
   * @param matrix the array of arrays to transpose; the subarray "rows" do not need to be of uniform length
   * @return a new, transposed array of arrays such that each element {@code matrix[i][j]} will be copied to
   *         {@code transposed[j][i]}
   */
  public static byte[][] transpose(byte[][] matrix) {
    // find the longest row in the matrix (its number of columns)--this will be our result matrix's width
    int newHeight = 0;
    for (byte[] row : matrix) {
      newHeight = Math.max(newHeight, row.length);
    }

    byte[][] transposed = new byte[newHeight][matrix.length];
    for (int i = 0; i < matrix.length; i++) {
      byte[] row = matrix[i];
      for (int j = 0; j < row.length; j++) {
        transposed[j][i] = row[j];
      }
    }

    return transposed;
  }

  /**
   * Given a sorted array (either least to greatest or greatest to least), places all unique elements at the start of
   * the array (maintaining the original sort order and overwriting their original values) and returns the number of
   * unique elements.
   *
   * For example, if this method is called on the array [1, 2, 2, 2, 3, 3, 4], it will return 4 (the number of unique
   * elements) and the array will be modified to [1, 2, 3, 4, 3, 3, 4].  Note that only the first 4 elements of this
   * array have been changed.
   *
   * The time complexity of this method is O(n), where n is the length of the input array.
   *
   * @param array the sorted array to deduplicate
   * @return the number of unique elements in the provided array
   */
  public static int deduplicateSortedArray(byte[] array) {
    // handle empty-array edge case
    if (array.length == 0) {
      return 0;
    }

    // look for duplicates and shift elements up to overwrite any that are found
    int shift = 0;
    for (int i = 1; i < array.length; i++) {
      if (array[i] == array[i - 1]) {
        shift++;
      } else {
        array[i - shift] = array[i]; // if shift == 0 this is a noop
      }
    }

    return array.length - shift;
  }

  /**
   * Reverses the order of the elements of the array.
   *
   * @param array the array to be reversed
   */
  public static void reverse(byte[] array) {
    for (int i = 0; i < array.length / 2; i++) {
      byte val = array[array.length - i - 1];
      array[array.length - i - 1] = array[i];
      array[i] = val;
    }
  }

  /**
   * Returns true if the elements of the array are monotonically increasing (i.e. in natural order)
   *
   * @param array the array to be checked
   * @return true if the array is monotonically increasing, false otherwise
   */
  public static boolean isMonotonicallyIncreasing(byte[] array) {
    if (array.length > 0) {
      byte previousElement = array[0];
      for (int i = 1; i < array.length; i++) {
        if (array[i] < previousElement) {
          return false;
        }
        previousElement = array[i];
      }
    }

    return true;
  }

  /**
   * Returns true if the elements of the array are monotonically decreasing (i.e. in reverse natural order)
   *
   * @param array the array to be checked
   * @return true if the array is monotonically decreasing, false otherwise
   */
  public static boolean isMonotonicallyDecreasing(byte[] array) {
    if (array.length > 0) {
      byte previousElement = array[0];
      for (int i = 1; i < array.length; i++) {
        if (array[i] > previousElement) {
          return false;
        }
        previousElement = array[i];
      }
    }

    return true;
  }

  /**
   * Converts an {@link Iterable} of {@link Number}s to an array of bytes.
   *
   * This method is "lossy" because it does not know, a priori, the concrete types of the providers {@link Number}s,
   * and some information may be lost.  {@link Number#byteValue()} is used to obtain the array values.
   *
   * A run-time exception will be thrown if the quantity of elements in the provided {@link Iterable} exceeds the
   * maximum array length on this JVM.
   *
   * @param numbers the numbers that should be converted into an array of bytes
   * @return an array of bytes, possibly subject to truncation or rounding
   */
  public static byte[] toBytesLossy(Iterable<? extends Number> numbers) {
    byte[] res = new byte[Math.toIntExact(Iterables.size64(numbers))];

    java.util.Iterator<? extends Number> iterator = numbers.iterator();
    try {
      for (int i = 0; i < res.length; i++) {
        res[i] = iterator.next().byteValue();
      }
      return res;
    } finally {
      // properly close AutoCloseable iterators

      Closeables.tryClose(iterator);
    }
  }

  /**
   * In-place sorts two parallel arrays in the natural order of elements of the first array.
   *
   * @param sortData the first array, whose values will determine the final sorted order
   * @param auxData the second array, whose values will be rearranged in parallel with the first array
   */
  public static void sort(byte[] sortData, Object[] auxData) {
    quicksort(sortData, auxData, 0, sortData.length - 1);
  }

  /**
   * In-place sorts two parallel arrays in the natural order of elements of the first array.
   *
   * @param sortData the first array, whose values will determine the final sorted order
   * @param auxData the second array, whose values will be rearranged in parallel with the first array
   * @param left the starting index of the subarray to be sorted.  To sort the entire array, specify 0.
   * @param right the ending index, INCLUSIVE, of the subarray to be sorted.  To sort the entire array, specify
   *              sortData.length - 1
   */
  private static void quicksort(byte[] sortData, Object[] auxData, int left, int right) {
    if (right <= left) {
      return;
    }

    // These exchanges are here to reduce both the runtime and the
    // stack usage (level of recursion) in degenerate cases such as
    // when the input is sorted or nearly sorted.
    exchange(sortData, auxData, (left + right) / 2, right - 1);
    compareExchange(sortData, auxData, left, right - 1);
    compareExchange(sortData, auxData, left, right);
    compareExchange(sortData, auxData, right - 1, right);

    if (right - 1 <= left) {
      return;
    }

    int i = partition(sortData, auxData, left + 1, right - 1);

    quicksort(sortData, auxData, left, i - 1);
    quicksort(sortData, auxData, i + 1, right);
  }

  private static int partition(byte[] sortData, Object[] auxData, int left, int right) {
    int i = left - 1;
    int j = right;

    byte sortVal = sortData[right];

    while (true) {
      while (sortData[++i] < sortVal) {
        // this space intentionally left blank
      }

      while (sortVal < sortData[--j]) {
        if (j == left) {
          break;
        }
      }

      if (i >= j) {
        break;
      }

      exchange(sortData, auxData, i, j);
    }

    exchange(sortData, auxData, i, right);
    return i;
  }

  private static void compareExchange(byte[] sortData, Object[] auxData, int idxA, int idxB) {
    if (sortData[idxB] < sortData[idxA]) {
      exchange(sortData, auxData, idxA, idxB);
    }
  }

  private static void exchange(byte[] sortData, Object[] auxData, int idxA, int idxB) {
    if (idxA == idxB) {
      return;
    }

    byte tempSortVal = sortData[idxA];
    sortData[idxA] = sortData[idxB];
    sortData[idxB] = tempSortVal;

    Object tempAuxVal = auxData[idxA];
    auxData[idxA] = auxData[idxB];
    auxData[idxB] = tempAuxVal;
  }

  /**
   * In-place sorts two parallel arrays in the natural order of elements of the first array.
   *
   * @param sortData the first array, whose values will determine the final sorted order
   * @param auxData the second array, whose values will be rearranged in parallel with the first array
   */
  public static void sort(byte[] sortData, boolean[] auxData) {
    quicksort(sortData, auxData, 0, sortData.length - 1);
  }

  /**
   * In-place sorts two parallel arrays in the natural order of elements of the first array.
   *
   * @param sortData the first array, whose values will determine the final sorted order
   * @param auxData the second array, whose values will be rearranged in parallel with the first array
   * @param left the starting index of the subarray to be sorted.  To sort the entire array, specify 0.
   * @param right the ending index, INCLUSIVE, of the subarray to be sorted.  To sort the entire array, specify
   *              sortData.length - 1
   */
  private static void quicksort(byte[] sortData, boolean[] auxData, int left, int right) {
    if (right <= left) {
      return;
    }

    // These exchanges are here to reduce both the runtime and the
    // stack usage (level of recursion) in degenerate cases such as
    // when the input is sorted or nearly sorted.
    exchange(sortData, auxData, (left + right) / 2, right - 1);
    compareExchange(sortData, auxData, left, right - 1);
    compareExchange(sortData, auxData, left, right);
    compareExchange(sortData, auxData, right - 1, right);

    if (right - 1 <= left) {
      return;
    }

    int i = partition(sortData, auxData, left + 1, right - 1);

    quicksort(sortData, auxData, left, i - 1);
    quicksort(sortData, auxData, i + 1, right);
  }

  private static int partition(byte[] sortData, boolean[] auxData, int left, int right) {
    int i = left - 1;
    int j = right;

    byte sortVal = sortData[right];

    while (true) {
      while (sortData[++i] < sortVal) {
        // this space intentionally left blank
      }

      while (sortVal < sortData[--j]) {
        if (j == left) {
          break;
        }
      }

      if (i >= j) {
        break;
      }

      exchange(sortData, auxData, i, j);
    }

    exchange(sortData, auxData, i, right);
    return i;
  }

  private static void compareExchange(byte[] sortData, boolean[] auxData, int idxA, int idxB) {
    if (sortData[idxB] < sortData[idxA]) {
      exchange(sortData, auxData, idxA, idxB);
    }
  }

  private static void exchange(byte[] sortData, boolean[] auxData, int idxA, int idxB) {
    if (idxA == idxB) {
      return;
    }

    byte tempSortVal = sortData[idxA];
    sortData[idxA] = sortData[idxB];
    sortData[idxB] = tempSortVal;

    boolean tempAuxVal = auxData[idxA];
    auxData[idxA] = auxData[idxB];
    auxData[idxB] = tempAuxVal;
  }

  /**
   * In-place sorts two parallel arrays in the natural order of elements of the first array.
   *
   * @param sortData the first array, whose values will determine the final sorted order
   * @param auxData the second array, whose values will be rearranged in parallel with the first array
   */
  public static void sort(byte[] sortData, byte[] auxData) {
    quicksort(sortData, auxData, 0, sortData.length - 1);
  }

  /**
   * In-place sorts two parallel arrays in the natural order of elements of the first array.
   *
   * @param sortData the first array, whose values will determine the final sorted order
   * @param auxData the second array, whose values will be rearranged in parallel with the first array
   * @param left the starting index of the subarray to be sorted.  To sort the entire array, specify 0.
   * @param right the ending index, INCLUSIVE, of the subarray to be sorted.  To sort the entire array, specify
   *              sortData.length - 1
   */
  private static void quicksort(byte[] sortData, byte[] auxData, int left, int right) {
    if (right <= left) {
      return;
    }

    // These exchanges are here to reduce both the runtime and the
    // stack usage (level of recursion) in degenerate cases such as
    // when the input is sorted or nearly sorted.
    exchange(sortData, auxData, (left + right) / 2, right - 1);
    compareExchange(sortData, auxData, left, right - 1);
    compareExchange(sortData, auxData, left, right);
    compareExchange(sortData, auxData, right - 1, right);

    if (right - 1 <= left) {
      return;
    }

    int i = partition(sortData, auxData, left + 1, right - 1);

    quicksort(sortData, auxData, left, i - 1);
    quicksort(sortData, auxData, i + 1, right);
  }

  private static int partition(byte[] sortData, byte[] auxData, int left, int right) {
    int i = left - 1;
    int j = right;

    byte sortVal = sortData[right];

    while (true) {
      while (sortData[++i] < sortVal) {
        // this space intentionally left blank
      }

      while (sortVal < sortData[--j]) {
        if (j == left) {
          break;
        }
      }

      if (i >= j) {
        break;
      }

      exchange(sortData, auxData, i, j);
    }

    exchange(sortData, auxData, i, right);
    return i;
  }

  private static void compareExchange(byte[] sortData, byte[] auxData, int idxA, int idxB) {
    if (sortData[idxB] < sortData[idxA]) {
      exchange(sortData, auxData, idxA, idxB);
    }
  }

  private static void exchange(byte[] sortData, byte[] auxData, int idxA, int idxB) {
    if (idxA == idxB) {
      return;
    }

    byte tempSortVal = sortData[idxA];
    sortData[idxA] = sortData[idxB];
    sortData[idxB] = tempSortVal;

    byte tempAuxVal = auxData[idxA];
    auxData[idxA] = auxData[idxB];
    auxData[idxB] = tempAuxVal;
  }

  /**
   * Converts an array of bytes to an array of chars.
   *
   * This cast is lossless (no loss of information).
   *
   * @param arr the array to convert
   * @return an array of chars cast from the provided array of bytes
   */
  public static char[] toCharacters(byte[] arr) {
    char[] res = new char[arr.length];
    for (int i = 0; i < res.length; i++) {
      res[i] = (char) arr[i];
    }

    return res;
  }

  /**
   * In-place sorts two parallel arrays in the natural order of elements of the first array.
   *
   * @param sortData the first array, whose values will determine the final sorted order
   * @param auxData the second array, whose values will be rearranged in parallel with the first array
   */
  public static void sort(byte[] sortData, char[] auxData) {
    quicksort(sortData, auxData, 0, sortData.length - 1);
  }

  /**
   * In-place sorts two parallel arrays in the natural order of elements of the first array.
   *
   * @param sortData the first array, whose values will determine the final sorted order
   * @param auxData the second array, whose values will be rearranged in parallel with the first array
   * @param left the starting index of the subarray to be sorted.  To sort the entire array, specify 0.
   * @param right the ending index, INCLUSIVE, of the subarray to be sorted.  To sort the entire array, specify
   *              sortData.length - 1
   */
  private static void quicksort(byte[] sortData, char[] auxData, int left, int right) {
    if (right <= left) {
      return;
    }

    // These exchanges are here to reduce both the runtime and the
    // stack usage (level of recursion) in degenerate cases such as
    // when the input is sorted or nearly sorted.
    exchange(sortData, auxData, (left + right) / 2, right - 1);
    compareExchange(sortData, auxData, left, right - 1);
    compareExchange(sortData, auxData, left, right);
    compareExchange(sortData, auxData, right - 1, right);

    if (right - 1 <= left) {
      return;
    }

    int i = partition(sortData, auxData, left + 1, right - 1);

    quicksort(sortData, auxData, left, i - 1);
    quicksort(sortData, auxData, i + 1, right);
  }

  private static int partition(byte[] sortData, char[] auxData, int left, int right) {
    int i = left - 1;
    int j = right;

    byte sortVal = sortData[right];

    while (true) {
      while (sortData[++i] < sortVal) {
        // this space intentionally left blank
      }

      while (sortVal < sortData[--j]) {
        if (j == left) {
          break;
        }
      }

      if (i >= j) {
        break;
      }

      exchange(sortData, auxData, i, j);
    }

    exchange(sortData, auxData, i, right);
    return i;
  }

  private static void compareExchange(byte[] sortData, char[] auxData, int idxA, int idxB) {
    if (sortData[idxB] < sortData[idxA]) {
      exchange(sortData, auxData, idxA, idxB);
    }
  }

  private static void exchange(byte[] sortData, char[] auxData, int idxA, int idxB) {
    if (idxA == idxB) {
      return;
    }

    byte tempSortVal = sortData[idxA];
    sortData[idxA] = sortData[idxB];
    sortData[idxB] = tempSortVal;

    char tempAuxVal = auxData[idxA];
    auxData[idxA] = auxData[idxB];
    auxData[idxB] = tempAuxVal;
  }

  /**
   * Converts an array of bytes to an array of shorts.
   *
   * This cast is lossless (no loss of information).
   *
   * @param arr the array to convert
   * @return an array of shorts cast from the provided array of bytes
   */
  public static short[] toShorts(byte[] arr) {
    short[] res = new short[arr.length];
    for (int i = 0; i < res.length; i++) {
      res[i] = arr[i];
    }

    return res;
  }

  /**
   * In-place sorts two parallel arrays in the natural order of elements of the first array.
   *
   * @param sortData the first array, whose values will determine the final sorted order
   * @param auxData the second array, whose values will be rearranged in parallel with the first array
   */
  public static void sort(byte[] sortData, short[] auxData) {
    quicksort(sortData, auxData, 0, sortData.length - 1);
  }

  /**
   * In-place sorts two parallel arrays in the natural order of elements of the first array.
   *
   * @param sortData the first array, whose values will determine the final sorted order
   * @param auxData the second array, whose values will be rearranged in parallel with the first array
   * @param left the starting index of the subarray to be sorted.  To sort the entire array, specify 0.
   * @param right the ending index, INCLUSIVE, of the subarray to be sorted.  To sort the entire array, specify
   *              sortData.length - 1
   */
  private static void quicksort(byte[] sortData, short[] auxData, int left, int right) {
    if (right <= left) {
      return;
    }

    // These exchanges are here to reduce both the runtime and the
    // stack usage (level of recursion) in degenerate cases such as
    // when the input is sorted or nearly sorted.
    exchange(sortData, auxData, (left + right) / 2, right - 1);
    compareExchange(sortData, auxData, left, right - 1);
    compareExchange(sortData, auxData, left, right);
    compareExchange(sortData, auxData, right - 1, right);

    if (right - 1 <= left) {
      return;
    }

    int i = partition(sortData, auxData, left + 1, right - 1);

    quicksort(sortData, auxData, left, i - 1);
    quicksort(sortData, auxData, i + 1, right);
  }

  private static int partition(byte[] sortData, short[] auxData, int left, int right) {
    int i = left - 1;
    int j = right;

    byte sortVal = sortData[right];

    while (true) {
      while (sortData[++i] < sortVal) {
        // this space intentionally left blank
      }

      while (sortVal < sortData[--j]) {
        if (j == left) {
          break;
        }
      }

      if (i >= j) {
        break;
      }

      exchange(sortData, auxData, i, j);
    }

    exchange(sortData, auxData, i, right);
    return i;
  }

  private static void compareExchange(byte[] sortData, short[] auxData, int idxA, int idxB) {
    if (sortData[idxB] < sortData[idxA]) {
      exchange(sortData, auxData, idxA, idxB);
    }
  }

  private static void exchange(byte[] sortData, short[] auxData, int idxA, int idxB) {
    if (idxA == idxB) {
      return;
    }

    byte tempSortVal = sortData[idxA];
    sortData[idxA] = sortData[idxB];
    sortData[idxB] = tempSortVal;

    short tempAuxVal = auxData[idxA];
    auxData[idxA] = auxData[idxB];
    auxData[idxB] = tempAuxVal;
  }

  /**
   * Converts an array of bytes to an array of ints.
   *
   * This cast is lossless (no loss of information).
   *
   * @param arr the array to convert
   * @return an array of ints cast from the provided array of bytes
   */
  public static int[] toIntegers(byte[] arr) {
    int[] res = new int[arr.length];
    for (int i = 0; i < res.length; i++) {
      res[i] = arr[i];
    }

    return res;
  }

  /**
   * In-place sorts two parallel arrays in the natural order of elements of the first array.
   *
   * @param sortData the first array, whose values will determine the final sorted order
   * @param auxData the second array, whose values will be rearranged in parallel with the first array
   */
  public static void sort(byte[] sortData, int[] auxData) {
    quicksort(sortData, auxData, 0, sortData.length - 1);
  }

  /**
   * In-place sorts two parallel arrays in the natural order of elements of the first array.
   *
   * @param sortData the first array, whose values will determine the final sorted order
   * @param auxData the second array, whose values will be rearranged in parallel with the first array
   * @param left the starting index of the subarray to be sorted.  To sort the entire array, specify 0.
   * @param right the ending index, INCLUSIVE, of the subarray to be sorted.  To sort the entire array, specify
   *              sortData.length - 1
   */
  private static void quicksort(byte[] sortData, int[] auxData, int left, int right) {
    if (right <= left) {
      return;
    }

    // These exchanges are here to reduce both the runtime and the
    // stack usage (level of recursion) in degenerate cases such as
    // when the input is sorted or nearly sorted.
    exchange(sortData, auxData, (left + right) / 2, right - 1);
    compareExchange(sortData, auxData, left, right - 1);
    compareExchange(sortData, auxData, left, right);
    compareExchange(sortData, auxData, right - 1, right);

    if (right - 1 <= left) {
      return;
    }

    int i = partition(sortData, auxData, left + 1, right - 1);

    quicksort(sortData, auxData, left, i - 1);
    quicksort(sortData, auxData, i + 1, right);
  }

  private static int partition(byte[] sortData, int[] auxData, int left, int right) {
    int i = left - 1;
    int j = right;

    byte sortVal = sortData[right];

    while (true) {
      while (sortData[++i] < sortVal) {
        // this space intentionally left blank
      }

      while (sortVal < sortData[--j]) {
        if (j == left) {
          break;
        }
      }

      if (i >= j) {
        break;
      }

      exchange(sortData, auxData, i, j);
    }

    exchange(sortData, auxData, i, right);
    return i;
  }

  private static void compareExchange(byte[] sortData, int[] auxData, int idxA, int idxB) {
    if (sortData[idxB] < sortData[idxA]) {
      exchange(sortData, auxData, idxA, idxB);
    }
  }

  private static void exchange(byte[] sortData, int[] auxData, int idxA, int idxB) {
    if (idxA == idxB) {
      return;
    }

    byte tempSortVal = sortData[idxA];
    sortData[idxA] = sortData[idxB];
    sortData[idxB] = tempSortVal;

    int tempAuxVal = auxData[idxA];
    auxData[idxA] = auxData[idxB];
    auxData[idxB] = tempAuxVal;
  }

  /**
   * Converts an array of bytes to an array of longs.
   *
   * This cast is lossless (no loss of information).
   *
   * @param arr the array to convert
   * @return an array of longs cast from the provided array of bytes
   */
  public static long[] toLongs(byte[] arr) {
    long[] res = new long[arr.length];
    for (int i = 0; i < res.length; i++) {
      res[i] = arr[i];
    }

    return res;
  }

  /**
   * In-place sorts two parallel arrays in the natural order of elements of the first array.
   *
   * @param sortData the first array, whose values will determine the final sorted order
   * @param auxData the second array, whose values will be rearranged in parallel with the first array
   */
  public static void sort(byte[] sortData, long[] auxData) {
    quicksort(sortData, auxData, 0, sortData.length - 1);
  }

  /**
   * In-place sorts two parallel arrays in the natural order of elements of the first array.
   *
   * @param sortData the first array, whose values will determine the final sorted order
   * @param auxData the second array, whose values will be rearranged in parallel with the first array
   * @param left the starting index of the subarray to be sorted.  To sort the entire array, specify 0.
   * @param right the ending index, INCLUSIVE, of the subarray to be sorted.  To sort the entire array, specify
   *              sortData.length - 1
   */
  private static void quicksort(byte[] sortData, long[] auxData, int left, int right) {
    if (right <= left) {
      return;
    }

    // These exchanges are here to reduce both the runtime and the
    // stack usage (level of recursion) in degenerate cases such as
    // when the input is sorted or nearly sorted.
    exchange(sortData, auxData, (left + right) / 2, right - 1);
    compareExchange(sortData, auxData, left, right - 1);
    compareExchange(sortData, auxData, left, right);
    compareExchange(sortData, auxData, right - 1, right);

    if (right - 1 <= left) {
      return;
    }

    int i = partition(sortData, auxData, left + 1, right - 1);

    quicksort(sortData, auxData, left, i - 1);
    quicksort(sortData, auxData, i + 1, right);
  }

  private static int partition(byte[] sortData, long[] auxData, int left, int right) {
    int i = left - 1;
    int j = right;

    byte sortVal = sortData[right];

    while (true) {
      while (sortData[++i] < sortVal) {
        // this space intentionally left blank
      }

      while (sortVal < sortData[--j]) {
        if (j == left) {
          break;
        }
      }

      if (i >= j) {
        break;
      }

      exchange(sortData, auxData, i, j);
    }

    exchange(sortData, auxData, i, right);
    return i;
  }

  private static void compareExchange(byte[] sortData, long[] auxData, int idxA, int idxB) {
    if (sortData[idxB] < sortData[idxA]) {
      exchange(sortData, auxData, idxA, idxB);
    }
  }

  private static void exchange(byte[] sortData, long[] auxData, int idxA, int idxB) {
    if (idxA == idxB) {
      return;
    }

    byte tempSortVal = sortData[idxA];
    sortData[idxA] = sortData[idxB];
    sortData[idxB] = tempSortVal;

    long tempAuxVal = auxData[idxA];
    auxData[idxA] = auxData[idxB];
    auxData[idxB] = tempAuxVal;
  }

  /**
   * Converts an array of bytes to an array of floats.
   *
   * This cast is lossless (no loss of information).
   *
   * @param arr the array to convert
   * @return an array of floats cast from the provided array of bytes
   */
  public static float[] toFloats(byte[] arr) {
    float[] res = new float[arr.length];
    for (int i = 0; i < res.length; i++) {
      res[i] = arr[i];
    }

    return res;
  }

  /**
   * In-place sorts two parallel arrays in the natural order of elements of the first array.
   *
   * @param sortData the first array, whose values will determine the final sorted order
   * @param auxData the second array, whose values will be rearranged in parallel with the first array
   */
  public static void sort(byte[] sortData, float[] auxData) {
    quicksort(sortData, auxData, 0, sortData.length - 1);
  }

  /**
   * In-place sorts two parallel arrays in the natural order of elements of the first array.
   *
   * @param sortData the first array, whose values will determine the final sorted order
   * @param auxData the second array, whose values will be rearranged in parallel with the first array
   * @param left the starting index of the subarray to be sorted.  To sort the entire array, specify 0.
   * @param right the ending index, INCLUSIVE, of the subarray to be sorted.  To sort the entire array, specify
   *              sortData.length - 1
   */
  private static void quicksort(byte[] sortData, float[] auxData, int left, int right) {
    if (right <= left) {
      return;
    }

    // These exchanges are here to reduce both the runtime and the
    // stack usage (level of recursion) in degenerate cases such as
    // when the input is sorted or nearly sorted.
    exchange(sortData, auxData, (left + right) / 2, right - 1);
    compareExchange(sortData, auxData, left, right - 1);
    compareExchange(sortData, auxData, left, right);
    compareExchange(sortData, auxData, right - 1, right);

    if (right - 1 <= left) {
      return;
    }

    int i = partition(sortData, auxData, left + 1, right - 1);

    quicksort(sortData, auxData, left, i - 1);
    quicksort(sortData, auxData, i + 1, right);
  }

  private static int partition(byte[] sortData, float[] auxData, int left, int right) {
    int i = left - 1;
    int j = right;

    byte sortVal = sortData[right];

    while (true) {
      while (sortData[++i] < sortVal) {
        // this space intentionally left blank
      }

      while (sortVal < sortData[--j]) {
        if (j == left) {
          break;
        }
      }

      if (i >= j) {
        break;
      }

      exchange(sortData, auxData, i, j);
    }

    exchange(sortData, auxData, i, right);
    return i;
  }

  private static void compareExchange(byte[] sortData, float[] auxData, int idxA, int idxB) {
    if (sortData[idxB] < sortData[idxA]) {
      exchange(sortData, auxData, idxA, idxB);
    }
  }

  private static void exchange(byte[] sortData, float[] auxData, int idxA, int idxB) {
    if (idxA == idxB) {
      return;
    }

    byte tempSortVal = sortData[idxA];
    sortData[idxA] = sortData[idxB];
    sortData[idxB] = tempSortVal;

    float tempAuxVal = auxData[idxA];
    auxData[idxA] = auxData[idxB];
    auxData[idxB] = tempAuxVal;
  }

  /**
   * Converts an array of bytes to an array of doubles.
   *
   * This cast is lossless (no loss of information).
   *
   * @param arr the array to convert
   * @return an array of doubles cast from the provided array of bytes
   */
  public static double[] toDoubles(byte[] arr) {
    double[] res = new double[arr.length];
    for (int i = 0; i < res.length; i++) {
      res[i] = arr[i];
    }

    return res;
  }

  /**
   * In-place sorts two parallel arrays in the natural order of elements of the first array.
   *
   * @param sortData the first array, whose values will determine the final sorted order
   * @param auxData the second array, whose values will be rearranged in parallel with the first array
   */
  public static void sort(byte[] sortData, double[] auxData) {
    quicksort(sortData, auxData, 0, sortData.length - 1);
  }

  /**
   * In-place sorts two parallel arrays in the natural order of elements of the first array.
   *
   * @param sortData the first array, whose values will determine the final sorted order
   * @param auxData the second array, whose values will be rearranged in parallel with the first array
   * @param left the starting index of the subarray to be sorted.  To sort the entire array, specify 0.
   * @param right the ending index, INCLUSIVE, of the subarray to be sorted.  To sort the entire array, specify
   *              sortData.length - 1
   */
  private static void quicksort(byte[] sortData, double[] auxData, int left, int right) {
    if (right <= left) {
      return;
    }

    // These exchanges are here to reduce both the runtime and the
    // stack usage (level of recursion) in degenerate cases such as
    // when the input is sorted or nearly sorted.
    exchange(sortData, auxData, (left + right) / 2, right - 1);
    compareExchange(sortData, auxData, left, right - 1);
    compareExchange(sortData, auxData, left, right);
    compareExchange(sortData, auxData, right - 1, right);

    if (right - 1 <= left) {
      return;
    }

    int i = partition(sortData, auxData, left + 1, right - 1);

    quicksort(sortData, auxData, left, i - 1);
    quicksort(sortData, auxData, i + 1, right);
  }

  private static int partition(byte[] sortData, double[] auxData, int left, int right) {
    int i = left - 1;
    int j = right;

    byte sortVal = sortData[right];

    while (true) {
      while (sortData[++i] < sortVal) {
        // this space intentionally left blank
      }

      while (sortVal < sortData[--j]) {
        if (j == left) {
          break;
        }
      }

      if (i >= j) {
        break;
      }

      exchange(sortData, auxData, i, j);
    }

    exchange(sortData, auxData, i, right);
    return i;
  }

  private static void compareExchange(byte[] sortData, double[] auxData, int idxA, int idxB) {
    if (sortData[idxB] < sortData[idxA]) {
      exchange(sortData, auxData, idxA, idxB);
    }
  }

  private static void exchange(byte[] sortData, double[] auxData, int idxA, int idxB) {
    if (idxA == idxB) {
      return;
    }

    byte tempSortVal = sortData[idxA];
    sortData[idxA] = sortData[idxB];
    sortData[idxB] = tempSortVal;

    double tempAuxVal = auxData[idxA];
    auxData[idxA] = auxData[idxB];
    auxData[idxB] = tempAuxVal;
  }

  // ---------------- Begin methods for Characters ----------------

  /**
   * An instance of an empty char array.  Using this instance rather than creating a new array each time an empty
   * array is needed avoids an unnecessary object creation.
   */
  public static final char[] EMPTY_CHARACTER_ARRAY = new char[0];

  /**
   * Concatenates one or more arrays.
   *
   * @param arrays one or more arrays to concatenate
   * @return the concatenated array
   */
  public static char[] concat(char[]... arrays) {
    int size = 0;
    for (char[] arr : arrays) {
      size += arr.length;
    }

    char[] res = new char[size];

    int offset = 0;
    for (char[] arr : arrays) {
      System.arraycopy(arr, 0, res, offset, arr.length);
      offset += arr.length;
    }

    return res;
  }

  /**
   * Wraps an array as a {@link java.util.List} just as {@link Arrays#asList(Object[])} does for reference types.
   *
   * However, unlike the list returned by {@link Arrays#asList(Object[])}, the returned list may still grow (or shrink),
   * in which case its underlying array may cease to be the {@code wrapped} array (such that changes in one will cease
   * to induce changes in the other).
   *
   * @param wrapped the array to wrap; until the list size changes, it is guaranteed that changes to the elements of
   *                the array will affect the list wrapper, and vice-versa
   * @return a list that wraps the provided array
   */
  public static CharArrayList asList(char... wrapped) {
    return CharArrayList.wrap(wrapped);
  }

  /**
   * Transposes a "matrix" comprised of an array of arrays; each element array[i][j] will be copied to transposed[j][i].
   *
   * If the original array of arrays is "jagged" (with subarray "rows" of differing lengths), the width of the matrix
   * will be taken as the longest of its rows and any "missing" elements in shorter rows will treated as if they were
   * '\0'.
   *
   * @param matrix the array of arrays to transpose; the subarray "rows" do not need to be of uniform length
   * @return a new, transposed array of arrays such that each element {@code matrix[i][j]} will be copied to
   *         {@code transposed[j][i]}
   */
  public static char[][] transpose(char[][] matrix) {
    // find the longest row in the matrix (its number of columns)--this will be our result matrix's width
    int newHeight = 0;
    for (char[] row : matrix) {
      newHeight = Math.max(newHeight, row.length);
    }

    char[][] transposed = new char[newHeight][matrix.length];
    for (int i = 0; i < matrix.length; i++) {
      char[] row = matrix[i];
      for (int j = 0; j < row.length; j++) {
        transposed[j][i] = row[j];
      }
    }

    return transposed;
  }

  /**
   * Given a sorted array (either least to greatest or greatest to least), places all unique elements at the start of
   * the array (maintaining the original sort order and overwriting their original values) and returns the number of
   * unique elements.
   *
   * For example, if this method is called on the array [1, 2, 2, 2, 3, 3, 4], it will return 4 (the number of unique
   * elements) and the array will be modified to [1, 2, 3, 4, 3, 3, 4].  Note that only the first 4 elements of this
   * array have been changed.
   *
   * The time complexity of this method is O(n), where n is the length of the input array.
   *
   * @param array the sorted array to deduplicate
   * @return the number of unique elements in the provided array
   */
  public static int deduplicateSortedArray(char[] array) {
    // handle empty-array edge case
    if (array.length == 0) {
      return 0;
    }

    // look for duplicates and shift elements up to overwrite any that are found
    int shift = 0;
    for (int i = 1; i < array.length; i++) {
      if (array[i] == array[i - 1]) {
        shift++;
      } else {
        array[i - shift] = array[i]; // if shift == 0 this is a noop
      }
    }

    return array.length - shift;
  }

  /**
   * Reverses the order of the elements of the array.
   *
   * @param array the array to be reversed
   */
  public static void reverse(char[] array) {
    for (int i = 0; i < array.length / 2; i++) {
      char val = array[array.length - i - 1];
      array[array.length - i - 1] = array[i];
      array[i] = val;
    }
  }

  /**
   * Returns true if the elements of the array are monotonically increasing (i.e. in natural order)
   *
   * @param array the array to be checked
   * @return true if the array is monotonically increasing, false otherwise
   */
  public static boolean isMonotonicallyIncreasing(char[] array) {
    if (array.length > 0) {
      char previousElement = array[0];
      for (int i = 1; i < array.length; i++) {
        if (array[i] < previousElement) {
          return false;
        }
        previousElement = array[i];
      }
    }

    return true;
  }

  /**
   * Returns true if the elements of the array are monotonically decreasing (i.e. in reverse natural order)
   *
   * @param array the array to be checked
   * @return true if the array is monotonically decreasing, false otherwise
   */
  public static boolean isMonotonicallyDecreasing(char[] array) {
    if (array.length > 0) {
      char previousElement = array[0];
      for (int i = 1; i < array.length; i++) {
        if (array[i] > previousElement) {
          return false;
        }
        previousElement = array[i];
      }
    }

    return true;
  }

  /**
   * In-place sorts two parallel arrays in the natural order of elements of the first array.
   *
   * @param sortData the first array, whose values will determine the final sorted order
   * @param auxData the second array, whose values will be rearranged in parallel with the first array
   */
  public static void sort(char[] sortData, Object[] auxData) {
    quicksort(sortData, auxData, 0, sortData.length - 1);
  }

  /**
   * In-place sorts two parallel arrays in the natural order of elements of the first array.
   *
   * @param sortData the first array, whose values will determine the final sorted order
   * @param auxData the second array, whose values will be rearranged in parallel with the first array
   * @param left the starting index of the subarray to be sorted.  To sort the entire array, specify 0.
   * @param right the ending index, INCLUSIVE, of the subarray to be sorted.  To sort the entire array, specify
   *              sortData.length - 1
   */
  private static void quicksort(char[] sortData, Object[] auxData, int left, int right) {
    if (right <= left) {
      return;
    }

    // These exchanges are here to reduce both the runtime and the
    // stack usage (level of recursion) in degenerate cases such as
    // when the input is sorted or nearly sorted.
    exchange(sortData, auxData, (left + right) / 2, right - 1);
    compareExchange(sortData, auxData, left, right - 1);
    compareExchange(sortData, auxData, left, right);
    compareExchange(sortData, auxData, right - 1, right);

    if (right - 1 <= left) {
      return;
    }

    int i = partition(sortData, auxData, left + 1, right - 1);

    quicksort(sortData, auxData, left, i - 1);
    quicksort(sortData, auxData, i + 1, right);
  }

  private static int partition(char[] sortData, Object[] auxData, int left, int right) {
    int i = left - 1;
    int j = right;

    char sortVal = sortData[right];

    while (true) {
      while (sortData[++i] < sortVal) {
        // this space intentionally left blank
      }

      while (sortVal < sortData[--j]) {
        if (j == left) {
          break;
        }
      }

      if (i >= j) {
        break;
      }

      exchange(sortData, auxData, i, j);
    }

    exchange(sortData, auxData, i, right);
    return i;
  }

  private static void compareExchange(char[] sortData, Object[] auxData, int idxA, int idxB) {
    if (sortData[idxB] < sortData[idxA]) {
      exchange(sortData, auxData, idxA, idxB);
    }
  }

  private static void exchange(char[] sortData, Object[] auxData, int idxA, int idxB) {
    if (idxA == idxB) {
      return;
    }

    char tempSortVal = sortData[idxA];
    sortData[idxA] = sortData[idxB];
    sortData[idxB] = tempSortVal;

    Object tempAuxVal = auxData[idxA];
    auxData[idxA] = auxData[idxB];
    auxData[idxB] = tempAuxVal;
  }

  /**
   * In-place sorts two parallel arrays in the natural order of elements of the first array.
   *
   * @param sortData the first array, whose values will determine the final sorted order
   * @param auxData the second array, whose values will be rearranged in parallel with the first array
   */
  public static void sort(char[] sortData, boolean[] auxData) {
    quicksort(sortData, auxData, 0, sortData.length - 1);
  }

  /**
   * In-place sorts two parallel arrays in the natural order of elements of the first array.
   *
   * @param sortData the first array, whose values will determine the final sorted order
   * @param auxData the second array, whose values will be rearranged in parallel with the first array
   * @param left the starting index of the subarray to be sorted.  To sort the entire array, specify 0.
   * @param right the ending index, INCLUSIVE, of the subarray to be sorted.  To sort the entire array, specify
   *              sortData.length - 1
   */
  private static void quicksort(char[] sortData, boolean[] auxData, int left, int right) {
    if (right <= left) {
      return;
    }

    // These exchanges are here to reduce both the runtime and the
    // stack usage (level of recursion) in degenerate cases such as
    // when the input is sorted or nearly sorted.
    exchange(sortData, auxData, (left + right) / 2, right - 1);
    compareExchange(sortData, auxData, left, right - 1);
    compareExchange(sortData, auxData, left, right);
    compareExchange(sortData, auxData, right - 1, right);

    if (right - 1 <= left) {
      return;
    }

    int i = partition(sortData, auxData, left + 1, right - 1);

    quicksort(sortData, auxData, left, i - 1);
    quicksort(sortData, auxData, i + 1, right);
  }

  private static int partition(char[] sortData, boolean[] auxData, int left, int right) {
    int i = left - 1;
    int j = right;

    char sortVal = sortData[right];

    while (true) {
      while (sortData[++i] < sortVal) {
        // this space intentionally left blank
      }

      while (sortVal < sortData[--j]) {
        if (j == left) {
          break;
        }
      }

      if (i >= j) {
        break;
      }

      exchange(sortData, auxData, i, j);
    }

    exchange(sortData, auxData, i, right);
    return i;
  }

  private static void compareExchange(char[] sortData, boolean[] auxData, int idxA, int idxB) {
    if (sortData[idxB] < sortData[idxA]) {
      exchange(sortData, auxData, idxA, idxB);
    }
  }

  private static void exchange(char[] sortData, boolean[] auxData, int idxA, int idxB) {
    if (idxA == idxB) {
      return;
    }

    char tempSortVal = sortData[idxA];
    sortData[idxA] = sortData[idxB];
    sortData[idxB] = tempSortVal;

    boolean tempAuxVal = auxData[idxA];
    auxData[idxA] = auxData[idxB];
    auxData[idxB] = tempAuxVal;
  }

  /**
   * Converts an array of chars to an array of bytes.
   *
   * This cast is "lossy" and may lose information.
   *
   * @param arr the array to convert
   * @return an array of bytes cast from the provided array of chars
   */
  public static byte[] toBytesLossy(char[] arr) {
    byte[] res = new byte[arr.length];
    for (int i = 0; i < res.length; i++) {
      res[i] = (byte) arr[i];
    }

    return res;
  }

  /**
   * Converts an array of chars to an array of bytes, throwing an exception if the
   * converted values do not <i>exactly</i> match the originals (as determined by {@code !=}.)
   *
   * @param arr the array to convert
   * @return an array of bytes cast from the provided array of chars
   * @throws ArithmeticException if the array cannot be losslessly converted
   */
  public static byte[] toBytesExact(char[] arr) {
    byte[] res = toBytesLossy(arr);
    for (int i = 0; i < res.length; i++) {
      if (res[i] != arr[i]) {
        throw new ArithmeticException("Cannot losslessly convert provided char[] to byte[] at index " + i + "; "
            + res[i] + " != " + arr[i]);
      }
    }

    return res;
  }

  /**
   * In-place sorts two parallel arrays in the natural order of elements of the first array.
   *
   * @param sortData the first array, whose values will determine the final sorted order
   * @param auxData the second array, whose values will be rearranged in parallel with the first array
   */
  public static void sort(char[] sortData, byte[] auxData) {
    quicksort(sortData, auxData, 0, sortData.length - 1);
  }

  /**
   * In-place sorts two parallel arrays in the natural order of elements of the first array.
   *
   * @param sortData the first array, whose values will determine the final sorted order
   * @param auxData the second array, whose values will be rearranged in parallel with the first array
   * @param left the starting index of the subarray to be sorted.  To sort the entire array, specify 0.
   * @param right the ending index, INCLUSIVE, of the subarray to be sorted.  To sort the entire array, specify
   *              sortData.length - 1
   */
  private static void quicksort(char[] sortData, byte[] auxData, int left, int right) {
    if (right <= left) {
      return;
    }

    // These exchanges are here to reduce both the runtime and the
    // stack usage (level of recursion) in degenerate cases such as
    // when the input is sorted or nearly sorted.
    exchange(sortData, auxData, (left + right) / 2, right - 1);
    compareExchange(sortData, auxData, left, right - 1);
    compareExchange(sortData, auxData, left, right);
    compareExchange(sortData, auxData, right - 1, right);

    if (right - 1 <= left) {
      return;
    }

    int i = partition(sortData, auxData, left + 1, right - 1);

    quicksort(sortData, auxData, left, i - 1);
    quicksort(sortData, auxData, i + 1, right);
  }

  private static int partition(char[] sortData, byte[] auxData, int left, int right) {
    int i = left - 1;
    int j = right;

    char sortVal = sortData[right];

    while (true) {
      while (sortData[++i] < sortVal) {
        // this space intentionally left blank
      }

      while (sortVal < sortData[--j]) {
        if (j == left) {
          break;
        }
      }

      if (i >= j) {
        break;
      }

      exchange(sortData, auxData, i, j);
    }

    exchange(sortData, auxData, i, right);
    return i;
  }

  private static void compareExchange(char[] sortData, byte[] auxData, int idxA, int idxB) {
    if (sortData[idxB] < sortData[idxA]) {
      exchange(sortData, auxData, idxA, idxB);
    }
  }

  private static void exchange(char[] sortData, byte[] auxData, int idxA, int idxB) {
    if (idxA == idxB) {
      return;
    }

    char tempSortVal = sortData[idxA];
    sortData[idxA] = sortData[idxB];
    sortData[idxB] = tempSortVal;

    byte tempAuxVal = auxData[idxA];
    auxData[idxA] = auxData[idxB];
    auxData[idxB] = tempAuxVal;
  }

  /**
   * In-place sorts two parallel arrays in the natural order of elements of the first array.
   *
   * @param sortData the first array, whose values will determine the final sorted order
   * @param auxData the second array, whose values will be rearranged in parallel with the first array
   */
  public static void sort(char[] sortData, char[] auxData) {
    quicksort(sortData, auxData, 0, sortData.length - 1);
  }

  /**
   * In-place sorts two parallel arrays in the natural order of elements of the first array.
   *
   * @param sortData the first array, whose values will determine the final sorted order
   * @param auxData the second array, whose values will be rearranged in parallel with the first array
   * @param left the starting index of the subarray to be sorted.  To sort the entire array, specify 0.
   * @param right the ending index, INCLUSIVE, of the subarray to be sorted.  To sort the entire array, specify
   *              sortData.length - 1
   */
  private static void quicksort(char[] sortData, char[] auxData, int left, int right) {
    if (right <= left) {
      return;
    }

    // These exchanges are here to reduce both the runtime and the
    // stack usage (level of recursion) in degenerate cases such as
    // when the input is sorted or nearly sorted.
    exchange(sortData, auxData, (left + right) / 2, right - 1);
    compareExchange(sortData, auxData, left, right - 1);
    compareExchange(sortData, auxData, left, right);
    compareExchange(sortData, auxData, right - 1, right);

    if (right - 1 <= left) {
      return;
    }

    int i = partition(sortData, auxData, left + 1, right - 1);

    quicksort(sortData, auxData, left, i - 1);
    quicksort(sortData, auxData, i + 1, right);
  }

  private static int partition(char[] sortData, char[] auxData, int left, int right) {
    int i = left - 1;
    int j = right;

    char sortVal = sortData[right];

    while (true) {
      while (sortData[++i] < sortVal) {
        // this space intentionally left blank
      }

      while (sortVal < sortData[--j]) {
        if (j == left) {
          break;
        }
      }

      if (i >= j) {
        break;
      }

      exchange(sortData, auxData, i, j);
    }

    exchange(sortData, auxData, i, right);
    return i;
  }

  private static void compareExchange(char[] sortData, char[] auxData, int idxA, int idxB) {
    if (sortData[idxB] < sortData[idxA]) {
      exchange(sortData, auxData, idxA, idxB);
    }
  }

  private static void exchange(char[] sortData, char[] auxData, int idxA, int idxB) {
    if (idxA == idxB) {
      return;
    }

    char tempSortVal = sortData[idxA];
    sortData[idxA] = sortData[idxB];
    sortData[idxB] = tempSortVal;

    char tempAuxVal = auxData[idxA];
    auxData[idxA] = auxData[idxB];
    auxData[idxB] = tempAuxVal;
  }

  /**
   * Converts an array of chars to an array of shorts.
   *
   * This cast is lossless (no loss of information).
   *
   * @param arr the array to convert
   * @return an array of shorts cast from the provided array of chars
   */
  public static short[] toShorts(char[] arr) {
    short[] res = new short[arr.length];
    for (int i = 0; i < res.length; i++) {
      res[i] = (short) arr[i];
    }

    return res;
  }

  /**
   * In-place sorts two parallel arrays in the natural order of elements of the first array.
   *
   * @param sortData the first array, whose values will determine the final sorted order
   * @param auxData the second array, whose values will be rearranged in parallel with the first array
   */
  public static void sort(char[] sortData, short[] auxData) {
    quicksort(sortData, auxData, 0, sortData.length - 1);
  }

  /**
   * In-place sorts two parallel arrays in the natural order of elements of the first array.
   *
   * @param sortData the first array, whose values will determine the final sorted order
   * @param auxData the second array, whose values will be rearranged in parallel with the first array
   * @param left the starting index of the subarray to be sorted.  To sort the entire array, specify 0.
   * @param right the ending index, INCLUSIVE, of the subarray to be sorted.  To sort the entire array, specify
   *              sortData.length - 1
   */
  private static void quicksort(char[] sortData, short[] auxData, int left, int right) {
    if (right <= left) {
      return;
    }

    // These exchanges are here to reduce both the runtime and the
    // stack usage (level of recursion) in degenerate cases such as
    // when the input is sorted or nearly sorted.
    exchange(sortData, auxData, (left + right) / 2, right - 1);
    compareExchange(sortData, auxData, left, right - 1);
    compareExchange(sortData, auxData, left, right);
    compareExchange(sortData, auxData, right - 1, right);

    if (right - 1 <= left) {
      return;
    }

    int i = partition(sortData, auxData, left + 1, right - 1);

    quicksort(sortData, auxData, left, i - 1);
    quicksort(sortData, auxData, i + 1, right);
  }

  private static int partition(char[] sortData, short[] auxData, int left, int right) {
    int i = left - 1;
    int j = right;

    char sortVal = sortData[right];

    while (true) {
      while (sortData[++i] < sortVal) {
        // this space intentionally left blank
      }

      while (sortVal < sortData[--j]) {
        if (j == left) {
          break;
        }
      }

      if (i >= j) {
        break;
      }

      exchange(sortData, auxData, i, j);
    }

    exchange(sortData, auxData, i, right);
    return i;
  }

  private static void compareExchange(char[] sortData, short[] auxData, int idxA, int idxB) {
    if (sortData[idxB] < sortData[idxA]) {
      exchange(sortData, auxData, idxA, idxB);
    }
  }

  private static void exchange(char[] sortData, short[] auxData, int idxA, int idxB) {
    if (idxA == idxB) {
      return;
    }

    char tempSortVal = sortData[idxA];
    sortData[idxA] = sortData[idxB];
    sortData[idxB] = tempSortVal;

    short tempAuxVal = auxData[idxA];
    auxData[idxA] = auxData[idxB];
    auxData[idxB] = tempAuxVal;
  }

  /**
   * Converts an array of chars to an array of ints.
   *
   * This cast is lossless (no loss of information).
   *
   * @param arr the array to convert
   * @return an array of ints cast from the provided array of chars
   */
  public static int[] toIntegers(char[] arr) {
    int[] res = new int[arr.length];
    for (int i = 0; i < res.length; i++) {
      res[i] = arr[i];
    }

    return res;
  }

  /**
   * In-place sorts two parallel arrays in the natural order of elements of the first array.
   *
   * @param sortData the first array, whose values will determine the final sorted order
   * @param auxData the second array, whose values will be rearranged in parallel with the first array
   */
  public static void sort(char[] sortData, int[] auxData) {
    quicksort(sortData, auxData, 0, sortData.length - 1);
  }

  /**
   * In-place sorts two parallel arrays in the natural order of elements of the first array.
   *
   * @param sortData the first array, whose values will determine the final sorted order
   * @param auxData the second array, whose values will be rearranged in parallel with the first array
   * @param left the starting index of the subarray to be sorted.  To sort the entire array, specify 0.
   * @param right the ending index, INCLUSIVE, of the subarray to be sorted.  To sort the entire array, specify
   *              sortData.length - 1
   */
  private static void quicksort(char[] sortData, int[] auxData, int left, int right) {
    if (right <= left) {
      return;
    }

    // These exchanges are here to reduce both the runtime and the
    // stack usage (level of recursion) in degenerate cases such as
    // when the input is sorted or nearly sorted.
    exchange(sortData, auxData, (left + right) / 2, right - 1);
    compareExchange(sortData, auxData, left, right - 1);
    compareExchange(sortData, auxData, left, right);
    compareExchange(sortData, auxData, right - 1, right);

    if (right - 1 <= left) {
      return;
    }

    int i = partition(sortData, auxData, left + 1, right - 1);

    quicksort(sortData, auxData, left, i - 1);
    quicksort(sortData, auxData, i + 1, right);
  }

  private static int partition(char[] sortData, int[] auxData, int left, int right) {
    int i = left - 1;
    int j = right;

    char sortVal = sortData[right];

    while (true) {
      while (sortData[++i] < sortVal) {
        // this space intentionally left blank
      }

      while (sortVal < sortData[--j]) {
        if (j == left) {
          break;
        }
      }

      if (i >= j) {
        break;
      }

      exchange(sortData, auxData, i, j);
    }

    exchange(sortData, auxData, i, right);
    return i;
  }

  private static void compareExchange(char[] sortData, int[] auxData, int idxA, int idxB) {
    if (sortData[idxB] < sortData[idxA]) {
      exchange(sortData, auxData, idxA, idxB);
    }
  }

  private static void exchange(char[] sortData, int[] auxData, int idxA, int idxB) {
    if (idxA == idxB) {
      return;
    }

    char tempSortVal = sortData[idxA];
    sortData[idxA] = sortData[idxB];
    sortData[idxB] = tempSortVal;

    int tempAuxVal = auxData[idxA];
    auxData[idxA] = auxData[idxB];
    auxData[idxB] = tempAuxVal;
  }

  /**
   * Converts an array of chars to an array of longs.
   *
   * This cast is lossless (no loss of information).
   *
   * @param arr the array to convert
   * @return an array of longs cast from the provided array of chars
   */
  public static long[] toLongs(char[] arr) {
    long[] res = new long[arr.length];
    for (int i = 0; i < res.length; i++) {
      res[i] = arr[i];
    }

    return res;
  }

  /**
   * In-place sorts two parallel arrays in the natural order of elements of the first array.
   *
   * @param sortData the first array, whose values will determine the final sorted order
   * @param auxData the second array, whose values will be rearranged in parallel with the first array
   */
  public static void sort(char[] sortData, long[] auxData) {
    quicksort(sortData, auxData, 0, sortData.length - 1);
  }

  /**
   * In-place sorts two parallel arrays in the natural order of elements of the first array.
   *
   * @param sortData the first array, whose values will determine the final sorted order
   * @param auxData the second array, whose values will be rearranged in parallel with the first array
   * @param left the starting index of the subarray to be sorted.  To sort the entire array, specify 0.
   * @param right the ending index, INCLUSIVE, of the subarray to be sorted.  To sort the entire array, specify
   *              sortData.length - 1
   */
  private static void quicksort(char[] sortData, long[] auxData, int left, int right) {
    if (right <= left) {
      return;
    }

    // These exchanges are here to reduce both the runtime and the
    // stack usage (level of recursion) in degenerate cases such as
    // when the input is sorted or nearly sorted.
    exchange(sortData, auxData, (left + right) / 2, right - 1);
    compareExchange(sortData, auxData, left, right - 1);
    compareExchange(sortData, auxData, left, right);
    compareExchange(sortData, auxData, right - 1, right);

    if (right - 1 <= left) {
      return;
    }

    int i = partition(sortData, auxData, left + 1, right - 1);

    quicksort(sortData, auxData, left, i - 1);
    quicksort(sortData, auxData, i + 1, right);
  }

  private static int partition(char[] sortData, long[] auxData, int left, int right) {
    int i = left - 1;
    int j = right;

    char sortVal = sortData[right];

    while (true) {
      while (sortData[++i] < sortVal) {
        // this space intentionally left blank
      }

      while (sortVal < sortData[--j]) {
        if (j == left) {
          break;
        }
      }

      if (i >= j) {
        break;
      }

      exchange(sortData, auxData, i, j);
    }

    exchange(sortData, auxData, i, right);
    return i;
  }

  private static void compareExchange(char[] sortData, long[] auxData, int idxA, int idxB) {
    if (sortData[idxB] < sortData[idxA]) {
      exchange(sortData, auxData, idxA, idxB);
    }
  }

  private static void exchange(char[] sortData, long[] auxData, int idxA, int idxB) {
    if (idxA == idxB) {
      return;
    }

    char tempSortVal = sortData[idxA];
    sortData[idxA] = sortData[idxB];
    sortData[idxB] = tempSortVal;

    long tempAuxVal = auxData[idxA];
    auxData[idxA] = auxData[idxB];
    auxData[idxB] = tempAuxVal;
  }

  /**
   * Converts an array of chars to an array of floats.
   *
   * This cast is lossless (no loss of information).
   *
   * @param arr the array to convert
   * @return an array of floats cast from the provided array of chars
   */
  public static float[] toFloats(char[] arr) {
    float[] res = new float[arr.length];
    for (int i = 0; i < res.length; i++) {
      res[i] = arr[i];
    }

    return res;
  }

  /**
   * In-place sorts two parallel arrays in the natural order of elements of the first array.
   *
   * @param sortData the first array, whose values will determine the final sorted order
   * @param auxData the second array, whose values will be rearranged in parallel with the first array
   */
  public static void sort(char[] sortData, float[] auxData) {
    quicksort(sortData, auxData, 0, sortData.length - 1);
  }

  /**
   * In-place sorts two parallel arrays in the natural order of elements of the first array.
   *
   * @param sortData the first array, whose values will determine the final sorted order
   * @param auxData the second array, whose values will be rearranged in parallel with the first array
   * @param left the starting index of the subarray to be sorted.  To sort the entire array, specify 0.
   * @param right the ending index, INCLUSIVE, of the subarray to be sorted.  To sort the entire array, specify
   *              sortData.length - 1
   */
  private static void quicksort(char[] sortData, float[] auxData, int left, int right) {
    if (right <= left) {
      return;
    }

    // These exchanges are here to reduce both the runtime and the
    // stack usage (level of recursion) in degenerate cases such as
    // when the input is sorted or nearly sorted.
    exchange(sortData, auxData, (left + right) / 2, right - 1);
    compareExchange(sortData, auxData, left, right - 1);
    compareExchange(sortData, auxData, left, right);
    compareExchange(sortData, auxData, right - 1, right);

    if (right - 1 <= left) {
      return;
    }

    int i = partition(sortData, auxData, left + 1, right - 1);

    quicksort(sortData, auxData, left, i - 1);
    quicksort(sortData, auxData, i + 1, right);
  }

  private static int partition(char[] sortData, float[] auxData, int left, int right) {
    int i = left - 1;
    int j = right;

    char sortVal = sortData[right];

    while (true) {
      while (sortData[++i] < sortVal) {
        // this space intentionally left blank
      }

      while (sortVal < sortData[--j]) {
        if (j == left) {
          break;
        }
      }

      if (i >= j) {
        break;
      }

      exchange(sortData, auxData, i, j);
    }

    exchange(sortData, auxData, i, right);
    return i;
  }

  private static void compareExchange(char[] sortData, float[] auxData, int idxA, int idxB) {
    if (sortData[idxB] < sortData[idxA]) {
      exchange(sortData, auxData, idxA, idxB);
    }
  }

  private static void exchange(char[] sortData, float[] auxData, int idxA, int idxB) {
    if (idxA == idxB) {
      return;
    }

    char tempSortVal = sortData[idxA];
    sortData[idxA] = sortData[idxB];
    sortData[idxB] = tempSortVal;

    float tempAuxVal = auxData[idxA];
    auxData[idxA] = auxData[idxB];
    auxData[idxB] = tempAuxVal;
  }

  /**
   * Converts an array of chars to an array of doubles.
   *
   * This cast is lossless (no loss of information).
   *
   * @param arr the array to convert
   * @return an array of doubles cast from the provided array of chars
   */
  public static double[] toDoubles(char[] arr) {
    double[] res = new double[arr.length];
    for (int i = 0; i < res.length; i++) {
      res[i] = arr[i];
    }

    return res;
  }

  /**
   * In-place sorts two parallel arrays in the natural order of elements of the first array.
   *
   * @param sortData the first array, whose values will determine the final sorted order
   * @param auxData the second array, whose values will be rearranged in parallel with the first array
   */
  public static void sort(char[] sortData, double[] auxData) {
    quicksort(sortData, auxData, 0, sortData.length - 1);
  }

  /**
   * In-place sorts two parallel arrays in the natural order of elements of the first array.
   *
   * @param sortData the first array, whose values will determine the final sorted order
   * @param auxData the second array, whose values will be rearranged in parallel with the first array
   * @param left the starting index of the subarray to be sorted.  To sort the entire array, specify 0.
   * @param right the ending index, INCLUSIVE, of the subarray to be sorted.  To sort the entire array, specify
   *              sortData.length - 1
   */
  private static void quicksort(char[] sortData, double[] auxData, int left, int right) {
    if (right <= left) {
      return;
    }

    // These exchanges are here to reduce both the runtime and the
    // stack usage (level of recursion) in degenerate cases such as
    // when the input is sorted or nearly sorted.
    exchange(sortData, auxData, (left + right) / 2, right - 1);
    compareExchange(sortData, auxData, left, right - 1);
    compareExchange(sortData, auxData, left, right);
    compareExchange(sortData, auxData, right - 1, right);

    if (right - 1 <= left) {
      return;
    }

    int i = partition(sortData, auxData, left + 1, right - 1);

    quicksort(sortData, auxData, left, i - 1);
    quicksort(sortData, auxData, i + 1, right);
  }

  private static int partition(char[] sortData, double[] auxData, int left, int right) {
    int i = left - 1;
    int j = right;

    char sortVal = sortData[right];

    while (true) {
      while (sortData[++i] < sortVal) {
        // this space intentionally left blank
      }

      while (sortVal < sortData[--j]) {
        if (j == left) {
          break;
        }
      }

      if (i >= j) {
        break;
      }

      exchange(sortData, auxData, i, j);
    }

    exchange(sortData, auxData, i, right);
    return i;
  }

  private static void compareExchange(char[] sortData, double[] auxData, int idxA, int idxB) {
    if (sortData[idxB] < sortData[idxA]) {
      exchange(sortData, auxData, idxA, idxB);
    }
  }

  private static void exchange(char[] sortData, double[] auxData, int idxA, int idxB) {
    if (idxA == idxB) {
      return;
    }

    char tempSortVal = sortData[idxA];
    sortData[idxA] = sortData[idxB];
    sortData[idxB] = tempSortVal;

    double tempAuxVal = auxData[idxA];
    auxData[idxA] = auxData[idxB];
    auxData[idxB] = tempAuxVal;
  }

  // ---------------- Begin methods for Shorts ----------------

  /**
   * An instance of an empty short array.  Using this instance rather than creating a new array each time an empty
   * array is needed avoids an unnecessary object creation.
   */
  public static final short[] EMPTY_SHORT_ARRAY = new short[0];

  /**
   * Concatenates one or more arrays.
   *
   * @param arrays one or more arrays to concatenate
   * @return the concatenated array
   */
  public static short[] concat(short[]... arrays) {
    int size = 0;
    for (short[] arr : arrays) {
      size += arr.length;
    }

    short[] res = new short[size];

    int offset = 0;
    for (short[] arr : arrays) {
      System.arraycopy(arr, 0, res, offset, arr.length);
      offset += arr.length;
    }

    return res;
  }

  /**
   * Wraps an array as a {@link java.util.List} just as {@link Arrays#asList(Object[])} does for reference types.
   *
   * However, unlike the list returned by {@link Arrays#asList(Object[])}, the returned list may still grow (or shrink),
   * in which case its underlying array may cease to be the {@code wrapped} array (such that changes in one will cease
   * to induce changes in the other).
   *
   * @param wrapped the array to wrap; until the list size changes, it is guaranteed that changes to the elements of
   *                the array will affect the list wrapper, and vice-versa
   * @return a list that wraps the provided array
   */
  public static ShortArrayList asList(short... wrapped) {
    return ShortArrayList.wrap(wrapped);
  }

  /**
   * Transposes a "matrix" comprised of an array of arrays; each element array[i][j] will be copied to transposed[j][i].
   *
   * If the original array of arrays is "jagged" (with subarray "rows" of differing lengths), the width of the matrix
   * will be taken as the longest of its rows and any "missing" elements in shorter rows will treated as if they were
   * 0.
   *
   * @param matrix the array of arrays to transpose; the subarray "rows" do not need to be of uniform length
   * @return a new, transposed array of arrays such that each element {@code matrix[i][j]} will be copied to
   *         {@code transposed[j][i]}
   */
  public static short[][] transpose(short[][] matrix) {
    // find the longest row in the matrix (its number of columns)--this will be our result matrix's width
    int newHeight = 0;
    for (short[] row : matrix) {
      newHeight = Math.max(newHeight, row.length);
    }

    short[][] transposed = new short[newHeight][matrix.length];
    for (int i = 0; i < matrix.length; i++) {
      short[] row = matrix[i];
      for (int j = 0; j < row.length; j++) {
        transposed[j][i] = row[j];
      }
    }

    return transposed;
  }

  /**
   * Given a sorted array (either least to greatest or greatest to least), places all unique elements at the start of
   * the array (maintaining the original sort order and overwriting their original values) and returns the number of
   * unique elements.
   *
   * For example, if this method is called on the array [1, 2, 2, 2, 3, 3, 4], it will return 4 (the number of unique
   * elements) and the array will be modified to [1, 2, 3, 4, 3, 3, 4].  Note that only the first 4 elements of this
   * array have been changed.
   *
   * The time complexity of this method is O(n), where n is the length of the input array.
   *
   * @param array the sorted array to deduplicate
   * @return the number of unique elements in the provided array
   */
  public static int deduplicateSortedArray(short[] array) {
    // handle empty-array edge case
    if (array.length == 0) {
      return 0;
    }

    // look for duplicates and shift elements up to overwrite any that are found
    int shift = 0;
    for (int i = 1; i < array.length; i++) {
      if (array[i] == array[i - 1]) {
        shift++;
      } else {
        array[i - shift] = array[i]; // if shift == 0 this is a noop
      }
    }

    return array.length - shift;
  }

  /**
   * Reverses the order of the elements of the array.
   *
   * @param array the array to be reversed
   */
  public static void reverse(short[] array) {
    for (int i = 0; i < array.length / 2; i++) {
      short val = array[array.length - i - 1];
      array[array.length - i - 1] = array[i];
      array[i] = val;
    }
  }

  /**
   * Returns true if the elements of the array are monotonically increasing (i.e. in natural order)
   *
   * @param array the array to be checked
   * @return true if the array is monotonically increasing, false otherwise
   */
  public static boolean isMonotonicallyIncreasing(short[] array) {
    if (array.length > 0) {
      short previousElement = array[0];
      for (int i = 1; i < array.length; i++) {
        if (array[i] < previousElement) {
          return false;
        }
        previousElement = array[i];
      }
    }

    return true;
  }

  /**
   * Returns true if the elements of the array are monotonically decreasing (i.e. in reverse natural order)
   *
   * @param array the array to be checked
   * @return true if the array is monotonically decreasing, false otherwise
   */
  public static boolean isMonotonicallyDecreasing(short[] array) {
    if (array.length > 0) {
      short previousElement = array[0];
      for (int i = 1; i < array.length; i++) {
        if (array[i] > previousElement) {
          return false;
        }
        previousElement = array[i];
      }
    }

    return true;
  }

  /**
   * Converts an {@link Iterable} of {@link Number}s to an array of shorts.
   *
   * This method is "lossy" because it does not know, a priori, the concrete types of the providers {@link Number}s,
   * and some information may be lost.  {@link Number#shortValue()} is used to obtain the array values.
   *
   * A run-time exception will be thrown if the quantity of elements in the provided {@link Iterable} exceeds the
   * maximum array length on this JVM.
   *
   * @param numbers the numbers that should be converted into an array of shorts
   * @return an array of shorts, possibly subject to truncation or rounding
   */
  public static short[] toShortsLossy(Iterable<? extends Number> numbers) {
    short[] res = new short[Math.toIntExact(Iterables.size64(numbers))];

    java.util.Iterator<? extends Number> iterator = numbers.iterator();
    try {
      for (int i = 0; i < res.length; i++) {
        res[i] = iterator.next().shortValue();
      }
      return res;
    } finally {
      // properly close AutoCloseable iterators
      Closeables.tryClose(iterator);
    }
  }

  /**
   * In-place sorts two parallel arrays in the natural order of elements of the first array.
   *
   * @param sortData the first array, whose values will determine the final sorted order
   * @param auxData the second array, whose values will be rearranged in parallel with the first array
   */
  public static void sort(short[] sortData, Object[] auxData) {
    quicksort(sortData, auxData, 0, sortData.length - 1);
  }

  /**
   * In-place sorts two parallel arrays in the natural order of elements of the first array.
   *
   * @param sortData the first array, whose values will determine the final sorted order
   * @param auxData the second array, whose values will be rearranged in parallel with the first array
   * @param left the starting index of the subarray to be sorted.  To sort the entire array, specify 0.
   * @param right the ending index, INCLUSIVE, of the subarray to be sorted.  To sort the entire array, specify
   *              sortData.length - 1
   */
  private static void quicksort(short[] sortData, Object[] auxData, int left, int right) {
    if (right <= left) {
      return;
    }

    // These exchanges are here to reduce both the runtime and the
    // stack usage (level of recursion) in degenerate cases such as
    // when the input is sorted or nearly sorted.
    exchange(sortData, auxData, (left + right) / 2, right - 1);
    compareExchange(sortData, auxData, left, right - 1);
    compareExchange(sortData, auxData, left, right);
    compareExchange(sortData, auxData, right - 1, right);

    if (right - 1 <= left) {
      return;
    }

    int i = partition(sortData, auxData, left + 1, right - 1);

    quicksort(sortData, auxData, left, i - 1);
    quicksort(sortData, auxData, i + 1, right);
  }

  private static int partition(short[] sortData, Object[] auxData, int left, int right) {
    int i = left - 1;
    int j = right;

    short sortVal = sortData[right];

    while (true) {
      while (sortData[++i] < sortVal) {
        // this space intentionally left blank
      }

      while (sortVal < sortData[--j]) {
        if (j == left) {
          break;
        }
      }

      if (i >= j) {
        break;
      }

      exchange(sortData, auxData, i, j);
    }

    exchange(sortData, auxData, i, right);
    return i;
  }

  private static void compareExchange(short[] sortData, Object[] auxData, int idxA, int idxB) {
    if (sortData[idxB] < sortData[idxA]) {
      exchange(sortData, auxData, idxA, idxB);
    }
  }

  private static void exchange(short[] sortData, Object[] auxData, int idxA, int idxB) {
    if (idxA == idxB) {
      return;
    }

    short tempSortVal = sortData[idxA];
    sortData[idxA] = sortData[idxB];
    sortData[idxB] = tempSortVal;

    Object tempAuxVal = auxData[idxA];
    auxData[idxA] = auxData[idxB];
    auxData[idxB] = tempAuxVal;
  }

  /**
   * In-place sorts two parallel arrays in the natural order of elements of the first array.
   *
   * @param sortData the first array, whose values will determine the final sorted order
   * @param auxData the second array, whose values will be rearranged in parallel with the first array
   */
  public static void sort(short[] sortData, boolean[] auxData) {
    quicksort(sortData, auxData, 0, sortData.length - 1);
  }

  /**
   * In-place sorts two parallel arrays in the natural order of elements of the first array.
   *
   * @param sortData the first array, whose values will determine the final sorted order
   * @param auxData the second array, whose values will be rearranged in parallel with the first array
   * @param left the starting index of the subarray to be sorted.  To sort the entire array, specify 0.
   * @param right the ending index, INCLUSIVE, of the subarray to be sorted.  To sort the entire array, specify
   *              sortData.length - 1
   */
  private static void quicksort(short[] sortData, boolean[] auxData, int left, int right) {
    if (right <= left) {
      return;
    }

    // These exchanges are here to reduce both the runtime and the
    // stack usage (level of recursion) in degenerate cases such as
    // when the input is sorted or nearly sorted.
    exchange(sortData, auxData, (left + right) / 2, right - 1);
    compareExchange(sortData, auxData, left, right - 1);
    compareExchange(sortData, auxData, left, right);
    compareExchange(sortData, auxData, right - 1, right);

    if (right - 1 <= left) {
      return;
    }

    int i = partition(sortData, auxData, left + 1, right - 1);

    quicksort(sortData, auxData, left, i - 1);
    quicksort(sortData, auxData, i + 1, right);
  }

  private static int partition(short[] sortData, boolean[] auxData, int left, int right) {
    int i = left - 1;
    int j = right;

    short sortVal = sortData[right];

    while (true) {
      while (sortData[++i] < sortVal) {
        // this space intentionally left blank
      }

      while (sortVal < sortData[--j]) {
        if (j == left) {
          break;
        }
      }

      if (i >= j) {
        break;
      }

      exchange(sortData, auxData, i, j);
    }

    exchange(sortData, auxData, i, right);
    return i;
  }

  private static void compareExchange(short[] sortData, boolean[] auxData, int idxA, int idxB) {
    if (sortData[idxB] < sortData[idxA]) {
      exchange(sortData, auxData, idxA, idxB);
    }
  }

  private static void exchange(short[] sortData, boolean[] auxData, int idxA, int idxB) {
    if (idxA == idxB) {
      return;
    }

    short tempSortVal = sortData[idxA];
    sortData[idxA] = sortData[idxB];
    sortData[idxB] = tempSortVal;

    boolean tempAuxVal = auxData[idxA];
    auxData[idxA] = auxData[idxB];
    auxData[idxB] = tempAuxVal;
  }

  /**
   * Converts an array of shorts to an array of bytes.
   *
   * This cast is "lossy" and may lose information.
   *
   * @param arr the array to convert
   * @return an array of bytes cast from the provided array of shorts
   */
  public static byte[] toBytesLossy(short[] arr) {
    byte[] res = new byte[arr.length];
    for (int i = 0; i < res.length; i++) {
      res[i] = (byte) arr[i];
    }

    return res;
  }

  /**
   * Converts an array of shorts to an array of bytes, throwing an exception if the
   * converted values do not <i>exactly</i> match the originals (as determined by {@code !=}.)
   *
   * @param arr the array to convert
   * @return an array of bytes cast from the provided array of shorts
   * @throws ArithmeticException if the array cannot be losslessly converted
   */
  public static byte[] toBytesExact(short[] arr) {
    byte[] res = toBytesLossy(arr);
    for (int i = 0; i < res.length; i++) {
      if (res[i] != arr[i]) {
        throw new ArithmeticException("Cannot losslessly convert provided short[] to byte[] at index " + i + "; "
            + res[i] + " != " + arr[i]);
      }
    }

    return res;
  }

  /**
   * In-place sorts two parallel arrays in the natural order of elements of the first array.
   *
   * @param sortData the first array, whose values will determine the final sorted order
   * @param auxData the second array, whose values will be rearranged in parallel with the first array
   */
  public static void sort(short[] sortData, byte[] auxData) {
    quicksort(sortData, auxData, 0, sortData.length - 1);
  }

  /**
   * In-place sorts two parallel arrays in the natural order of elements of the first array.
   *
   * @param sortData the first array, whose values will determine the final sorted order
   * @param auxData the second array, whose values will be rearranged in parallel with the first array
   * @param left the starting index of the subarray to be sorted.  To sort the entire array, specify 0.
   * @param right the ending index, INCLUSIVE, of the subarray to be sorted.  To sort the entire array, specify
   *              sortData.length - 1
   */
  private static void quicksort(short[] sortData, byte[] auxData, int left, int right) {
    if (right <= left) {
      return;
    }

    // These exchanges are here to reduce both the runtime and the
    // stack usage (level of recursion) in degenerate cases such as
    // when the input is sorted or nearly sorted.
    exchange(sortData, auxData, (left + right) / 2, right - 1);
    compareExchange(sortData, auxData, left, right - 1);
    compareExchange(sortData, auxData, left, right);
    compareExchange(sortData, auxData, right - 1, right);

    if (right - 1 <= left) {
      return;
    }

    int i = partition(sortData, auxData, left + 1, right - 1);

    quicksort(sortData, auxData, left, i - 1);
    quicksort(sortData, auxData, i + 1, right);
  }

  private static int partition(short[] sortData, byte[] auxData, int left, int right) {
    int i = left - 1;
    int j = right;

    short sortVal = sortData[right];

    while (true) {
      while (sortData[++i] < sortVal) {
        // this space intentionally left blank
      }

      while (sortVal < sortData[--j]) {
        if (j == left) {
          break;
        }
      }

      if (i >= j) {
        break;
      }

      exchange(sortData, auxData, i, j);
    }

    exchange(sortData, auxData, i, right);
    return i;
  }

  private static void compareExchange(short[] sortData, byte[] auxData, int idxA, int idxB) {
    if (sortData[idxB] < sortData[idxA]) {
      exchange(sortData, auxData, idxA, idxB);
    }
  }

  private static void exchange(short[] sortData, byte[] auxData, int idxA, int idxB) {
    if (idxA == idxB) {
      return;
    }

    short tempSortVal = sortData[idxA];
    sortData[idxA] = sortData[idxB];
    sortData[idxB] = tempSortVal;

    byte tempAuxVal = auxData[idxA];
    auxData[idxA] = auxData[idxB];
    auxData[idxB] = tempAuxVal;
  }

  /**
   * Converts an array of shorts to an array of chars.
   *
   * This cast is lossless (no loss of information).
   *
   * @param arr the array to convert
   * @return an array of chars cast from the provided array of shorts
   */
  public static char[] toCharacters(short[] arr) {
    char[] res = new char[arr.length];
    for (int i = 0; i < res.length; i++) {
      res[i] = (char) arr[i];
    }

    return res;
  }

  /**
   * In-place sorts two parallel arrays in the natural order of elements of the first array.
   *
   * @param sortData the first array, whose values will determine the final sorted order
   * @param auxData the second array, whose values will be rearranged in parallel with the first array
   */
  public static void sort(short[] sortData, char[] auxData) {
    quicksort(sortData, auxData, 0, sortData.length - 1);
  }

  /**
   * In-place sorts two parallel arrays in the natural order of elements of the first array.
   *
   * @param sortData the first array, whose values will determine the final sorted order
   * @param auxData the second array, whose values will be rearranged in parallel with the first array
   * @param left the starting index of the subarray to be sorted.  To sort the entire array, specify 0.
   * @param right the ending index, INCLUSIVE, of the subarray to be sorted.  To sort the entire array, specify
   *              sortData.length - 1
   */
  private static void quicksort(short[] sortData, char[] auxData, int left, int right) {
    if (right <= left) {
      return;
    }

    // These exchanges are here to reduce both the runtime and the
    // stack usage (level of recursion) in degenerate cases such as
    // when the input is sorted or nearly sorted.
    exchange(sortData, auxData, (left + right) / 2, right - 1);
    compareExchange(sortData, auxData, left, right - 1);
    compareExchange(sortData, auxData, left, right);
    compareExchange(sortData, auxData, right - 1, right);

    if (right - 1 <= left) {
      return;
    }

    int i = partition(sortData, auxData, left + 1, right - 1);

    quicksort(sortData, auxData, left, i - 1);
    quicksort(sortData, auxData, i + 1, right);
  }

  private static int partition(short[] sortData, char[] auxData, int left, int right) {
    int i = left - 1;
    int j = right;

    short sortVal = sortData[right];

    while (true) {
      while (sortData[++i] < sortVal) {
        // this space intentionally left blank
      }

      while (sortVal < sortData[--j]) {
        if (j == left) {
          break;
        }
      }

      if (i >= j) {
        break;
      }

      exchange(sortData, auxData, i, j);
    }

    exchange(sortData, auxData, i, right);
    return i;
  }

  private static void compareExchange(short[] sortData, char[] auxData, int idxA, int idxB) {
    if (sortData[idxB] < sortData[idxA]) {
      exchange(sortData, auxData, idxA, idxB);
    }
  }

  private static void exchange(short[] sortData, char[] auxData, int idxA, int idxB) {
    if (idxA == idxB) {
      return;
    }

    short tempSortVal = sortData[idxA];
    sortData[idxA] = sortData[idxB];
    sortData[idxB] = tempSortVal;

    char tempAuxVal = auxData[idxA];
    auxData[idxA] = auxData[idxB];
    auxData[idxB] = tempAuxVal;
  }

  /**
   * In-place sorts two parallel arrays in the natural order of elements of the first array.
   *
   * @param sortData the first array, whose values will determine the final sorted order
   * @param auxData the second array, whose values will be rearranged in parallel with the first array
   */
  public static void sort(short[] sortData, short[] auxData) {
    quicksort(sortData, auxData, 0, sortData.length - 1);
  }

  /**
   * In-place sorts two parallel arrays in the natural order of elements of the first array.
   *
   * @param sortData the first array, whose values will determine the final sorted order
   * @param auxData the second array, whose values will be rearranged in parallel with the first array
   * @param left the starting index of the subarray to be sorted.  To sort the entire array, specify 0.
   * @param right the ending index, INCLUSIVE, of the subarray to be sorted.  To sort the entire array, specify
   *              sortData.length - 1
   */
  private static void quicksort(short[] sortData, short[] auxData, int left, int right) {
    if (right <= left) {
      return;
    }

    // These exchanges are here to reduce both the runtime and the
    // stack usage (level of recursion) in degenerate cases such as
    // when the input is sorted or nearly sorted.
    exchange(sortData, auxData, (left + right) / 2, right - 1);
    compareExchange(sortData, auxData, left, right - 1);
    compareExchange(sortData, auxData, left, right);
    compareExchange(sortData, auxData, right - 1, right);

    if (right - 1 <= left) {
      return;
    }

    int i = partition(sortData, auxData, left + 1, right - 1);

    quicksort(sortData, auxData, left, i - 1);
    quicksort(sortData, auxData, i + 1, right);
  }

  private static int partition(short[] sortData, short[] auxData, int left, int right) {
    int i = left - 1;
    int j = right;

    short sortVal = sortData[right];

    while (true) {
      while (sortData[++i] < sortVal) {
        // this space intentionally left blank
      }

      while (sortVal < sortData[--j]) {
        if (j == left) {
          break;
        }
      }

      if (i >= j) {
        break;
      }

      exchange(sortData, auxData, i, j);
    }

    exchange(sortData, auxData, i, right);
    return i;
  }

  private static void compareExchange(short[] sortData, short[] auxData, int idxA, int idxB) {
    if (sortData[idxB] < sortData[idxA]) {
      exchange(sortData, auxData, idxA, idxB);
    }
  }

  private static void exchange(short[] sortData, short[] auxData, int idxA, int idxB) {
    if (idxA == idxB) {
      return;
    }

    short tempSortVal = sortData[idxA];
    sortData[idxA] = sortData[idxB];
    sortData[idxB] = tempSortVal;

    short tempAuxVal = auxData[idxA];
    auxData[idxA] = auxData[idxB];
    auxData[idxB] = tempAuxVal;
  }

  /**
   * Converts an array of shorts to an array of ints.
   *
   * This cast is lossless (no loss of information).
   *
   * @param arr the array to convert
   * @return an array of ints cast from the provided array of shorts
   */
  public static int[] toIntegers(short[] arr) {
    int[] res = new int[arr.length];
    for (int i = 0; i < res.length; i++) {
      res[i] = arr[i];
    }

    return res;
  }

  /**
   * In-place sorts two parallel arrays in the natural order of elements of the first array.
   *
   * @param sortData the first array, whose values will determine the final sorted order
   * @param auxData the second array, whose values will be rearranged in parallel with the first array
   */
  public static void sort(short[] sortData, int[] auxData) {
    quicksort(sortData, auxData, 0, sortData.length - 1);
  }

  /**
   * In-place sorts two parallel arrays in the natural order of elements of the first array.
   *
   * @param sortData the first array, whose values will determine the final sorted order
   * @param auxData the second array, whose values will be rearranged in parallel with the first array
   * @param left the starting index of the subarray to be sorted.  To sort the entire array, specify 0.
   * @param right the ending index, INCLUSIVE, of the subarray to be sorted.  To sort the entire array, specify
   *              sortData.length - 1
   */
  private static void quicksort(short[] sortData, int[] auxData, int left, int right) {
    if (right <= left) {
      return;
    }

    // These exchanges are here to reduce both the runtime and the
    // stack usage (level of recursion) in degenerate cases such as
    // when the input is sorted or nearly sorted.
    exchange(sortData, auxData, (left + right) / 2, right - 1);
    compareExchange(sortData, auxData, left, right - 1);
    compareExchange(sortData, auxData, left, right);
    compareExchange(sortData, auxData, right - 1, right);

    if (right - 1 <= left) {
      return;
    }

    int i = partition(sortData, auxData, left + 1, right - 1);

    quicksort(sortData, auxData, left, i - 1);
    quicksort(sortData, auxData, i + 1, right);
  }

  private static int partition(short[] sortData, int[] auxData, int left, int right) {
    int i = left - 1;
    int j = right;

    short sortVal = sortData[right];

    while (true) {
      while (sortData[++i] < sortVal) {
        // this space intentionally left blank
      }

      while (sortVal < sortData[--j]) {
        if (j == left) {
          break;
        }
      }

      if (i >= j) {
        break;
      }

      exchange(sortData, auxData, i, j);
    }

    exchange(sortData, auxData, i, right);
    return i;
  }

  private static void compareExchange(short[] sortData, int[] auxData, int idxA, int idxB) {
    if (sortData[idxB] < sortData[idxA]) {
      exchange(sortData, auxData, idxA, idxB);
    }
  }

  private static void exchange(short[] sortData, int[] auxData, int idxA, int idxB) {
    if (idxA == idxB) {
      return;
    }

    short tempSortVal = sortData[idxA];
    sortData[idxA] = sortData[idxB];
    sortData[idxB] = tempSortVal;

    int tempAuxVal = auxData[idxA];
    auxData[idxA] = auxData[idxB];
    auxData[idxB] = tempAuxVal;
  }

  /**
   * Converts an array of shorts to an array of longs.
   *
   * This cast is lossless (no loss of information).
   *
   * @param arr the array to convert
   * @return an array of longs cast from the provided array of shorts
   */
  public static long[] toLongs(short[] arr) {
    long[] res = new long[arr.length];
    for (int i = 0; i < res.length; i++) {
      res[i] = arr[i];
    }

    return res;
  }

  /**
   * In-place sorts two parallel arrays in the natural order of elements of the first array.
   *
   * @param sortData the first array, whose values will determine the final sorted order
   * @param auxData the second array, whose values will be rearranged in parallel with the first array
   */
  public static void sort(short[] sortData, long[] auxData) {
    quicksort(sortData, auxData, 0, sortData.length - 1);
  }

  /**
   * In-place sorts two parallel arrays in the natural order of elements of the first array.
   *
   * @param sortData the first array, whose values will determine the final sorted order
   * @param auxData the second array, whose values will be rearranged in parallel with the first array
   * @param left the starting index of the subarray to be sorted.  To sort the entire array, specify 0.
   * @param right the ending index, INCLUSIVE, of the subarray to be sorted.  To sort the entire array, specify
   *              sortData.length - 1
   */
  private static void quicksort(short[] sortData, long[] auxData, int left, int right) {
    if (right <= left) {
      return;
    }

    // These exchanges are here to reduce both the runtime and the
    // stack usage (level of recursion) in degenerate cases such as
    // when the input is sorted or nearly sorted.
    exchange(sortData, auxData, (left + right) / 2, right - 1);
    compareExchange(sortData, auxData, left, right - 1);
    compareExchange(sortData, auxData, left, right);
    compareExchange(sortData, auxData, right - 1, right);

    if (right - 1 <= left) {
      return;
    }

    int i = partition(sortData, auxData, left + 1, right - 1);

    quicksort(sortData, auxData, left, i - 1);
    quicksort(sortData, auxData, i + 1, right);
  }

  private static int partition(short[] sortData, long[] auxData, int left, int right) {
    int i = left - 1;
    int j = right;

    short sortVal = sortData[right];

    while (true) {
      while (sortData[++i] < sortVal) {
        // this space intentionally left blank
      }

      while (sortVal < sortData[--j]) {
        if (j == left) {
          break;
        }
      }

      if (i >= j) {
        break;
      }

      exchange(sortData, auxData, i, j);
    }

    exchange(sortData, auxData, i, right);
    return i;
  }

  private static void compareExchange(short[] sortData, long[] auxData, int idxA, int idxB) {
    if (sortData[idxB] < sortData[idxA]) {
      exchange(sortData, auxData, idxA, idxB);
    }
  }

  private static void exchange(short[] sortData, long[] auxData, int idxA, int idxB) {
    if (idxA == idxB) {
      return;
    }

    short tempSortVal = sortData[idxA];
    sortData[idxA] = sortData[idxB];
    sortData[idxB] = tempSortVal;

    long tempAuxVal = auxData[idxA];
    auxData[idxA] = auxData[idxB];
    auxData[idxB] = tempAuxVal;
  }

  /**
   * Converts an array of shorts to an array of floats.
   *
   * This cast is lossless (no loss of information).
   *
   * @param arr the array to convert
   * @return an array of floats cast from the provided array of shorts
   */
  public static float[] toFloats(short[] arr) {
    float[] res = new float[arr.length];
    for (int i = 0; i < res.length; i++) {
      res[i] = arr[i];
    }

    return res;
  }

  /**
   * In-place sorts two parallel arrays in the natural order of elements of the first array.
   *
   * @param sortData the first array, whose values will determine the final sorted order
   * @param auxData the second array, whose values will be rearranged in parallel with the first array
   */
  public static void sort(short[] sortData, float[] auxData) {
    quicksort(sortData, auxData, 0, sortData.length - 1);
  }

  /**
   * In-place sorts two parallel arrays in the natural order of elements of the first array.
   *
   * @param sortData the first array, whose values will determine the final sorted order
   * @param auxData the second array, whose values will be rearranged in parallel with the first array
   * @param left the starting index of the subarray to be sorted.  To sort the entire array, specify 0.
   * @param right the ending index, INCLUSIVE, of the subarray to be sorted.  To sort the entire array, specify
   *              sortData.length - 1
   */
  private static void quicksort(short[] sortData, float[] auxData, int left, int right) {
    if (right <= left) {
      return;
    }

    // These exchanges are here to reduce both the runtime and the
    // stack usage (level of recursion) in degenerate cases such as
    // when the input is sorted or nearly sorted.
    exchange(sortData, auxData, (left + right) / 2, right - 1);
    compareExchange(sortData, auxData, left, right - 1);
    compareExchange(sortData, auxData, left, right);
    compareExchange(sortData, auxData, right - 1, right);

    if (right - 1 <= left) {
      return;
    }

    int i = partition(sortData, auxData, left + 1, right - 1);

    quicksort(sortData, auxData, left, i - 1);
    quicksort(sortData, auxData, i + 1, right);
  }

  private static int partition(short[] sortData, float[] auxData, int left, int right) {
    int i = left - 1;
    int j = right;

    short sortVal = sortData[right];

    while (true) {
      while (sortData[++i] < sortVal) {
        // this space intentionally left blank
      }

      while (sortVal < sortData[--j]) {
        if (j == left) {
          break;
        }
      }

      if (i >= j) {
        break;
      }

      exchange(sortData, auxData, i, j);
    }

    exchange(sortData, auxData, i, right);
    return i;
  }

  private static void compareExchange(short[] sortData, float[] auxData, int idxA, int idxB) {
    if (sortData[idxB] < sortData[idxA]) {
      exchange(sortData, auxData, idxA, idxB);
    }
  }

  private static void exchange(short[] sortData, float[] auxData, int idxA, int idxB) {
    if (idxA == idxB) {
      return;
    }

    short tempSortVal = sortData[idxA];
    sortData[idxA] = sortData[idxB];
    sortData[idxB] = tempSortVal;

    float tempAuxVal = auxData[idxA];
    auxData[idxA] = auxData[idxB];
    auxData[idxB] = tempAuxVal;
  }

  /**
   * Converts an array of shorts to an array of doubles.
   *
   * This cast is lossless (no loss of information).
   *
   * @param arr the array to convert
   * @return an array of doubles cast from the provided array of shorts
   */
  public static double[] toDoubles(short[] arr) {
    double[] res = new double[arr.length];
    for (int i = 0; i < res.length; i++) {
      res[i] = arr[i];
    }

    return res;
  }

  /**
   * In-place sorts two parallel arrays in the natural order of elements of the first array.
   *
   * @param sortData the first array, whose values will determine the final sorted order
   * @param auxData the second array, whose values will be rearranged in parallel with the first array
   */
  public static void sort(short[] sortData, double[] auxData) {
    quicksort(sortData, auxData, 0, sortData.length - 1);
  }

  /**
   * In-place sorts two parallel arrays in the natural order of elements of the first array.
   *
   * @param sortData the first array, whose values will determine the final sorted order
   * @param auxData the second array, whose values will be rearranged in parallel with the first array
   * @param left the starting index of the subarray to be sorted.  To sort the entire array, specify 0.
   * @param right the ending index, INCLUSIVE, of the subarray to be sorted.  To sort the entire array, specify
   *              sortData.length - 1
   */
  private static void quicksort(short[] sortData, double[] auxData, int left, int right) {
    if (right <= left) {
      return;
    }

    // These exchanges are here to reduce both the runtime and the
    // stack usage (level of recursion) in degenerate cases such as
    // when the input is sorted or nearly sorted.
    exchange(sortData, auxData, (left + right) / 2, right - 1);
    compareExchange(sortData, auxData, left, right - 1);
    compareExchange(sortData, auxData, left, right);
    compareExchange(sortData, auxData, right - 1, right);

    if (right - 1 <= left) {
      return;
    }

    int i = partition(sortData, auxData, left + 1, right - 1);

    quicksort(sortData, auxData, left, i - 1);
    quicksort(sortData, auxData, i + 1, right);
  }

  private static int partition(short[] sortData, double[] auxData, int left, int right) {
    int i = left - 1;
    int j = right;

    short sortVal = sortData[right];

    while (true) {
      while (sortData[++i] < sortVal) {
        // this space intentionally left blank
      }

      while (sortVal < sortData[--j]) {
        if (j == left) {
          break;
        }
      }

      if (i >= j) {
        break;
      }

      exchange(sortData, auxData, i, j);
    }

    exchange(sortData, auxData, i, right);
    return i;
  }

  private static void compareExchange(short[] sortData, double[] auxData, int idxA, int idxB) {
    if (sortData[idxB] < sortData[idxA]) {
      exchange(sortData, auxData, idxA, idxB);
    }
  }

  private static void exchange(short[] sortData, double[] auxData, int idxA, int idxB) {
    if (idxA == idxB) {
      return;
    }

    short tempSortVal = sortData[idxA];
    sortData[idxA] = sortData[idxB];
    sortData[idxB] = tempSortVal;

    double tempAuxVal = auxData[idxA];
    auxData[idxA] = auxData[idxB];
    auxData[idxB] = tempAuxVal;
  }

  // ---------------- Begin methods for Integers ----------------

  /**
   * An instance of an empty int array.  Using this instance rather than creating a new array each time an empty
   * array is needed avoids an unnecessary object creation.
   */
  public static final int[] EMPTY_INTEGER_ARRAY = new int[0];

  /**
   * Concatenates one or more arrays.
   *
   * @param arrays one or more arrays to concatenate
   * @return the concatenated array
   */
  public static int[] concat(int[]... arrays) {
    int size = 0;
    for (int[] arr : arrays) {
      size += arr.length;
    }

    int[] res = new int[size];

    int offset = 0;
    for (int[] arr : arrays) {
      System.arraycopy(arr, 0, res, offset, arr.length);
      offset += arr.length;
    }

    return res;
  }

  /**
   * Wraps an array as a {@link java.util.List} just as {@link Arrays#asList(Object[])} does for reference types.
   *
   * However, unlike the list returned by {@link Arrays#asList(Object[])}, the returned list may still grow (or shrink),
   * in which case its underlying array may cease to be the {@code wrapped} array (such that changes in one will cease
   * to induce changes in the other).
   *
   * @param wrapped the array to wrap; until the list size changes, it is guaranteed that changes to the elements of
   *                the array will affect the list wrapper, and vice-versa
   * @return a list that wraps the provided array
   */
  public static IntArrayList asList(int... wrapped) {
    return IntArrayList.wrap(wrapped);
  }

  /**
   * Transposes a "matrix" comprised of an array of arrays; each element array[i][j] will be copied to transposed[j][i].
   *
   * If the original array of arrays is "jagged" (with subarray "rows" of differing lengths), the width of the matrix
   * will be taken as the longest of its rows and any "missing" elements in shorter rows will treated as if they were
   * 0.
   *
   * @param matrix the array of arrays to transpose; the subarray "rows" do not need to be of uniform length
   * @return a new, transposed array of arrays such that each element {@code matrix[i][j]} will be copied to
   *         {@code transposed[j][i]}
   */
  public static int[][] transpose(int[][] matrix) {
    // find the longest row in the matrix (its number of columns)--this will be our result matrix's width
    int newHeight = 0;
    for (int[] row : matrix) {
      newHeight = Math.max(newHeight, row.length);
    }

    int[][] transposed = new int[newHeight][matrix.length];
    for (int i = 0; i < matrix.length; i++) {
      int[] row = matrix[i];
      for (int j = 0; j < row.length; j++) {
        transposed[j][i] = row[j];
      }
    }

    return transposed;
  }

  /**
   * Given a sorted array (either least to greatest or greatest to least), places all unique elements at the start of
   * the array (maintaining the original sort order and overwriting their original values) and returns the number of
   * unique elements.
   *
   * For example, if this method is called on the array [1, 2, 2, 2, 3, 3, 4], it will return 4 (the number of unique
   * elements) and the array will be modified to [1, 2, 3, 4, 3, 3, 4].  Note that only the first 4 elements of this
   * array have been changed.
   *
   * The time complexity of this method is O(n), where n is the length of the input array.
   *
   * @param array the sorted array to deduplicate
   * @return the number of unique elements in the provided array
   */
  public static int deduplicateSortedArray(int[] array) {
    // handle empty-array edge case
    if (array.length == 0) {
      return 0;
    }

    // look for duplicates and shift elements up to overwrite any that are found
    int shift = 0;
    for (int i = 1; i < array.length; i++) {
      if (array[i] == array[i - 1]) {
        shift++;
      } else {
        array[i - shift] = array[i]; // if shift == 0 this is a noop
      }
    }

    return array.length - shift;
  }

  /**
   * Reverses the order of the elements of the array.
   *
   * @param array the array to be reversed
   */
  public static void reverse(int[] array) {
    for (int i = 0; i < array.length / 2; i++) {
      int val = array[array.length - i - 1];
      array[array.length - i - 1] = array[i];
      array[i] = val;
    }
  }

  /**
   * Returns true if the elements of the array are monotonically increasing (i.e. in natural order)
   *
   * @param array the array to be checked
   * @return true if the array is monotonically increasing, false otherwise
   */
  public static boolean isMonotonicallyIncreasing(int[] array) {
    if (array.length > 0) {
      int previousElement = array[0];
      for (int i = 1; i < array.length; i++) {
        if (array[i] < previousElement) {
          return false;
        }
        previousElement = array[i];
      }
    }

    return true;
  }

  /**
   * Returns true if the elements of the array are monotonically decreasing (i.e. in reverse natural order)
   *
   * @param array the array to be checked
   * @return true if the array is monotonically decreasing, false otherwise
   */
  public static boolean isMonotonicallyDecreasing(int[] array) {
    if (array.length > 0) {
      int previousElement = array[0];
      for (int i = 1; i < array.length; i++) {
        if (array[i] > previousElement) {
          return false;
        }
        previousElement = array[i];
      }
    }

    return true;
  }

  /**
   * Converts an {@link Iterable} of {@link Number}s to an array of ints.
   *
   * This method is "lossy" because it does not know, a priori, the concrete types of the providers {@link Number}s,
   * and some information may be lost.  {@link Number#intValue()} is used to obtain the array values.
   *
   * A run-time exception will be thrown if the quantity of elements in the provided {@link Iterable} exceeds the
   * maximum array length on this JVM.
   *
   * @param numbers the numbers that should be converted into an array of ints
   * @return an array of ints, possibly subject to truncation or rounding
   */
  public static int[] toIntegersLossy(Iterable<? extends Number> numbers) {
    int[] res = new int[Math.toIntExact(Iterables.size64(numbers))];

    java.util.Iterator<? extends Number> iterator = numbers.iterator();
    try {
      for (int i = 0; i < res.length; i++) {
        res[i] = iterator.next().intValue();
      }
      return res;
    } finally {
      // properly close AutoCloseable iterators
      Closeables.tryClose(iterator);
    }
  }

  /**
   * In-place sorts two parallel arrays in the natural order of elements of the first array.
   *
   * @param sortData the first array, whose values will determine the final sorted order
   * @param auxData the second array, whose values will be rearranged in parallel with the first array
   */
  public static void sort(int[] sortData, Object[] auxData) {
    quicksort(sortData, auxData, 0, sortData.length - 1);
  }

  /**
   * In-place sorts two parallel arrays in the natural order of elements of the first array.
   *
   * @param sortData the first array, whose values will determine the final sorted order
   * @param auxData the second array, whose values will be rearranged in parallel with the first array
   * @param left the starting index of the subarray to be sorted.  To sort the entire array, specify 0.
   * @param right the ending index, INCLUSIVE, of the subarray to be sorted.  To sort the entire array, specify
   *              sortData.length - 1
   */
  private static void quicksort(int[] sortData, Object[] auxData, int left, int right) {
    if (right <= left) {
      return;
    }

    // These exchanges are here to reduce both the runtime and the
    // stack usage (level of recursion) in degenerate cases such as
    // when the input is sorted or nearly sorted.
    exchange(sortData, auxData, (left + right) / 2, right - 1);
    compareExchange(sortData, auxData, left, right - 1);
    compareExchange(sortData, auxData, left, right);
    compareExchange(sortData, auxData, right - 1, right);

    if (right - 1 <= left) {
      return;
    }

    int i = partition(sortData, auxData, left + 1, right - 1);

    quicksort(sortData, auxData, left, i - 1);
    quicksort(sortData, auxData, i + 1, right);
  }

  private static int partition(int[] sortData, Object[] auxData, int left, int right) {
    int i = left - 1;
    int j = right;

    int sortVal = sortData[right];

    while (true) {
      while (sortData[++i] < sortVal) {
        // this space intentionally left blank
      }

      while (sortVal < sortData[--j]) {
        if (j == left) {
          break;
        }
      }

      if (i >= j) {
        break;
      }

      exchange(sortData, auxData, i, j);
    }

    exchange(sortData, auxData, i, right);
    return i;
  }

  private static void compareExchange(int[] sortData, Object[] auxData, int idxA, int idxB) {
    if (sortData[idxB] < sortData[idxA]) {
      exchange(sortData, auxData, idxA, idxB);
    }
  }

  private static void exchange(int[] sortData, Object[] auxData, int idxA, int idxB) {
    if (idxA == idxB) {
      return;
    }

    int tempSortVal = sortData[idxA];
    sortData[idxA] = sortData[idxB];
    sortData[idxB] = tempSortVal;

    Object tempAuxVal = auxData[idxA];
    auxData[idxA] = auxData[idxB];
    auxData[idxB] = tempAuxVal;
  }

  /**
   * In-place sorts two parallel arrays in the natural order of elements of the first array.
   *
   * @param sortData the first array, whose values will determine the final sorted order
   * @param auxData the second array, whose values will be rearranged in parallel with the first array
   */
  public static void sort(int[] sortData, boolean[] auxData) {
    quicksort(sortData, auxData, 0, sortData.length - 1);
  }

  /**
   * In-place sorts two parallel arrays in the natural order of elements of the first array.
   *
   * @param sortData the first array, whose values will determine the final sorted order
   * @param auxData the second array, whose values will be rearranged in parallel with the first array
   * @param left the starting index of the subarray to be sorted.  To sort the entire array, specify 0.
   * @param right the ending index, INCLUSIVE, of the subarray to be sorted.  To sort the entire array, specify
   *              sortData.length - 1
   */
  private static void quicksort(int[] sortData, boolean[] auxData, int left, int right) {
    if (right <= left) {
      return;
    }

    // These exchanges are here to reduce both the runtime and the
    // stack usage (level of recursion) in degenerate cases such as
    // when the input is sorted or nearly sorted.
    exchange(sortData, auxData, (left + right) / 2, right - 1);
    compareExchange(sortData, auxData, left, right - 1);
    compareExchange(sortData, auxData, left, right);
    compareExchange(sortData, auxData, right - 1, right);

    if (right - 1 <= left) {
      return;
    }

    int i = partition(sortData, auxData, left + 1, right - 1);

    quicksort(sortData, auxData, left, i - 1);
    quicksort(sortData, auxData, i + 1, right);
  }

  private static int partition(int[] sortData, boolean[] auxData, int left, int right) {
    int i = left - 1;
    int j = right;

    int sortVal = sortData[right];

    while (true) {
      while (sortData[++i] < sortVal) {
        // this space intentionally left blank
      }

      while (sortVal < sortData[--j]) {
        if (j == left) {
          break;
        }
      }

      if (i >= j) {
        break;
      }

      exchange(sortData, auxData, i, j);
    }

    exchange(sortData, auxData, i, right);
    return i;
  }

  private static void compareExchange(int[] sortData, boolean[] auxData, int idxA, int idxB) {
    if (sortData[idxB] < sortData[idxA]) {
      exchange(sortData, auxData, idxA, idxB);
    }
  }

  private static void exchange(int[] sortData, boolean[] auxData, int idxA, int idxB) {
    if (idxA == idxB) {
      return;
    }

    int tempSortVal = sortData[idxA];
    sortData[idxA] = sortData[idxB];
    sortData[idxB] = tempSortVal;

    boolean tempAuxVal = auxData[idxA];
    auxData[idxA] = auxData[idxB];
    auxData[idxB] = tempAuxVal;
  }

  /**
   * Converts an array of ints to an array of bytes.
   *
   * This cast is "lossy" and may lose information.
   *
   * @param arr the array to convert
   * @return an array of bytes cast from the provided array of ints
   */
  public static byte[] toBytesLossy(int[] arr) {
    byte[] res = new byte[arr.length];
    for (int i = 0; i < res.length; i++) {
      res[i] = (byte) arr[i];
    }

    return res;
  }

  /**
   * Converts an array of ints to an array of bytes, throwing an exception if the
   * converted values do not <i>exactly</i> match the originals (as determined by {@code !=}.)
   *
   * @param arr the array to convert
   * @return an array of bytes cast from the provided array of ints
   * @throws ArithmeticException if the array cannot be losslessly converted
   */
  public static byte[] toBytesExact(int[] arr) {
    byte[] res = toBytesLossy(arr);
    for (int i = 0; i < res.length; i++) {
      if (res[i] != arr[i]) {
        throw new ArithmeticException("Cannot losslessly convert provided int[] to byte[] at index " + i + "; "
            + res[i] + " != " + arr[i]);
      }
    }

    return res;
  }

  /**
   * In-place sorts two parallel arrays in the natural order of elements of the first array.
   *
   * @param sortData the first array, whose values will determine the final sorted order
   * @param auxData the second array, whose values will be rearranged in parallel with the first array
   */
  public static void sort(int[] sortData, byte[] auxData) {
    quicksort(sortData, auxData, 0, sortData.length - 1);
  }

  /**
   * In-place sorts two parallel arrays in the natural order of elements of the first array.
   *
   * @param sortData the first array, whose values will determine the final sorted order
   * @param auxData the second array, whose values will be rearranged in parallel with the first array
   * @param left the starting index of the subarray to be sorted.  To sort the entire array, specify 0.
   * @param right the ending index, INCLUSIVE, of the subarray to be sorted.  To sort the entire array, specify
   *              sortData.length - 1
   */
  private static void quicksort(int[] sortData, byte[] auxData, int left, int right) {
    if (right <= left) {
      return;
    }

    // These exchanges are here to reduce both the runtime and the
    // stack usage (level of recursion) in degenerate cases such as
    // when the input is sorted or nearly sorted.
    exchange(sortData, auxData, (left + right) / 2, right - 1);
    compareExchange(sortData, auxData, left, right - 1);
    compareExchange(sortData, auxData, left, right);
    compareExchange(sortData, auxData, right - 1, right);

    if (right - 1 <= left) {
      return;
    }

    int i = partition(sortData, auxData, left + 1, right - 1);

    quicksort(sortData, auxData, left, i - 1);
    quicksort(sortData, auxData, i + 1, right);
  }

  private static int partition(int[] sortData, byte[] auxData, int left, int right) {
    int i = left - 1;
    int j = right;

    int sortVal = sortData[right];

    while (true) {
      while (sortData[++i] < sortVal) {
        // this space intentionally left blank
      }

      while (sortVal < sortData[--j]) {
        if (j == left) {
          break;
        }
      }

      if (i >= j) {
        break;
      }

      exchange(sortData, auxData, i, j);
    }

    exchange(sortData, auxData, i, right);
    return i;
  }

  private static void compareExchange(int[] sortData, byte[] auxData, int idxA, int idxB) {
    if (sortData[idxB] < sortData[idxA]) {
      exchange(sortData, auxData, idxA, idxB);
    }
  }

  private static void exchange(int[] sortData, byte[] auxData, int idxA, int idxB) {
    if (idxA == idxB) {
      return;
    }

    int tempSortVal = sortData[idxA];
    sortData[idxA] = sortData[idxB];
    sortData[idxB] = tempSortVal;

    byte tempAuxVal = auxData[idxA];
    auxData[idxA] = auxData[idxB];
    auxData[idxB] = tempAuxVal;
  }

  /**
   * Converts an array of ints to an array of chars.
   *
   * This cast is "lossy" and may lose information.
   *
   * @param arr the array to convert
   * @return an array of chars cast from the provided array of ints
   */
  public static char[] toCharactersLossy(int[] arr) {
    char[] res = new char[arr.length];
    for (int i = 0; i < res.length; i++) {
      res[i] = (char) arr[i];
    }

    return res;
  }

  /**
   * Converts an array of ints to an array of chars, throwing an exception if the
   * converted values do not <i>exactly</i> match the originals (as determined by {@code !=}.)
   *
   * @param arr the array to convert
   * @return an array of chars cast from the provided array of ints
   * @throws ArithmeticException if the array cannot be losslessly converted
   */
  public static char[] toCharactersExact(int[] arr) {
    char[] res = toCharactersLossy(arr);
    for (int i = 0; i < res.length; i++) {
      if (res[i] != arr[i]) {
        throw new ArithmeticException("Cannot losslessly convert provided int[] to char[] at index " + i + "; "
            + res[i] + " != " + arr[i]);
      }
    }

    return res;
  }

  /**
   * In-place sorts two parallel arrays in the natural order of elements of the first array.
   *
   * @param sortData the first array, whose values will determine the final sorted order
   * @param auxData the second array, whose values will be rearranged in parallel with the first array
   */
  public static void sort(int[] sortData, char[] auxData) {
    quicksort(sortData, auxData, 0, sortData.length - 1);
  }

  /**
   * In-place sorts two parallel arrays in the natural order of elements of the first array.
   *
   * @param sortData the first array, whose values will determine the final sorted order
   * @param auxData the second array, whose values will be rearranged in parallel with the first array
   * @param left the starting index of the subarray to be sorted.  To sort the entire array, specify 0.
   * @param right the ending index, INCLUSIVE, of the subarray to be sorted.  To sort the entire array, specify
   *              sortData.length - 1
   */
  private static void quicksort(int[] sortData, char[] auxData, int left, int right) {
    if (right <= left) {
      return;
    }

    // These exchanges are here to reduce both the runtime and the
    // stack usage (level of recursion) in degenerate cases such as
    // when the input is sorted or nearly sorted.
    exchange(sortData, auxData, (left + right) / 2, right - 1);
    compareExchange(sortData, auxData, left, right - 1);
    compareExchange(sortData, auxData, left, right);
    compareExchange(sortData, auxData, right - 1, right);

    if (right - 1 <= left) {
      return;
    }

    int i = partition(sortData, auxData, left + 1, right - 1);

    quicksort(sortData, auxData, left, i - 1);
    quicksort(sortData, auxData, i + 1, right);
  }

  private static int partition(int[] sortData, char[] auxData, int left, int right) {
    int i = left - 1;
    int j = right;

    int sortVal = sortData[right];

    while (true) {
      while (sortData[++i] < sortVal) {
        // this space intentionally left blank
      }

      while (sortVal < sortData[--j]) {
        if (j == left) {
          break;
        }
      }

      if (i >= j) {
        break;
      }

      exchange(sortData, auxData, i, j);
    }

    exchange(sortData, auxData, i, right);
    return i;
  }

  private static void compareExchange(int[] sortData, char[] auxData, int idxA, int idxB) {
    if (sortData[idxB] < sortData[idxA]) {
      exchange(sortData, auxData, idxA, idxB);
    }
  }

  private static void exchange(int[] sortData, char[] auxData, int idxA, int idxB) {
    if (idxA == idxB) {
      return;
    }

    int tempSortVal = sortData[idxA];
    sortData[idxA] = sortData[idxB];
    sortData[idxB] = tempSortVal;

    char tempAuxVal = auxData[idxA];
    auxData[idxA] = auxData[idxB];
    auxData[idxB] = tempAuxVal;
  }

  /**
   * Converts an array of ints to an array of shorts.
   *
   * This cast is "lossy" and may lose information.
   *
   * @param arr the array to convert
   * @return an array of shorts cast from the provided array of ints
   */
  public static short[] toShortsLossy(int[] arr) {
    short[] res = new short[arr.length];
    for (int i = 0; i < res.length; i++) {
      res[i] = (short) arr[i];
    }

    return res;
  }

  /**
   * Converts an array of ints to an array of shorts, throwing an exception if the
   * converted values do not <i>exactly</i> match the originals (as determined by {@code !=}.)
   *
   * @param arr the array to convert
   * @return an array of shorts cast from the provided array of ints
   * @throws ArithmeticException if the array cannot be losslessly converted
   */
  public static short[] toShortsExact(int[] arr) {
    short[] res = toShortsLossy(arr);
    for (int i = 0; i < res.length; i++) {
      if (res[i] != arr[i]) {
        throw new ArithmeticException("Cannot losslessly convert provided int[] to short[] at index " + i + "; "
            + res[i] + " != " + arr[i]);
      }
    }

    return res;
  }

  /**
   * In-place sorts two parallel arrays in the natural order of elements of the first array.
   *
   * @param sortData the first array, whose values will determine the final sorted order
   * @param auxData the second array, whose values will be rearranged in parallel with the first array
   */
  public static void sort(int[] sortData, short[] auxData) {
    quicksort(sortData, auxData, 0, sortData.length - 1);
  }

  /**
   * In-place sorts two parallel arrays in the natural order of elements of the first array.
   *
   * @param sortData the first array, whose values will determine the final sorted order
   * @param auxData the second array, whose values will be rearranged in parallel with the first array
   * @param left the starting index of the subarray to be sorted.  To sort the entire array, specify 0.
   * @param right the ending index, INCLUSIVE, of the subarray to be sorted.  To sort the entire array, specify
   *              sortData.length - 1
   */
  private static void quicksort(int[] sortData, short[] auxData, int left, int right) {
    if (right <= left) {
      return;
    }

    // These exchanges are here to reduce both the runtime and the
    // stack usage (level of recursion) in degenerate cases such as
    // when the input is sorted or nearly sorted.
    exchange(sortData, auxData, (left + right) / 2, right - 1);
    compareExchange(sortData, auxData, left, right - 1);
    compareExchange(sortData, auxData, left, right);
    compareExchange(sortData, auxData, right - 1, right);

    if (right - 1 <= left) {
      return;
    }

    int i = partition(sortData, auxData, left + 1, right - 1);

    quicksort(sortData, auxData, left, i - 1);
    quicksort(sortData, auxData, i + 1, right);
  }

  private static int partition(int[] sortData, short[] auxData, int left, int right) {
    int i = left - 1;
    int j = right;

    int sortVal = sortData[right];

    while (true) {
      while (sortData[++i] < sortVal) {
        // this space intentionally left blank
      }

      while (sortVal < sortData[--j]) {
        if (j == left) {
          break;
        }
      }

      if (i >= j) {
        break;
      }

      exchange(sortData, auxData, i, j);
    }

    exchange(sortData, auxData, i, right);
    return i;
  }

  private static void compareExchange(int[] sortData, short[] auxData, int idxA, int idxB) {
    if (sortData[idxB] < sortData[idxA]) {
      exchange(sortData, auxData, idxA, idxB);
    }
  }

  private static void exchange(int[] sortData, short[] auxData, int idxA, int idxB) {
    if (idxA == idxB) {
      return;
    }

    int tempSortVal = sortData[idxA];
    sortData[idxA] = sortData[idxB];
    sortData[idxB] = tempSortVal;

    short tempAuxVal = auxData[idxA];
    auxData[idxA] = auxData[idxB];
    auxData[idxB] = tempAuxVal;
  }

  /**
   * In-place sorts two parallel arrays in the natural order of elements of the first array.
   *
   * @param sortData the first array, whose values will determine the final sorted order
   * @param auxData the second array, whose values will be rearranged in parallel with the first array
   */
  public static void sort(int[] sortData, int[] auxData) {
    quicksort(sortData, auxData, 0, sortData.length - 1);
  }

  /**
   * In-place sorts two parallel arrays in the natural order of elements of the first array.
   *
   * @param sortData the first array, whose values will determine the final sorted order
   * @param auxData the second array, whose values will be rearranged in parallel with the first array
   * @param left the starting index of the subarray to be sorted.  To sort the entire array, specify 0.
   * @param right the ending index, INCLUSIVE, of the subarray to be sorted.  To sort the entire array, specify
   *              sortData.length - 1
   */
  private static void quicksort(int[] sortData, int[] auxData, int left, int right) {
    if (right <= left) {
      return;
    }

    // These exchanges are here to reduce both the runtime and the
    // stack usage (level of recursion) in degenerate cases such as
    // when the input is sorted or nearly sorted.
    exchange(sortData, auxData, (left + right) / 2, right - 1);
    compareExchange(sortData, auxData, left, right - 1);
    compareExchange(sortData, auxData, left, right);
    compareExchange(sortData, auxData, right - 1, right);

    if (right - 1 <= left) {
      return;
    }

    int i = partition(sortData, auxData, left + 1, right - 1);

    quicksort(sortData, auxData, left, i - 1);
    quicksort(sortData, auxData, i + 1, right);
  }

  private static int partition(int[] sortData, int[] auxData, int left, int right) {
    int i = left - 1;
    int j = right;

    int sortVal = sortData[right];

    while (true) {
      while (sortData[++i] < sortVal) {
        // this space intentionally left blank
      }

      while (sortVal < sortData[--j]) {
        if (j == left) {
          break;
        }
      }

      if (i >= j) {
        break;
      }

      exchange(sortData, auxData, i, j);
    }

    exchange(sortData, auxData, i, right);
    return i;
  }

  private static void compareExchange(int[] sortData, int[] auxData, int idxA, int idxB) {
    if (sortData[idxB] < sortData[idxA]) {
      exchange(sortData, auxData, idxA, idxB);
    }
  }

  private static void exchange(int[] sortData, int[] auxData, int idxA, int idxB) {
    if (idxA == idxB) {
      return;
    }

    int tempSortVal = sortData[idxA];
    sortData[idxA] = sortData[idxB];
    sortData[idxB] = tempSortVal;

    int tempAuxVal = auxData[idxA];
    auxData[idxA] = auxData[idxB];
    auxData[idxB] = tempAuxVal;
  }

  /**
   * Converts an array of ints to an array of longs.
   *
   * This cast is lossless (no loss of information).
   *
   * @param arr the array to convert
   * @return an array of longs cast from the provided array of ints
   */
  public static long[] toLongs(int[] arr) {
    long[] res = new long[arr.length];
    for (int i = 0; i < res.length; i++) {
      res[i] = arr[i];
    }

    return res;
  }

  /**
   * In-place sorts two parallel arrays in the natural order of elements of the first array.
   *
   * @param sortData the first array, whose values will determine the final sorted order
   * @param auxData the second array, whose values will be rearranged in parallel with the first array
   */
  public static void sort(int[] sortData, long[] auxData) {
    quicksort(sortData, auxData, 0, sortData.length - 1);
  }

  /**
   * In-place sorts two parallel arrays in the natural order of elements of the first array.
   *
   * @param sortData the first array, whose values will determine the final sorted order
   * @param auxData the second array, whose values will be rearranged in parallel with the first array
   * @param left the starting index of the subarray to be sorted.  To sort the entire array, specify 0.
   * @param right the ending index, INCLUSIVE, of the subarray to be sorted.  To sort the entire array, specify
   *              sortData.length - 1
   */
  private static void quicksort(int[] sortData, long[] auxData, int left, int right) {
    if (right <= left) {
      return;
    }

    // These exchanges are here to reduce both the runtime and the
    // stack usage (level of recursion) in degenerate cases such as
    // when the input is sorted or nearly sorted.
    exchange(sortData, auxData, (left + right) / 2, right - 1);
    compareExchange(sortData, auxData, left, right - 1);
    compareExchange(sortData, auxData, left, right);
    compareExchange(sortData, auxData, right - 1, right);

    if (right - 1 <= left) {
      return;
    }

    int i = partition(sortData, auxData, left + 1, right - 1);

    quicksort(sortData, auxData, left, i - 1);
    quicksort(sortData, auxData, i + 1, right);
  }

  private static int partition(int[] sortData, long[] auxData, int left, int right) {
    int i = left - 1;
    int j = right;

    int sortVal = sortData[right];

    while (true) {
      while (sortData[++i] < sortVal) {
        // this space intentionally left blank
      }

      while (sortVal < sortData[--j]) {
        if (j == left) {
          break;
        }
      }

      if (i >= j) {
        break;
      }

      exchange(sortData, auxData, i, j);
    }

    exchange(sortData, auxData, i, right);
    return i;
  }

  private static void compareExchange(int[] sortData, long[] auxData, int idxA, int idxB) {
    if (sortData[idxB] < sortData[idxA]) {
      exchange(sortData, auxData, idxA, idxB);
    }
  }

  private static void exchange(int[] sortData, long[] auxData, int idxA, int idxB) {
    if (idxA == idxB) {
      return;
    }

    int tempSortVal = sortData[idxA];
    sortData[idxA] = sortData[idxB];
    sortData[idxB] = tempSortVal;

    long tempAuxVal = auxData[idxA];
    auxData[idxA] = auxData[idxB];
    auxData[idxB] = tempAuxVal;
  }

  /**
   * Converts an array of ints to an array of floats.
   *
   * This cast is "lossy" and may lose information.
   *
   * @param arr the array to convert
   * @return an array of floats cast from the provided array of ints
   */
  public static float[] toFloatsLossy(int[] arr) {
    float[] res = new float[arr.length];
    for (int i = 0; i < res.length; i++) {
      res[i] = (float) arr[i];
    }

    return res;
  }

  /**
   * Converts an array of ints to an array of floats, throwing an exception if the
   * converted values do not <i>exactly</i> match the originals (as determined by {@code !=}.)
   *
   * @param arr the array to convert
   * @return an array of floats cast from the provided array of ints
   * @throws ArithmeticException if the array cannot be losslessly converted
   */
  public static float[] toFloatsExact(int[] arr) {
    float[] res = toFloatsLossy(arr);
    for (int i = 0; i < res.length; i++) {
      if (res[i] != arr[i]) {
        throw new ArithmeticException("Cannot losslessly convert provided int[] to float[] at index " + i + "; "
            + res[i] + " != " + arr[i]);
      }
    }

    return res;
  }

  /**
   * In-place sorts two parallel arrays in the natural order of elements of the first array.
   *
   * @param sortData the first array, whose values will determine the final sorted order
   * @param auxData the second array, whose values will be rearranged in parallel with the first array
   */
  public static void sort(int[] sortData, float[] auxData) {
    quicksort(sortData, auxData, 0, sortData.length - 1);
  }

  /**
   * In-place sorts two parallel arrays in the natural order of elements of the first array.
   *
   * @param sortData the first array, whose values will determine the final sorted order
   * @param auxData the second array, whose values will be rearranged in parallel with the first array
   * @param left the starting index of the subarray to be sorted.  To sort the entire array, specify 0.
   * @param right the ending index, INCLUSIVE, of the subarray to be sorted.  To sort the entire array, specify
   *              sortData.length - 1
   */
  private static void quicksort(int[] sortData, float[] auxData, int left, int right) {
    if (right <= left) {
      return;
    }

    // These exchanges are here to reduce both the runtime and the
    // stack usage (level of recursion) in degenerate cases such as
    // when the input is sorted or nearly sorted.
    exchange(sortData, auxData, (left + right) / 2, right - 1);
    compareExchange(sortData, auxData, left, right - 1);
    compareExchange(sortData, auxData, left, right);
    compareExchange(sortData, auxData, right - 1, right);

    if (right - 1 <= left) {
      return;
    }

    int i = partition(sortData, auxData, left + 1, right - 1);

    quicksort(sortData, auxData, left, i - 1);
    quicksort(sortData, auxData, i + 1, right);
  }

  private static int partition(int[] sortData, float[] auxData, int left, int right) {
    int i = left - 1;
    int j = right;

    int sortVal = sortData[right];

    while (true) {
      while (sortData[++i] < sortVal) {
        // this space intentionally left blank
      }

      while (sortVal < sortData[--j]) {
        if (j == left) {
          break;
        }
      }

      if (i >= j) {
        break;
      }

      exchange(sortData, auxData, i, j);
    }

    exchange(sortData, auxData, i, right);
    return i;
  }

  private static void compareExchange(int[] sortData, float[] auxData, int idxA, int idxB) {
    if (sortData[idxB] < sortData[idxA]) {
      exchange(sortData, auxData, idxA, idxB);
    }
  }

  private static void exchange(int[] sortData, float[] auxData, int idxA, int idxB) {
    if (idxA == idxB) {
      return;
    }

    int tempSortVal = sortData[idxA];
    sortData[idxA] = sortData[idxB];
    sortData[idxB] = tempSortVal;

    float tempAuxVal = auxData[idxA];
    auxData[idxA] = auxData[idxB];
    auxData[idxB] = tempAuxVal;
  }

  /**
   * Converts an array of ints to an array of doubles.
   *
   * This cast is lossless (no loss of information).
   *
   * @param arr the array to convert
   * @return an array of doubles cast from the provided array of ints
   */
  public static double[] toDoubles(int[] arr) {
    double[] res = new double[arr.length];
    for (int i = 0; i < res.length; i++) {
      res[i] = arr[i];
    }

    return res;
  }

  /**
   * In-place sorts two parallel arrays in the natural order of elements of the first array.
   *
   * @param sortData the first array, whose values will determine the final sorted order
   * @param auxData the second array, whose values will be rearranged in parallel with the first array
   */
  public static void sort(int[] sortData, double[] auxData) {
    quicksort(sortData, auxData, 0, sortData.length - 1);
  }

  /**
   * In-place sorts two parallel arrays in the natural order of elements of the first array.
   *
   * @param sortData the first array, whose values will determine the final sorted order
   * @param auxData the second array, whose values will be rearranged in parallel with the first array
   * @param left the starting index of the subarray to be sorted.  To sort the entire array, specify 0.
   * @param right the ending index, INCLUSIVE, of the subarray to be sorted.  To sort the entire array, specify
   *              sortData.length - 1
   */
  private static void quicksort(int[] sortData, double[] auxData, int left, int right) {
    if (right <= left) {
      return;
    }

    // These exchanges are here to reduce both the runtime and the
    // stack usage (level of recursion) in degenerate cases such as
    // when the input is sorted or nearly sorted.
    exchange(sortData, auxData, (left + right) / 2, right - 1);
    compareExchange(sortData, auxData, left, right - 1);
    compareExchange(sortData, auxData, left, right);
    compareExchange(sortData, auxData, right - 1, right);

    if (right - 1 <= left) {
      return;
    }

    int i = partition(sortData, auxData, left + 1, right - 1);

    quicksort(sortData, auxData, left, i - 1);
    quicksort(sortData, auxData, i + 1, right);
  }

  private static int partition(int[] sortData, double[] auxData, int left, int right) {
    int i = left - 1;
    int j = right;

    int sortVal = sortData[right];

    while (true) {
      while (sortData[++i] < sortVal) {
        // this space intentionally left blank
      }

      while (sortVal < sortData[--j]) {
        if (j == left) {
          break;
        }
      }

      if (i >= j) {
        break;
      }

      exchange(sortData, auxData, i, j);
    }

    exchange(sortData, auxData, i, right);
    return i;
  }

  private static void compareExchange(int[] sortData, double[] auxData, int idxA, int idxB) {
    if (sortData[idxB] < sortData[idxA]) {
      exchange(sortData, auxData, idxA, idxB);
    }
  }

  private static void exchange(int[] sortData, double[] auxData, int idxA, int idxB) {
    if (idxA == idxB) {
      return;
    }

    int tempSortVal = sortData[idxA];
    sortData[idxA] = sortData[idxB];
    sortData[idxB] = tempSortVal;

    double tempAuxVal = auxData[idxA];
    auxData[idxA] = auxData[idxB];
    auxData[idxB] = tempAuxVal;
  }

  // ---------------- Begin methods for Longs ----------------

  /**
   * An instance of an empty long array.  Using this instance rather than creating a new array each time an empty
   * array is needed avoids an unnecessary object creation.
   */
  public static final long[] EMPTY_LONG_ARRAY = new long[0];

  /**
   * Concatenates one or more arrays.
   *
   * @param arrays one or more arrays to concatenate
   * @return the concatenated array
   */
  public static long[] concat(long[]... arrays) {
    int size = 0;
    for (long[] arr : arrays) {
      size += arr.length;
    }

    long[] res = new long[size];

    int offset = 0;
    for (long[] arr : arrays) {
      System.arraycopy(arr, 0, res, offset, arr.length);
      offset += arr.length;
    }

    return res;
  }

  /**
   * Wraps an array as a {@link java.util.List} just as {@link Arrays#asList(Object[])} does for reference types.
   *
   * However, unlike the list returned by {@link Arrays#asList(Object[])}, the returned list may still grow (or shrink),
   * in which case its underlying array may cease to be the {@code wrapped} array (such that changes in one will cease
   * to induce changes in the other).
   *
   * @param wrapped the array to wrap; until the list size changes, it is guaranteed that changes to the elements of
   *                the array will affect the list wrapper, and vice-versa
   * @return a list that wraps the provided array
   */
  public static LongArrayList asList(long... wrapped) {
    return LongArrayList.wrap(wrapped);
  }

  /**
   * Transposes a "matrix" comprised of an array of arrays; each element array[i][j] will be copied to transposed[j][i].
   *
   * If the original array of arrays is "jagged" (with subarray "rows" of differing lengths), the width of the matrix
   * will be taken as the longest of its rows and any "missing" elements in shorter rows will treated as if they were
   * 0.
   *
   * @param matrix the array of arrays to transpose; the subarray "rows" do not need to be of uniform length
   * @return a new, transposed array of arrays such that each element {@code matrix[i][j]} will be copied to
   *         {@code transposed[j][i]}
   */
  public static long[][] transpose(long[][] matrix) {
    // find the longest row in the matrix (its number of columns)--this will be our result matrix's width
    int newHeight = 0;
    for (long[] row : matrix) {
      newHeight = Math.max(newHeight, row.length);
    }

    long[][] transposed = new long[newHeight][matrix.length];
    for (int i = 0; i < matrix.length; i++) {
      long[] row = matrix[i];
      for (int j = 0; j < row.length; j++) {
        transposed[j][i] = row[j];
      }
    }

    return transposed;
  }

  /**
   * Given a sorted array (either least to greatest or greatest to least), places all unique elements at the start of
   * the array (maintaining the original sort order and overwriting their original values) and returns the number of
   * unique elements.
   *
   * For example, if this method is called on the array [1, 2, 2, 2, 3, 3, 4], it will return 4 (the number of unique
   * elements) and the array will be modified to [1, 2, 3, 4, 3, 3, 4].  Note that only the first 4 elements of this
   * array have been changed.
   *
   * The time complexity of this method is O(n), where n is the length of the input array.
   *
   * @param array the sorted array to deduplicate
   * @return the number of unique elements in the provided array
   */
  public static int deduplicateSortedArray(long[] array) {
    // handle empty-array edge case
    if (array.length == 0) {
      return 0;
    }

    // look for duplicates and shift elements up to overwrite any that are found
    int shift = 0;
    for (int i = 1; i < array.length; i++) {
      if (array[i] == array[i - 1]) {
        shift++;
      } else {
        array[i - shift] = array[i]; // if shift == 0 this is a noop
      }
    }

    return array.length - shift;
  }

  /**
   * Reverses the order of the elements of the array.
   *
   * @param array the array to be reversed
   */
  public static void reverse(long[] array) {
    for (int i = 0; i < array.length / 2; i++) {
      long val = array[array.length - i - 1];
      array[array.length - i - 1] = array[i];
      array[i] = val;
    }
  }

  /**
   * Returns true if the elements of the array are monotonically increasing (i.e. in natural order)
   *
   * @param array the array to be checked
   * @return true if the array is monotonically increasing, false otherwise
   */
  public static boolean isMonotonicallyIncreasing(long[] array) {
    if (array.length > 0) {
      long previousElement = array[0];
      for (int i = 1; i < array.length; i++) {
        if (array[i] < previousElement) {
          return false;
        }
        previousElement = array[i];
      }
    }

    return true;
  }

  /**
   * Returns true if the elements of the array are monotonically decreasing (i.e. in reverse natural order)
   *
   * @param array the array to be checked
   * @return true if the array is monotonically decreasing, false otherwise
   */
  public static boolean isMonotonicallyDecreasing(long[] array) {
    if (array.length > 0) {
      long previousElement = array[0];
      for (int i = 1; i < array.length; i++) {
        if (array[i] > previousElement) {
          return false;
        }
        previousElement = array[i];
      }
    }

    return true;
  }

  /**
   * Converts an {@link Iterable} of {@link Number}s to an array of longs.
   *
   * This method is "lossy" because it does not know, a priori, the concrete types of the providers {@link Number}s,
   * and some information may be lost.  {@link Number#longValue()} is used to obtain the array values.
   *
   * A run-time exception will be thrown if the quantity of elements in the provided {@link Iterable} exceeds the
   * maximum array length on this JVM.
   *
   * @param numbers the numbers that should be converted into an array of longs
   * @return an array of longs, possibly subject to truncation or rounding
   */
  public static long[] toLongsLossy(Iterable<? extends Number> numbers) {
    long[] res = new long[Math.toIntExact(Iterables.size64(numbers))];

    java.util.Iterator<? extends Number> iterator = numbers.iterator();
    try {
      for (int i = 0; i < res.length; i++) {
        res[i] = iterator.next().longValue();
      }
      return res;
    } finally {
      // properly close AutoCloseable iterators
      Closeables.tryClose(iterator);
    }
  }

  /**
   * In-place sorts two parallel arrays in the natural order of elements of the first array.
   *
   * @param sortData the first array, whose values will determine the final sorted order
   * @param auxData the second array, whose values will be rearranged in parallel with the first array
   */
  public static void sort(long[] sortData, Object[] auxData) {
    quicksort(sortData, auxData, 0, sortData.length - 1);
  }

  /**
   * In-place sorts two parallel arrays in the natural order of elements of the first array.
   *
   * @param sortData the first array, whose values will determine the final sorted order
   * @param auxData the second array, whose values will be rearranged in parallel with the first array
   * @param left the starting index of the subarray to be sorted.  To sort the entire array, specify 0.
   * @param right the ending index, INCLUSIVE, of the subarray to be sorted.  To sort the entire array, specify
   *              sortData.length - 1
   */
  private static void quicksort(long[] sortData, Object[] auxData, int left, int right) {
    if (right <= left) {
      return;
    }

    // These exchanges are here to reduce both the runtime and the
    // stack usage (level of recursion) in degenerate cases such as
    // when the input is sorted or nearly sorted.
    exchange(sortData, auxData, (left + right) / 2, right - 1);
    compareExchange(sortData, auxData, left, right - 1);
    compareExchange(sortData, auxData, left, right);
    compareExchange(sortData, auxData, right - 1, right);

    if (right - 1 <= left) {
      return;
    }

    int i = partition(sortData, auxData, left + 1, right - 1);

    quicksort(sortData, auxData, left, i - 1);
    quicksort(sortData, auxData, i + 1, right);
  }

  private static int partition(long[] sortData, Object[] auxData, int left, int right) {
    int i = left - 1;
    int j = right;

    long sortVal = sortData[right];

    while (true) {
      while (sortData[++i] < sortVal) {
        // this space intentionally left blank
      }

      while (sortVal < sortData[--j]) {
        if (j == left) {
          break;
        }
      }

      if (i >= j) {
        break;
      }

      exchange(sortData, auxData, i, j);
    }

    exchange(sortData, auxData, i, right);
    return i;
  }

  private static void compareExchange(long[] sortData, Object[] auxData, int idxA, int idxB) {
    if (sortData[idxB] < sortData[idxA]) {
      exchange(sortData, auxData, idxA, idxB);
    }
  }

  private static void exchange(long[] sortData, Object[] auxData, int idxA, int idxB) {
    if (idxA == idxB) {
      return;
    }

    long tempSortVal = sortData[idxA];
    sortData[idxA] = sortData[idxB];
    sortData[idxB] = tempSortVal;

    Object tempAuxVal = auxData[idxA];
    auxData[idxA] = auxData[idxB];
    auxData[idxB] = tempAuxVal;
  }

  /**
   * In-place sorts two parallel arrays in the natural order of elements of the first array.
   *
   * @param sortData the first array, whose values will determine the final sorted order
   * @param auxData the second array, whose values will be rearranged in parallel with the first array
   */
  public static void sort(long[] sortData, boolean[] auxData) {
    quicksort(sortData, auxData, 0, sortData.length - 1);
  }

  /**
   * In-place sorts two parallel arrays in the natural order of elements of the first array.
   *
   * @param sortData the first array, whose values will determine the final sorted order
   * @param auxData the second array, whose values will be rearranged in parallel with the first array
   * @param left the starting index of the subarray to be sorted.  To sort the entire array, specify 0.
   * @param right the ending index, INCLUSIVE, of the subarray to be sorted.  To sort the entire array, specify
   *              sortData.length - 1
   */
  private static void quicksort(long[] sortData, boolean[] auxData, int left, int right) {
    if (right <= left) {
      return;
    }

    // These exchanges are here to reduce both the runtime and the
    // stack usage (level of recursion) in degenerate cases such as
    // when the input is sorted or nearly sorted.
    exchange(sortData, auxData, (left + right) / 2, right - 1);
    compareExchange(sortData, auxData, left, right - 1);
    compareExchange(sortData, auxData, left, right);
    compareExchange(sortData, auxData, right - 1, right);

    if (right - 1 <= left) {
      return;
    }

    int i = partition(sortData, auxData, left + 1, right - 1);

    quicksort(sortData, auxData, left, i - 1);
    quicksort(sortData, auxData, i + 1, right);
  }

  private static int partition(long[] sortData, boolean[] auxData, int left, int right) {
    int i = left - 1;
    int j = right;

    long sortVal = sortData[right];

    while (true) {
      while (sortData[++i] < sortVal) {
        // this space intentionally left blank
      }

      while (sortVal < sortData[--j]) {
        if (j == left) {
          break;
        }
      }

      if (i >= j) {
        break;
      }

      exchange(sortData, auxData, i, j);
    }

    exchange(sortData, auxData, i, right);
    return i;
  }

  private static void compareExchange(long[] sortData, boolean[] auxData, int idxA, int idxB) {
    if (sortData[idxB] < sortData[idxA]) {
      exchange(sortData, auxData, idxA, idxB);
    }
  }

  private static void exchange(long[] sortData, boolean[] auxData, int idxA, int idxB) {
    if (idxA == idxB) {
      return;
    }

    long tempSortVal = sortData[idxA];
    sortData[idxA] = sortData[idxB];
    sortData[idxB] = tempSortVal;

    boolean tempAuxVal = auxData[idxA];
    auxData[idxA] = auxData[idxB];
    auxData[idxB] = tempAuxVal;
  }

  /**
   * Converts an array of longs to an array of bytes.
   *
   * This cast is "lossy" and may lose information.
   *
   * @param arr the array to convert
   * @return an array of bytes cast from the provided array of longs
   */
  public static byte[] toBytesLossy(long[] arr) {
    byte[] res = new byte[arr.length];
    for (int i = 0; i < res.length; i++) {
      res[i] = (byte) arr[i];
    }

    return res;
  }

  /**
   * Converts an array of longs to an array of bytes, throwing an exception if the
   * converted values do not <i>exactly</i> match the originals (as determined by {@code !=}.)
   *
   * @param arr the array to convert
   * @return an array of bytes cast from the provided array of longs
   * @throws ArithmeticException if the array cannot be losslessly converted
   */
  public static byte[] toBytesExact(long[] arr) {
    byte[] res = toBytesLossy(arr);
    for (int i = 0; i < res.length; i++) {
      if (res[i] != arr[i]) {
        throw new ArithmeticException("Cannot losslessly convert provided long[] to byte[] at index " + i + "; "
            + res[i] + " != " + arr[i]);
      }
    }

    return res;
  }

  /**
   * In-place sorts two parallel arrays in the natural order of elements of the first array.
   *
   * @param sortData the first array, whose values will determine the final sorted order
   * @param auxData the second array, whose values will be rearranged in parallel with the first array
   */
  public static void sort(long[] sortData, byte[] auxData) {
    quicksort(sortData, auxData, 0, sortData.length - 1);
  }

  /**
   * In-place sorts two parallel arrays in the natural order of elements of the first array.
   *
   * @param sortData the first array, whose values will determine the final sorted order
   * @param auxData the second array, whose values will be rearranged in parallel with the first array
   * @param left the starting index of the subarray to be sorted.  To sort the entire array, specify 0.
   * @param right the ending index, INCLUSIVE, of the subarray to be sorted.  To sort the entire array, specify
   *              sortData.length - 1
   */
  private static void quicksort(long[] sortData, byte[] auxData, int left, int right) {
    if (right <= left) {
      return;
    }

    // These exchanges are here to reduce both the runtime and the
    // stack usage (level of recursion) in degenerate cases such as
    // when the input is sorted or nearly sorted.
    exchange(sortData, auxData, (left + right) / 2, right - 1);
    compareExchange(sortData, auxData, left, right - 1);
    compareExchange(sortData, auxData, left, right);
    compareExchange(sortData, auxData, right - 1, right);

    if (right - 1 <= left) {
      return;
    }

    int i = partition(sortData, auxData, left + 1, right - 1);

    quicksort(sortData, auxData, left, i - 1);
    quicksort(sortData, auxData, i + 1, right);
  }

  private static int partition(long[] sortData, byte[] auxData, int left, int right) {
    int i = left - 1;
    int j = right;

    long sortVal = sortData[right];

    while (true) {
      while (sortData[++i] < sortVal) {
        // this space intentionally left blank
      }

      while (sortVal < sortData[--j]) {
        if (j == left) {
          break;
        }
      }

      if (i >= j) {
        break;
      }

      exchange(sortData, auxData, i, j);
    }

    exchange(sortData, auxData, i, right);
    return i;
  }

  private static void compareExchange(long[] sortData, byte[] auxData, int idxA, int idxB) {
    if (sortData[idxB] < sortData[idxA]) {
      exchange(sortData, auxData, idxA, idxB);
    }
  }

  private static void exchange(long[] sortData, byte[] auxData, int idxA, int idxB) {
    if (idxA == idxB) {
      return;
    }

    long tempSortVal = sortData[idxA];
    sortData[idxA] = sortData[idxB];
    sortData[idxB] = tempSortVal;

    byte tempAuxVal = auxData[idxA];
    auxData[idxA] = auxData[idxB];
    auxData[idxB] = tempAuxVal;
  }

  /**
   * Converts an array of longs to an array of chars.
   *
   * This cast is "lossy" and may lose information.
   *
   * @param arr the array to convert
   * @return an array of chars cast from the provided array of longs
   */
  public static char[] toCharactersLossy(long[] arr) {
    char[] res = new char[arr.length];
    for (int i = 0; i < res.length; i++) {
      res[i] = (char) arr[i];
    }

    return res;
  }

  /**
   * Converts an array of longs to an array of chars, throwing an exception if the
   * converted values do not <i>exactly</i> match the originals (as determined by {@code !=}.)
   *
   * @param arr the array to convert
   * @return an array of chars cast from the provided array of longs
   * @throws ArithmeticException if the array cannot be losslessly converted
   */
  public static char[] toCharactersExact(long[] arr) {
    char[] res = toCharactersLossy(arr);
    for (int i = 0; i < res.length; i++) {
      if (res[i] != arr[i]) {
        throw new ArithmeticException("Cannot losslessly convert provided long[] to char[] at index " + i + "; "
            + res[i] + " != " + arr[i]);
      }
    }

    return res;
  }

  /**
   * In-place sorts two parallel arrays in the natural order of elements of the first array.
   *
   * @param sortData the first array, whose values will determine the final sorted order
   * @param auxData the second array, whose values will be rearranged in parallel with the first array
   */
  public static void sort(long[] sortData, char[] auxData) {
    quicksort(sortData, auxData, 0, sortData.length - 1);
  }

  /**
   * In-place sorts two parallel arrays in the natural order of elements of the first array.
   *
   * @param sortData the first array, whose values will determine the final sorted order
   * @param auxData the second array, whose values will be rearranged in parallel with the first array
   * @param left the starting index of the subarray to be sorted.  To sort the entire array, specify 0.
   * @param right the ending index, INCLUSIVE, of the subarray to be sorted.  To sort the entire array, specify
   *              sortData.length - 1
   */
  private static void quicksort(long[] sortData, char[] auxData, int left, int right) {
    if (right <= left) {
      return;
    }

    // These exchanges are here to reduce both the runtime and the
    // stack usage (level of recursion) in degenerate cases such as
    // when the input is sorted or nearly sorted.
    exchange(sortData, auxData, (left + right) / 2, right - 1);
    compareExchange(sortData, auxData, left, right - 1);
    compareExchange(sortData, auxData, left, right);
    compareExchange(sortData, auxData, right - 1, right);

    if (right - 1 <= left) {
      return;
    }

    int i = partition(sortData, auxData, left + 1, right - 1);

    quicksort(sortData, auxData, left, i - 1);
    quicksort(sortData, auxData, i + 1, right);
  }

  private static int partition(long[] sortData, char[] auxData, int left, int right) {
    int i = left - 1;
    int j = right;

    long sortVal = sortData[right];

    while (true) {
      while (sortData[++i] < sortVal) {
        // this space intentionally left blank
      }

      while (sortVal < sortData[--j]) {
        if (j == left) {
          break;
        }
      }

      if (i >= j) {
        break;
      }

      exchange(sortData, auxData, i, j);
    }

    exchange(sortData, auxData, i, right);
    return i;
  }

  private static void compareExchange(long[] sortData, char[] auxData, int idxA, int idxB) {
    if (sortData[idxB] < sortData[idxA]) {
      exchange(sortData, auxData, idxA, idxB);
    }
  }

  private static void exchange(long[] sortData, char[] auxData, int idxA, int idxB) {
    if (idxA == idxB) {
      return;
    }

    long tempSortVal = sortData[idxA];
    sortData[idxA] = sortData[idxB];
    sortData[idxB] = tempSortVal;

    char tempAuxVal = auxData[idxA];
    auxData[idxA] = auxData[idxB];
    auxData[idxB] = tempAuxVal;
  }

  /**
   * Converts an array of longs to an array of shorts.
   *
   * This cast is "lossy" and may lose information.
   *
   * @param arr the array to convert
   * @return an array of shorts cast from the provided array of longs
   */
  public static short[] toShortsLossy(long[] arr) {
    short[] res = new short[arr.length];
    for (int i = 0; i < res.length; i++) {
      res[i] = (short) arr[i];
    }

    return res;
  }

  /**
   * Converts an array of longs to an array of shorts, throwing an exception if the
   * converted values do not <i>exactly</i> match the originals (as determined by {@code !=}.)
   *
   * @param arr the array to convert
   * @return an array of shorts cast from the provided array of longs
   * @throws ArithmeticException if the array cannot be losslessly converted
   */
  public static short[] toShortsExact(long[] arr) {
    short[] res = toShortsLossy(arr);
    for (int i = 0; i < res.length; i++) {
      if (res[i] != arr[i]) {
        throw new ArithmeticException("Cannot losslessly convert provided long[] to short[] at index " + i + "; "
            + res[i] + " != " + arr[i]);
      }
    }

    return res;
  }

  /**
   * In-place sorts two parallel arrays in the natural order of elements of the first array.
   *
   * @param sortData the first array, whose values will determine the final sorted order
   * @param auxData the second array, whose values will be rearranged in parallel with the first array
   */
  public static void sort(long[] sortData, short[] auxData) {
    quicksort(sortData, auxData, 0, sortData.length - 1);
  }

  /**
   * In-place sorts two parallel arrays in the natural order of elements of the first array.
   *
   * @param sortData the first array, whose values will determine the final sorted order
   * @param auxData the second array, whose values will be rearranged in parallel with the first array
   * @param left the starting index of the subarray to be sorted.  To sort the entire array, specify 0.
   * @param right the ending index, INCLUSIVE, of the subarray to be sorted.  To sort the entire array, specify
   *              sortData.length - 1
   */
  private static void quicksort(long[] sortData, short[] auxData, int left, int right) {
    if (right <= left) {
      return;
    }

    // These exchanges are here to reduce both the runtime and the
    // stack usage (level of recursion) in degenerate cases such as
    // when the input is sorted or nearly sorted.
    exchange(sortData, auxData, (left + right) / 2, right - 1);
    compareExchange(sortData, auxData, left, right - 1);
    compareExchange(sortData, auxData, left, right);
    compareExchange(sortData, auxData, right - 1, right);

    if (right - 1 <= left) {
      return;
    }

    int i = partition(sortData, auxData, left + 1, right - 1);

    quicksort(sortData, auxData, left, i - 1);
    quicksort(sortData, auxData, i + 1, right);
  }

  private static int partition(long[] sortData, short[] auxData, int left, int right) {
    int i = left - 1;
    int j = right;

    long sortVal = sortData[right];

    while (true) {
      while (sortData[++i] < sortVal) {
        // this space intentionally left blank
      }

      while (sortVal < sortData[--j]) {
        if (j == left) {
          break;
        }
      }

      if (i >= j) {
        break;
      }

      exchange(sortData, auxData, i, j);
    }

    exchange(sortData, auxData, i, right);
    return i;
  }

  private static void compareExchange(long[] sortData, short[] auxData, int idxA, int idxB) {
    if (sortData[idxB] < sortData[idxA]) {
      exchange(sortData, auxData, idxA, idxB);
    }
  }

  private static void exchange(long[] sortData, short[] auxData, int idxA, int idxB) {
    if (idxA == idxB) {
      return;
    }

    long tempSortVal = sortData[idxA];
    sortData[idxA] = sortData[idxB];
    sortData[idxB] = tempSortVal;

    short tempAuxVal = auxData[idxA];
    auxData[idxA] = auxData[idxB];
    auxData[idxB] = tempAuxVal;
  }

  /**
   * Converts an array of longs to an array of ints.
   *
   * This cast is "lossy" and may lose information.
   *
   * @param arr the array to convert
   * @return an array of ints cast from the provided array of longs
   */
  public static int[] toIntegersLossy(long[] arr) {
    int[] res = new int[arr.length];
    for (int i = 0; i < res.length; i++) {
      res[i] = (int) arr[i];
    }

    return res;
  }

  /**
   * Converts an array of longs to an array of ints, throwing an exception if the
   * converted values do not <i>exactly</i> match the originals (as determined by {@code !=}.)
   *
   * @param arr the array to convert
   * @return an array of ints cast from the provided array of longs
   * @throws ArithmeticException if the array cannot be losslessly converted
   */
  public static int[] toIntegersExact(long[] arr) {
    int[] res = toIntegersLossy(arr);
    for (int i = 0; i < res.length; i++) {
      if (res[i] != arr[i]) {
        throw new ArithmeticException("Cannot losslessly convert provided long[] to int[] at index " + i + "; "
            + res[i] + " != " + arr[i]);
      }
    }

    return res;
  }

  /**
   * In-place sorts two parallel arrays in the natural order of elements of the first array.
   *
   * @param sortData the first array, whose values will determine the final sorted order
   * @param auxData the second array, whose values will be rearranged in parallel with the first array
   */
  public static void sort(long[] sortData, int[] auxData) {
    quicksort(sortData, auxData, 0, sortData.length - 1);
  }

  /**
   * In-place sorts two parallel arrays in the natural order of elements of the first array.
   *
   * @param sortData the first array, whose values will determine the final sorted order
   * @param auxData the second array, whose values will be rearranged in parallel with the first array
   * @param left the starting index of the subarray to be sorted.  To sort the entire array, specify 0.
   * @param right the ending index, INCLUSIVE, of the subarray to be sorted.  To sort the entire array, specify
   *              sortData.length - 1
   */
  private static void quicksort(long[] sortData, int[] auxData, int left, int right) {
    if (right <= left) {
      return;
    }

    // These exchanges are here to reduce both the runtime and the
    // stack usage (level of recursion) in degenerate cases such as
    // when the input is sorted or nearly sorted.
    exchange(sortData, auxData, (left + right) / 2, right - 1);
    compareExchange(sortData, auxData, left, right - 1);
    compareExchange(sortData, auxData, left, right);
    compareExchange(sortData, auxData, right - 1, right);

    if (right - 1 <= left) {
      return;
    }

    int i = partition(sortData, auxData, left + 1, right - 1);

    quicksort(sortData, auxData, left, i - 1);
    quicksort(sortData, auxData, i + 1, right);
  }

  private static int partition(long[] sortData, int[] auxData, int left, int right) {
    int i = left - 1;
    int j = right;

    long sortVal = sortData[right];

    while (true) {
      while (sortData[++i] < sortVal) {
        // this space intentionally left blank
      }

      while (sortVal < sortData[--j]) {
        if (j == left) {
          break;
        }
      }

      if (i >= j) {
        break;
      }

      exchange(sortData, auxData, i, j);
    }

    exchange(sortData, auxData, i, right);
    return i;
  }

  private static void compareExchange(long[] sortData, int[] auxData, int idxA, int idxB) {
    if (sortData[idxB] < sortData[idxA]) {
      exchange(sortData, auxData, idxA, idxB);
    }
  }

  private static void exchange(long[] sortData, int[] auxData, int idxA, int idxB) {
    if (idxA == idxB) {
      return;
    }

    long tempSortVal = sortData[idxA];
    sortData[idxA] = sortData[idxB];
    sortData[idxB] = tempSortVal;

    int tempAuxVal = auxData[idxA];
    auxData[idxA] = auxData[idxB];
    auxData[idxB] = tempAuxVal;
  }

  /**
   * In-place sorts two parallel arrays in the natural order of elements of the first array.
   *
   * @param sortData the first array, whose values will determine the final sorted order
   * @param auxData the second array, whose values will be rearranged in parallel with the first array
   */
  public static void sort(long[] sortData, long[] auxData) {
    quicksort(sortData, auxData, 0, sortData.length - 1);
  }

  /**
   * In-place sorts two parallel arrays in the natural order of elements of the first array.
   *
   * @param sortData the first array, whose values will determine the final sorted order
   * @param auxData the second array, whose values will be rearranged in parallel with the first array
   * @param left the starting index of the subarray to be sorted.  To sort the entire array, specify 0.
   * @param right the ending index, INCLUSIVE, of the subarray to be sorted.  To sort the entire array, specify
   *              sortData.length - 1
   */
  private static void quicksort(long[] sortData, long[] auxData, int left, int right) {
    if (right <= left) {
      return;
    }

    // These exchanges are here to reduce both the runtime and the
    // stack usage (level of recursion) in degenerate cases such as
    // when the input is sorted or nearly sorted.
    exchange(sortData, auxData, (left + right) / 2, right - 1);
    compareExchange(sortData, auxData, left, right - 1);
    compareExchange(sortData, auxData, left, right);
    compareExchange(sortData, auxData, right - 1, right);

    if (right - 1 <= left) {
      return;
    }

    int i = partition(sortData, auxData, left + 1, right - 1);

    quicksort(sortData, auxData, left, i - 1);
    quicksort(sortData, auxData, i + 1, right);
  }

  private static int partition(long[] sortData, long[] auxData, int left, int right) {
    int i = left - 1;
    int j = right;

    long sortVal = sortData[right];

    while (true) {
      while (sortData[++i] < sortVal) {
        // this space intentionally left blank
      }

      while (sortVal < sortData[--j]) {
        if (j == left) {
          break;
        }
      }

      if (i >= j) {
        break;
      }

      exchange(sortData, auxData, i, j);
    }

    exchange(sortData, auxData, i, right);
    return i;
  }

  private static void compareExchange(long[] sortData, long[] auxData, int idxA, int idxB) {
    if (sortData[idxB] < sortData[idxA]) {
      exchange(sortData, auxData, idxA, idxB);
    }
  }

  private static void exchange(long[] sortData, long[] auxData, int idxA, int idxB) {
    if (idxA == idxB) {
      return;
    }

    long tempSortVal = sortData[idxA];
    sortData[idxA] = sortData[idxB];
    sortData[idxB] = tempSortVal;

    long tempAuxVal = auxData[idxA];
    auxData[idxA] = auxData[idxB];
    auxData[idxB] = tempAuxVal;
  }

  /**
   * Converts an array of longs to an array of floats.
   *
   * This cast is "lossy" and may lose information.
   *
   * @param arr the array to convert
   * @return an array of floats cast from the provided array of longs
   */
  public static float[] toFloatsLossy(long[] arr) {
    float[] res = new float[arr.length];
    for (int i = 0; i < res.length; i++) {
      res[i] = (float) arr[i];
    }

    return res;
  }

  /**
   * Converts an array of longs to an array of floats, throwing an exception if the
   * converted values do not <i>exactly</i> match the originals (as determined by {@code !=}.)
   *
   * @param arr the array to convert
   * @return an array of floats cast from the provided array of longs
   * @throws ArithmeticException if the array cannot be losslessly converted
   */
  public static float[] toFloatsExact(long[] arr) {
    float[] res = toFloatsLossy(arr);
    for (int i = 0; i < res.length; i++) {
      if (res[i] != arr[i]) {
        throw new ArithmeticException("Cannot losslessly convert provided long[] to float[] at index " + i + "; "
            + res[i] + " != " + arr[i]);
      }
    }

    return res;
  }

  /**
   * In-place sorts two parallel arrays in the natural order of elements of the first array.
   *
   * @param sortData the first array, whose values will determine the final sorted order
   * @param auxData the second array, whose values will be rearranged in parallel with the first array
   */
  public static void sort(long[] sortData, float[] auxData) {
    quicksort(sortData, auxData, 0, sortData.length - 1);
  }

  /**
   * In-place sorts two parallel arrays in the natural order of elements of the first array.
   *
   * @param sortData the first array, whose values will determine the final sorted order
   * @param auxData the second array, whose values will be rearranged in parallel with the first array
   * @param left the starting index of the subarray to be sorted.  To sort the entire array, specify 0.
   * @param right the ending index, INCLUSIVE, of the subarray to be sorted.  To sort the entire array, specify
   *              sortData.length - 1
   */
  private static void quicksort(long[] sortData, float[] auxData, int left, int right) {
    if (right <= left) {
      return;
    }

    // These exchanges are here to reduce both the runtime and the
    // stack usage (level of recursion) in degenerate cases such as
    // when the input is sorted or nearly sorted.
    exchange(sortData, auxData, (left + right) / 2, right - 1);
    compareExchange(sortData, auxData, left, right - 1);
    compareExchange(sortData, auxData, left, right);
    compareExchange(sortData, auxData, right - 1, right);

    if (right - 1 <= left) {
      return;
    }

    int i = partition(sortData, auxData, left + 1, right - 1);

    quicksort(sortData, auxData, left, i - 1);
    quicksort(sortData, auxData, i + 1, right);
  }

  private static int partition(long[] sortData, float[] auxData, int left, int right) {
    int i = left - 1;
    int j = right;

    long sortVal = sortData[right];

    while (true) {
      while (sortData[++i] < sortVal) {
        // this space intentionally left blank
      }

      while (sortVal < sortData[--j]) {
        if (j == left) {
          break;
        }
      }

      if (i >= j) {
        break;
      }

      exchange(sortData, auxData, i, j);
    }

    exchange(sortData, auxData, i, right);
    return i;
  }

  private static void compareExchange(long[] sortData, float[] auxData, int idxA, int idxB) {
    if (sortData[idxB] < sortData[idxA]) {
      exchange(sortData, auxData, idxA, idxB);
    }
  }

  private static void exchange(long[] sortData, float[] auxData, int idxA, int idxB) {
    if (idxA == idxB) {
      return;
    }

    long tempSortVal = sortData[idxA];
    sortData[idxA] = sortData[idxB];
    sortData[idxB] = tempSortVal;

    float tempAuxVal = auxData[idxA];
    auxData[idxA] = auxData[idxB];
    auxData[idxB] = tempAuxVal;
  }

  /**
   * Converts an array of longs to an array of doubles.
   *
   * This cast is "lossy" and may lose information.
   *
   * @param arr the array to convert
   * @return an array of doubles cast from the provided array of longs
   */
  public static double[] toDoublesLossy(long[] arr) {
    double[] res = new double[arr.length];
    for (int i = 0; i < res.length; i++) {
      res[i] = (double) arr[i];
    }

    return res;
  }

  /**
   * Converts an array of longs to an array of doubles, throwing an exception if the
   * converted values do not <i>exactly</i> match the originals (as determined by {@code !=}.)
   *
   * @param arr the array to convert
   * @return an array of doubles cast from the provided array of longs
   * @throws ArithmeticException if the array cannot be losslessly converted
   */
  public static double[] toDoublesExact(long[] arr) {
    double[] res = toDoublesLossy(arr);
    for (int i = 0; i < res.length; i++) {
      if (res[i] != arr[i]) {
        throw new ArithmeticException("Cannot losslessly convert provided long[] to double[] at index " + i + "; "
            + res[i] + " != " + arr[i]);
      }
    }

    return res;
  }

  /**
   * In-place sorts two parallel arrays in the natural order of elements of the first array.
   *
   * @param sortData the first array, whose values will determine the final sorted order
   * @param auxData the second array, whose values will be rearranged in parallel with the first array
   */
  public static void sort(long[] sortData, double[] auxData) {
    quicksort(sortData, auxData, 0, sortData.length - 1);
  }

  /**
   * In-place sorts two parallel arrays in the natural order of elements of the first array.
   *
   * @param sortData the first array, whose values will determine the final sorted order
   * @param auxData the second array, whose values will be rearranged in parallel with the first array
   * @param left the starting index of the subarray to be sorted.  To sort the entire array, specify 0.
   * @param right the ending index, INCLUSIVE, of the subarray to be sorted.  To sort the entire array, specify
   *              sortData.length - 1
   */
  private static void quicksort(long[] sortData, double[] auxData, int left, int right) {
    if (right <= left) {
      return;
    }

    // These exchanges are here to reduce both the runtime and the
    // stack usage (level of recursion) in degenerate cases such as
    // when the input is sorted or nearly sorted.
    exchange(sortData, auxData, (left + right) / 2, right - 1);
    compareExchange(sortData, auxData, left, right - 1);
    compareExchange(sortData, auxData, left, right);
    compareExchange(sortData, auxData, right - 1, right);

    if (right - 1 <= left) {
      return;
    }

    int i = partition(sortData, auxData, left + 1, right - 1);

    quicksort(sortData, auxData, left, i - 1);
    quicksort(sortData, auxData, i + 1, right);
  }

  private static int partition(long[] sortData, double[] auxData, int left, int right) {
    int i = left - 1;
    int j = right;

    long sortVal = sortData[right];

    while (true) {
      while (sortData[++i] < sortVal) {
        // this space intentionally left blank
      }

      while (sortVal < sortData[--j]) {
        if (j == left) {
          break;
        }
      }

      if (i >= j) {
        break;
      }

      exchange(sortData, auxData, i, j);
    }

    exchange(sortData, auxData, i, right);
    return i;
  }

  private static void compareExchange(long[] sortData, double[] auxData, int idxA, int idxB) {
    if (sortData[idxB] < sortData[idxA]) {
      exchange(sortData, auxData, idxA, idxB);
    }
  }

  private static void exchange(long[] sortData, double[] auxData, int idxA, int idxB) {
    if (idxA == idxB) {
      return;
    }

    long tempSortVal = sortData[idxA];
    sortData[idxA] = sortData[idxB];
    sortData[idxB] = tempSortVal;

    double tempAuxVal = auxData[idxA];
    auxData[idxA] = auxData[idxB];
    auxData[idxB] = tempAuxVal;
  }

  // ---------------- Begin methods for Floats ----------------

  /**
   * An instance of an empty float array.  Using this instance rather than creating a new array each time an empty
   * array is needed avoids an unnecessary object creation.
   */
  public static final float[] EMPTY_FLOAT_ARRAY = new float[0];

  /**
   * Concatenates one or more arrays.
   *
   * @param arrays one or more arrays to concatenate
   * @return the concatenated array
   */
  public static float[] concat(float[]... arrays) {
    int size = 0;
    for (float[] arr : arrays) {
      size += arr.length;
    }

    float[] res = new float[size];

    int offset = 0;
    for (float[] arr : arrays) {
      System.arraycopy(arr, 0, res, offset, arr.length);
      offset += arr.length;
    }

    return res;
  }

  /**
   * Wraps an array as a {@link java.util.List} just as {@link Arrays#asList(Object[])} does for reference types.
   *
   * However, unlike the list returned by {@link Arrays#asList(Object[])}, the returned list may still grow (or shrink),
   * in which case its underlying array may cease to be the {@code wrapped} array (such that changes in one will cease
   * to induce changes in the other).
   *
   * @param wrapped the array to wrap; until the list size changes, it is guaranteed that changes to the elements of
   *                the array will affect the list wrapper, and vice-versa
   * @return a list that wraps the provided array
   */
  public static FloatArrayList asList(float... wrapped) {
    return FloatArrayList.wrap(wrapped);
  }

  /**
   * Transposes a "matrix" comprised of an array of arrays; each element array[i][j] will be copied to transposed[j][i].
   *
   * If the original array of arrays is "jagged" (with subarray "rows" of differing lengths), the width of the matrix
   * will be taken as the longest of its rows and any "missing" elements in shorter rows will treated as if they were
   * 0.
   *
   * @param matrix the array of arrays to transpose; the subarray "rows" do not need to be of uniform length
   * @return a new, transposed array of arrays such that each element {@code matrix[i][j]} will be copied to
   *         {@code transposed[j][i]}
   */
  public static float[][] transpose(float[][] matrix) {
    // find the longest row in the matrix (its number of columns)--this will be our result matrix's width
    int newHeight = 0;
    for (float[] row : matrix) {
      newHeight = Math.max(newHeight, row.length);
    }

    float[][] transposed = new float[newHeight][matrix.length];
    for (int i = 0; i < matrix.length; i++) {
      float[] row = matrix[i];
      for (int j = 0; j < row.length; j++) {
        transposed[j][i] = row[j];
      }
    }

    return transposed;
  }

  /**
   * Given a sorted array (either least to greatest or greatest to least), places all unique elements at the start of
   * the array (maintaining the original sort order and overwriting their original values) and returns the number of
   * unique elements.
   *
   * For example, if this method is called on the array [1, 2, 2, 2, 3, 3, 4], it will return 4 (the number of unique
   * elements) and the array will be modified to [1, 2, 3, 4, 3, 3, 4].  Note that only the first 4 elements of this
   * array have been changed.
   *
   * The time complexity of this method is O(n), where n is the length of the input array.
   *
   * @param array the sorted array to deduplicate
   * @return the number of unique elements in the provided array
   */
  public static int deduplicateSortedArray(float[] array) {
    // handle empty-array edge case
    if (array.length == 0) {
      return 0;
    }

    // look for duplicates and shift elements up to overwrite any that are found
    int shift = 0;
    for (int i = 1; i < array.length; i++) {
      if (array[i] == array[i - 1]) {
        shift++;
      } else {
        array[i - shift] = array[i]; // if shift == 0 this is a noop
      }
    }

    return array.length - shift;
  }

  /**
   * Reverses the order of the elements of the array.
   *
   * @param array the array to be reversed
   */
  public static void reverse(float[] array) {
    for (int i = 0; i < array.length / 2; i++) {
      float val = array[array.length - i - 1];
      array[array.length - i - 1] = array[i];
      array[i] = val;
    }
  }

  /**
   * Returns true if the elements of the array are monotonically increasing (i.e. in natural order)
   *
   * @param array the array to be checked
   * @return true if the array is monotonically increasing, false otherwise
   */
  public static boolean isMonotonicallyIncreasing(float[] array) {
    if (array.length > 0) {
      float previousElement = array[0];
      for (int i = 1; i < array.length; i++) {
        if (array[i] < previousElement) {
          return false;
        }
        previousElement = array[i];
      }
    }

    return true;
  }

  /**
   * Returns true if the elements of the array are monotonically decreasing (i.e. in reverse natural order)
   *
   * @param array the array to be checked
   * @return true if the array is monotonically decreasing, false otherwise
   */
  public static boolean isMonotonicallyDecreasing(float[] array) {
    if (array.length > 0) {
      float previousElement = array[0];
      for (int i = 1; i < array.length; i++) {
        if (array[i] > previousElement) {
          return false;
        }
        previousElement = array[i];
      }
    }

    return true;
  }

  /**
   * Converts an {@link Iterable} of {@link Number}s to an array of floats.
   *
   * This method is "lossy" because it does not know, a priori, the concrete types of the providers {@link Number}s,
   * and some information may be lost.  {@link Number#floatValue()} is used to obtain the array values.
   *
   * A run-time exception will be thrown if the quantity of elements in the provided {@link Iterable} exceeds the
   * maximum array length on this JVM.
   *
   * @param numbers the numbers that should be converted into an array of floats
   * @return an array of floats, possibly subject to truncation or rounding
   */
  public static float[] toFloatsLossy(Iterable<? extends Number> numbers) {
    float[] res = new float[Math.toIntExact(Iterables.size64(numbers))];

    java.util.Iterator<? extends Number> iterator = numbers.iterator();
    try {
      for (int i = 0; i < res.length; i++) {
        res[i] = iterator.next().floatValue();
      }
      return res;
    } finally {
      // properly close AutoCloseable iterators
      Closeables.tryClose(iterator);
    }
  }

  /**
   * In-place sorts two parallel arrays in the natural order of elements of the first array.
   *
   * @param sortData the first array, whose values will determine the final sorted order
   * @param auxData the second array, whose values will be rearranged in parallel with the first array
   */
  public static void sort(float[] sortData, Object[] auxData) {
    quicksort(sortData, auxData, 0, sortData.length - 1);
  }

  /**
   * In-place sorts two parallel arrays in the natural order of elements of the first array.
   *
   * @param sortData the first array, whose values will determine the final sorted order
   * @param auxData the second array, whose values will be rearranged in parallel with the first array
   * @param left the starting index of the subarray to be sorted.  To sort the entire array, specify 0.
   * @param right the ending index, INCLUSIVE, of the subarray to be sorted.  To sort the entire array, specify
   *              sortData.length - 1
   */
  private static void quicksort(float[] sortData, Object[] auxData, int left, int right) {
    if (right <= left) {
      return;
    }

    // These exchanges are here to reduce both the runtime and the
    // stack usage (level of recursion) in degenerate cases such as
    // when the input is sorted or nearly sorted.
    exchange(sortData, auxData, (left + right) / 2, right - 1);
    compareExchange(sortData, auxData, left, right - 1);
    compareExchange(sortData, auxData, left, right);
    compareExchange(sortData, auxData, right - 1, right);

    if (right - 1 <= left) {
      return;
    }

    int i = partition(sortData, auxData, left + 1, right - 1);

    quicksort(sortData, auxData, left, i - 1);
    quicksort(sortData, auxData, i + 1, right);
  }

  private static int partition(float[] sortData, Object[] auxData, int left, int right) {
    int i = left - 1;
    int j = right;

    float sortVal = sortData[right];

    while (true) {
      while (sortData[++i] < sortVal) {
        // this space intentionally left blank
      }

      while (sortVal < sortData[--j]) {
        if (j == left) {
          break;
        }
      }

      if (i >= j) {
        break;
      }

      exchange(sortData, auxData, i, j);
    }

    exchange(sortData, auxData, i, right);
    return i;
  }

  private static void compareExchange(float[] sortData, Object[] auxData, int idxA, int idxB) {
    if (sortData[idxB] < sortData[idxA]) {
      exchange(sortData, auxData, idxA, idxB);
    }
  }

  private static void exchange(float[] sortData, Object[] auxData, int idxA, int idxB) {
    if (idxA == idxB) {
      return;
    }

    float tempSortVal = sortData[idxA];
    sortData[idxA] = sortData[idxB];
    sortData[idxB] = tempSortVal;

    Object tempAuxVal = auxData[idxA];
    auxData[idxA] = auxData[idxB];
    auxData[idxB] = tempAuxVal;
  }

  /**
   * In-place sorts two parallel arrays in the natural order of elements of the first array.
   *
   * @param sortData the first array, whose values will determine the final sorted order
   * @param auxData the second array, whose values will be rearranged in parallel with the first array
   */
  public static void sort(float[] sortData, boolean[] auxData) {
    quicksort(sortData, auxData, 0, sortData.length - 1);
  }

  /**
   * In-place sorts two parallel arrays in the natural order of elements of the first array.
   *
   * @param sortData the first array, whose values will determine the final sorted order
   * @param auxData the second array, whose values will be rearranged in parallel with the first array
   * @param left the starting index of the subarray to be sorted.  To sort the entire array, specify 0.
   * @param right the ending index, INCLUSIVE, of the subarray to be sorted.  To sort the entire array, specify
   *              sortData.length - 1
   */
  private static void quicksort(float[] sortData, boolean[] auxData, int left, int right) {
    if (right <= left) {
      return;
    }

    // These exchanges are here to reduce both the runtime and the
    // stack usage (level of recursion) in degenerate cases such as
    // when the input is sorted or nearly sorted.
    exchange(sortData, auxData, (left + right) / 2, right - 1);
    compareExchange(sortData, auxData, left, right - 1);
    compareExchange(sortData, auxData, left, right);
    compareExchange(sortData, auxData, right - 1, right);

    if (right - 1 <= left) {
      return;
    }

    int i = partition(sortData, auxData, left + 1, right - 1);

    quicksort(sortData, auxData, left, i - 1);
    quicksort(sortData, auxData, i + 1, right);
  }

  private static int partition(float[] sortData, boolean[] auxData, int left, int right) {
    int i = left - 1;
    int j = right;

    float sortVal = sortData[right];

    while (true) {
      while (sortData[++i] < sortVal) {
        // this space intentionally left blank
      }

      while (sortVal < sortData[--j]) {
        if (j == left) {
          break;
        }
      }

      if (i >= j) {
        break;
      }

      exchange(sortData, auxData, i, j);
    }

    exchange(sortData, auxData, i, right);
    return i;
  }

  private static void compareExchange(float[] sortData, boolean[] auxData, int idxA, int idxB) {
    if (sortData[idxB] < sortData[idxA]) {
      exchange(sortData, auxData, idxA, idxB);
    }
  }

  private static void exchange(float[] sortData, boolean[] auxData, int idxA, int idxB) {
    if (idxA == idxB) {
      return;
    }

    float tempSortVal = sortData[idxA];
    sortData[idxA] = sortData[idxB];
    sortData[idxB] = tempSortVal;

    boolean tempAuxVal = auxData[idxA];
    auxData[idxA] = auxData[idxB];
    auxData[idxB] = tempAuxVal;
  }

  /**
   * Converts an array of floats to an array of bytes.
   *
   * This cast is "lossy" and may lose information.
   *
   * @param arr the array to convert
   * @return an array of bytes cast from the provided array of floats
   */
  public static byte[] toBytesLossy(float[] arr) {
    byte[] res = new byte[arr.length];
    for (int i = 0; i < res.length; i++) {
      res[i] = (byte) arr[i];
    }

    return res;
  }

  /**
   * Converts an array of floats to an array of bytes, throwing an exception if the
   * converted values do not <i>exactly</i> match the originals (as determined by {@code !=}.)
   *
   * @param arr the array to convert
   * @return an array of bytes cast from the provided array of floats
   * @throws ArithmeticException if the array cannot be losslessly converted
   */
  public static byte[] toBytesExact(float[] arr) {
    byte[] res = toBytesLossy(arr);
    for (int i = 0; i < res.length; i++) {
      if (res[i] != arr[i]) {
        throw new ArithmeticException("Cannot losslessly convert provided float[] to byte[] at index " + i + "; "
            + res[i] + " != " + arr[i]);
      }
    }

    return res;
  }

  /**
   * In-place sorts two parallel arrays in the natural order of elements of the first array.
   *
   * @param sortData the first array, whose values will determine the final sorted order
   * @param auxData the second array, whose values will be rearranged in parallel with the first array
   */
  public static void sort(float[] sortData, byte[] auxData) {
    quicksort(sortData, auxData, 0, sortData.length - 1);
  }

  /**
   * In-place sorts two parallel arrays in the natural order of elements of the first array.
   *
   * @param sortData the first array, whose values will determine the final sorted order
   * @param auxData the second array, whose values will be rearranged in parallel with the first array
   * @param left the starting index of the subarray to be sorted.  To sort the entire array, specify 0.
   * @param right the ending index, INCLUSIVE, of the subarray to be sorted.  To sort the entire array, specify
   *              sortData.length - 1
   */
  private static void quicksort(float[] sortData, byte[] auxData, int left, int right) {
    if (right <= left) {
      return;
    }

    // These exchanges are here to reduce both the runtime and the
    // stack usage (level of recursion) in degenerate cases such as
    // when the input is sorted or nearly sorted.
    exchange(sortData, auxData, (left + right) / 2, right - 1);
    compareExchange(sortData, auxData, left, right - 1);
    compareExchange(sortData, auxData, left, right);
    compareExchange(sortData, auxData, right - 1, right);

    if (right - 1 <= left) {
      return;
    }

    int i = partition(sortData, auxData, left + 1, right - 1);

    quicksort(sortData, auxData, left, i - 1);
    quicksort(sortData, auxData, i + 1, right);
  }

  private static int partition(float[] sortData, byte[] auxData, int left, int right) {
    int i = left - 1;
    int j = right;

    float sortVal = sortData[right];

    while (true) {
      while (sortData[++i] < sortVal) {
        // this space intentionally left blank
      }

      while (sortVal < sortData[--j]) {
        if (j == left) {
          break;
        }
      }

      if (i >= j) {
        break;
      }

      exchange(sortData, auxData, i, j);
    }

    exchange(sortData, auxData, i, right);
    return i;
  }

  private static void compareExchange(float[] sortData, byte[] auxData, int idxA, int idxB) {
    if (sortData[idxB] < sortData[idxA]) {
      exchange(sortData, auxData, idxA, idxB);
    }
  }

  private static void exchange(float[] sortData, byte[] auxData, int idxA, int idxB) {
    if (idxA == idxB) {
      return;
    }

    float tempSortVal = sortData[idxA];
    sortData[idxA] = sortData[idxB];
    sortData[idxB] = tempSortVal;

    byte tempAuxVal = auxData[idxA];
    auxData[idxA] = auxData[idxB];
    auxData[idxB] = tempAuxVal;
  }

  /**
   * Converts an array of floats to an array of chars.
   *
   * This cast is "lossy" and may lose information.
   *
   * @param arr the array to convert
   * @return an array of chars cast from the provided array of floats
   */
  public static char[] toCharactersLossy(float[] arr) {
    char[] res = new char[arr.length];
    for (int i = 0; i < res.length; i++) {
      res[i] = (char) arr[i];
    }

    return res;
  }

  /**
   * Converts an array of floats to an array of chars, throwing an exception if the
   * converted values do not <i>exactly</i> match the originals (as determined by {@code !=}.)
   *
   * @param arr the array to convert
   * @return an array of chars cast from the provided array of floats
   * @throws ArithmeticException if the array cannot be losslessly converted
   */
  public static char[] toCharactersExact(float[] arr) {
    char[] res = toCharactersLossy(arr);
    for (int i = 0; i < res.length; i++) {
      if (res[i] != arr[i]) {
        throw new ArithmeticException("Cannot losslessly convert provided float[] to char[] at index " + i + "; "
            + res[i] + " != " + arr[i]);
      }
    }

    return res;
  }

  /**
   * In-place sorts two parallel arrays in the natural order of elements of the first array.
   *
   * @param sortData the first array, whose values will determine the final sorted order
   * @param auxData the second array, whose values will be rearranged in parallel with the first array
   */
  public static void sort(float[] sortData, char[] auxData) {
    quicksort(sortData, auxData, 0, sortData.length - 1);
  }

  /**
   * In-place sorts two parallel arrays in the natural order of elements of the first array.
   *
   * @param sortData the first array, whose values will determine the final sorted order
   * @param auxData the second array, whose values will be rearranged in parallel with the first array
   * @param left the starting index of the subarray to be sorted.  To sort the entire array, specify 0.
   * @param right the ending index, INCLUSIVE, of the subarray to be sorted.  To sort the entire array, specify
   *              sortData.length - 1
   */
  private static void quicksort(float[] sortData, char[] auxData, int left, int right) {
    if (right <= left) {
      return;
    }

    // These exchanges are here to reduce both the runtime and the
    // stack usage (level of recursion) in degenerate cases such as
    // when the input is sorted or nearly sorted.
    exchange(sortData, auxData, (left + right) / 2, right - 1);
    compareExchange(sortData, auxData, left, right - 1);
    compareExchange(sortData, auxData, left, right);
    compareExchange(sortData, auxData, right - 1, right);

    if (right - 1 <= left) {
      return;
    }

    int i = partition(sortData, auxData, left + 1, right - 1);

    quicksort(sortData, auxData, left, i - 1);
    quicksort(sortData, auxData, i + 1, right);
  }

  private static int partition(float[] sortData, char[] auxData, int left, int right) {
    int i = left - 1;
    int j = right;

    float sortVal = sortData[right];

    while (true) {
      while (sortData[++i] < sortVal) {
        // this space intentionally left blank
      }

      while (sortVal < sortData[--j]) {
        if (j == left) {
          break;
        }
      }

      if (i >= j) {
        break;
      }

      exchange(sortData, auxData, i, j);
    }

    exchange(sortData, auxData, i, right);
    return i;
  }

  private static void compareExchange(float[] sortData, char[] auxData, int idxA, int idxB) {
    if (sortData[idxB] < sortData[idxA]) {
      exchange(sortData, auxData, idxA, idxB);
    }
  }

  private static void exchange(float[] sortData, char[] auxData, int idxA, int idxB) {
    if (idxA == idxB) {
      return;
    }

    float tempSortVal = sortData[idxA];
    sortData[idxA] = sortData[idxB];
    sortData[idxB] = tempSortVal;

    char tempAuxVal = auxData[idxA];
    auxData[idxA] = auxData[idxB];
    auxData[idxB] = tempAuxVal;
  }

  /**
   * Converts an array of floats to an array of shorts.
   *
   * This cast is "lossy" and may lose information.
   *
   * @param arr the array to convert
   * @return an array of shorts cast from the provided array of floats
   */
  public static short[] toShortsLossy(float[] arr) {
    short[] res = new short[arr.length];
    for (int i = 0; i < res.length; i++) {
      res[i] = (short) arr[i];
    }

    return res;
  }

  /**
   * Converts an array of floats to an array of shorts, throwing an exception if the
   * converted values do not <i>exactly</i> match the originals (as determined by {@code !=}.)
   *
   * @param arr the array to convert
   * @return an array of shorts cast from the provided array of floats
   * @throws ArithmeticException if the array cannot be losslessly converted
   */
  public static short[] toShortsExact(float[] arr) {
    short[] res = toShortsLossy(arr);
    for (int i = 0; i < res.length; i++) {
      if (res[i] != arr[i]) {
        throw new ArithmeticException("Cannot losslessly convert provided float[] to short[] at index " + i + "; "
            + res[i] + " != " + arr[i]);
      }
    }

    return res;
  }

  /**
   * In-place sorts two parallel arrays in the natural order of elements of the first array.
   *
   * @param sortData the first array, whose values will determine the final sorted order
   * @param auxData the second array, whose values will be rearranged in parallel with the first array
   */
  public static void sort(float[] sortData, short[] auxData) {
    quicksort(sortData, auxData, 0, sortData.length - 1);
  }

  /**
   * In-place sorts two parallel arrays in the natural order of elements of the first array.
   *
   * @param sortData the first array, whose values will determine the final sorted order
   * @param auxData the second array, whose values will be rearranged in parallel with the first array
   * @param left the starting index of the subarray to be sorted.  To sort the entire array, specify 0.
   * @param right the ending index, INCLUSIVE, of the subarray to be sorted.  To sort the entire array, specify
   *              sortData.length - 1
   */
  private static void quicksort(float[] sortData, short[] auxData, int left, int right) {
    if (right <= left) {
      return;
    }

    // These exchanges are here to reduce both the runtime and the
    // stack usage (level of recursion) in degenerate cases such as
    // when the input is sorted or nearly sorted.
    exchange(sortData, auxData, (left + right) / 2, right - 1);
    compareExchange(sortData, auxData, left, right - 1);
    compareExchange(sortData, auxData, left, right);
    compareExchange(sortData, auxData, right - 1, right);

    if (right - 1 <= left) {
      return;
    }

    int i = partition(sortData, auxData, left + 1, right - 1);

    quicksort(sortData, auxData, left, i - 1);
    quicksort(sortData, auxData, i + 1, right);
  }

  private static int partition(float[] sortData, short[] auxData, int left, int right) {
    int i = left - 1;
    int j = right;

    float sortVal = sortData[right];

    while (true) {
      while (sortData[++i] < sortVal) {
        // this space intentionally left blank
      }

      while (sortVal < sortData[--j]) {
        if (j == left) {
          break;
        }
      }

      if (i >= j) {
        break;
      }

      exchange(sortData, auxData, i, j);
    }

    exchange(sortData, auxData, i, right);
    return i;
  }

  private static void compareExchange(float[] sortData, short[] auxData, int idxA, int idxB) {
    if (sortData[idxB] < sortData[idxA]) {
      exchange(sortData, auxData, idxA, idxB);
    }
  }

  private static void exchange(float[] sortData, short[] auxData, int idxA, int idxB) {
    if (idxA == idxB) {
      return;
    }

    float tempSortVal = sortData[idxA];
    sortData[idxA] = sortData[idxB];
    sortData[idxB] = tempSortVal;

    short tempAuxVal = auxData[idxA];
    auxData[idxA] = auxData[idxB];
    auxData[idxB] = tempAuxVal;
  }

  /**
   * Converts an array of floats to an array of ints.
   *
   * This cast is "lossy" and may lose information.
   *
   * @param arr the array to convert
   * @return an array of ints cast from the provided array of floats
   */
  public static int[] toIntegersLossy(float[] arr) {
    int[] res = new int[arr.length];
    for (int i = 0; i < res.length; i++) {
      res[i] = (int) arr[i];
    }

    return res;
  }

  /**
   * Converts an array of floats to an array of ints, throwing an exception if the
   * converted values do not <i>exactly</i> match the originals (as determined by {@code !=}.)
   *
   * @param arr the array to convert
   * @return an array of ints cast from the provided array of floats
   * @throws ArithmeticException if the array cannot be losslessly converted
   */
  public static int[] toIntegersExact(float[] arr) {
    int[] res = toIntegersLossy(arr);
    for (int i = 0; i < res.length; i++) {
      if (res[i] != arr[i]) {
        throw new ArithmeticException("Cannot losslessly convert provided float[] to int[] at index " + i + "; "
            + res[i] + " != " + arr[i]);
      }
    }

    return res;
  }

  /**
   * In-place sorts two parallel arrays in the natural order of elements of the first array.
   *
   * @param sortData the first array, whose values will determine the final sorted order
   * @param auxData the second array, whose values will be rearranged in parallel with the first array
   */
  public static void sort(float[] sortData, int[] auxData) {
    quicksort(sortData, auxData, 0, sortData.length - 1);
  }

  /**
   * In-place sorts two parallel arrays in the natural order of elements of the first array.
   *
   * @param sortData the first array, whose values will determine the final sorted order
   * @param auxData the second array, whose values will be rearranged in parallel with the first array
   * @param left the starting index of the subarray to be sorted.  To sort the entire array, specify 0.
   * @param right the ending index, INCLUSIVE, of the subarray to be sorted.  To sort the entire array, specify
   *              sortData.length - 1
   */
  private static void quicksort(float[] sortData, int[] auxData, int left, int right) {
    if (right <= left) {
      return;
    }

    // These exchanges are here to reduce both the runtime and the
    // stack usage (level of recursion) in degenerate cases such as
    // when the input is sorted or nearly sorted.
    exchange(sortData, auxData, (left + right) / 2, right - 1);
    compareExchange(sortData, auxData, left, right - 1);
    compareExchange(sortData, auxData, left, right);
    compareExchange(sortData, auxData, right - 1, right);

    if (right - 1 <= left) {
      return;
    }

    int i = partition(sortData, auxData, left + 1, right - 1);

    quicksort(sortData, auxData, left, i - 1);
    quicksort(sortData, auxData, i + 1, right);
  }

  private static int partition(float[] sortData, int[] auxData, int left, int right) {
    int i = left - 1;
    int j = right;

    float sortVal = sortData[right];

    while (true) {
      while (sortData[++i] < sortVal) {
        // this space intentionally left blank
      }

      while (sortVal < sortData[--j]) {
        if (j == left) {
          break;
        }
      }

      if (i >= j) {
        break;
      }

      exchange(sortData, auxData, i, j);
    }

    exchange(sortData, auxData, i, right);
    return i;
  }

  private static void compareExchange(float[] sortData, int[] auxData, int idxA, int idxB) {
    if (sortData[idxB] < sortData[idxA]) {
      exchange(sortData, auxData, idxA, idxB);
    }
  }

  private static void exchange(float[] sortData, int[] auxData, int idxA, int idxB) {
    if (idxA == idxB) {
      return;
    }

    float tempSortVal = sortData[idxA];
    sortData[idxA] = sortData[idxB];
    sortData[idxB] = tempSortVal;

    int tempAuxVal = auxData[idxA];
    auxData[idxA] = auxData[idxB];
    auxData[idxB] = tempAuxVal;
  }

  /**
   * Converts an array of floats to an array of longs.
   *
   * This cast is "lossy" and may lose information.
   *
   * @param arr the array to convert
   * @return an array of longs cast from the provided array of floats
   */
  public static long[] toLongsLossy(float[] arr) {
    long[] res = new long[arr.length];
    for (int i = 0; i < res.length; i++) {
      res[i] = (long) arr[i];
    }

    return res;
  }

  /**
   * Converts an array of floats to an array of longs, throwing an exception if the
   * converted values do not <i>exactly</i> match the originals (as determined by {@code !=}.)
   *
   * @param arr the array to convert
   * @return an array of longs cast from the provided array of floats
   * @throws ArithmeticException if the array cannot be losslessly converted
   */
  public static long[] toLongsExact(float[] arr) {
    long[] res = toLongsLossy(arr);
    for (int i = 0; i < res.length; i++) {
      if (res[i] != arr[i]) {
        throw new ArithmeticException("Cannot losslessly convert provided float[] to long[] at index " + i + "; "
            + res[i] + " != " + arr[i]);
      }
    }

    return res;
  }

  /**
   * In-place sorts two parallel arrays in the natural order of elements of the first array.
   *
   * @param sortData the first array, whose values will determine the final sorted order
   * @param auxData the second array, whose values will be rearranged in parallel with the first array
   */
  public static void sort(float[] sortData, long[] auxData) {
    quicksort(sortData, auxData, 0, sortData.length - 1);
  }

  /**
   * In-place sorts two parallel arrays in the natural order of elements of the first array.
   *
   * @param sortData the first array, whose values will determine the final sorted order
   * @param auxData the second array, whose values will be rearranged in parallel with the first array
   * @param left the starting index of the subarray to be sorted.  To sort the entire array, specify 0.
   * @param right the ending index, INCLUSIVE, of the subarray to be sorted.  To sort the entire array, specify
   *              sortData.length - 1
   */
  private static void quicksort(float[] sortData, long[] auxData, int left, int right) {
    if (right <= left) {
      return;
    }

    // These exchanges are here to reduce both the runtime and the
    // stack usage (level of recursion) in degenerate cases such as
    // when the input is sorted or nearly sorted.
    exchange(sortData, auxData, (left + right) / 2, right - 1);
    compareExchange(sortData, auxData, left, right - 1);
    compareExchange(sortData, auxData, left, right);
    compareExchange(sortData, auxData, right - 1, right);

    if (right - 1 <= left) {
      return;
    }

    int i = partition(sortData, auxData, left + 1, right - 1);

    quicksort(sortData, auxData, left, i - 1);
    quicksort(sortData, auxData, i + 1, right);
  }

  private static int partition(float[] sortData, long[] auxData, int left, int right) {
    int i = left - 1;
    int j = right;

    float sortVal = sortData[right];

    while (true) {
      while (sortData[++i] < sortVal) {
        // this space intentionally left blank
      }

      while (sortVal < sortData[--j]) {
        if (j == left) {
          break;
        }
      }

      if (i >= j) {
        break;
      }

      exchange(sortData, auxData, i, j);
    }

    exchange(sortData, auxData, i, right);
    return i;
  }

  private static void compareExchange(float[] sortData, long[] auxData, int idxA, int idxB) {
    if (sortData[idxB] < sortData[idxA]) {
      exchange(sortData, auxData, idxA, idxB);
    }
  }

  private static void exchange(float[] sortData, long[] auxData, int idxA, int idxB) {
    if (idxA == idxB) {
      return;
    }

    float tempSortVal = sortData[idxA];
    sortData[idxA] = sortData[idxB];
    sortData[idxB] = tempSortVal;

    long tempAuxVal = auxData[idxA];
    auxData[idxA] = auxData[idxB];
    auxData[idxB] = tempAuxVal;
  }

  /**
   * In-place sorts two parallel arrays in the natural order of elements of the first array.
   *
   * @param sortData the first array, whose values will determine the final sorted order
   * @param auxData the second array, whose values will be rearranged in parallel with the first array
   */
  public static void sort(float[] sortData, float[] auxData) {
    quicksort(sortData, auxData, 0, sortData.length - 1);
  }

  /**
   * In-place sorts two parallel arrays in the natural order of elements of the first array.
   *
   * @param sortData the first array, whose values will determine the final sorted order
   * @param auxData the second array, whose values will be rearranged in parallel with the first array
   * @param left the starting index of the subarray to be sorted.  To sort the entire array, specify 0.
   * @param right the ending index, INCLUSIVE, of the subarray to be sorted.  To sort the entire array, specify
   *              sortData.length - 1
   */
  private static void quicksort(float[] sortData, float[] auxData, int left, int right) {
    if (right <= left) {
      return;
    }

    // These exchanges are here to reduce both the runtime and the
    // stack usage (level of recursion) in degenerate cases such as
    // when the input is sorted or nearly sorted.
    exchange(sortData, auxData, (left + right) / 2, right - 1);
    compareExchange(sortData, auxData, left, right - 1);
    compareExchange(sortData, auxData, left, right);
    compareExchange(sortData, auxData, right - 1, right);

    if (right - 1 <= left) {
      return;
    }

    int i = partition(sortData, auxData, left + 1, right - 1);

    quicksort(sortData, auxData, left, i - 1);
    quicksort(sortData, auxData, i + 1, right);
  }

  private static int partition(float[] sortData, float[] auxData, int left, int right) {
    int i = left - 1;
    int j = right;

    float sortVal = sortData[right];

    while (true) {
      while (sortData[++i] < sortVal) {
        // this space intentionally left blank
      }

      while (sortVal < sortData[--j]) {
        if (j == left) {
          break;
        }
      }

      if (i >= j) {
        break;
      }

      exchange(sortData, auxData, i, j);
    }

    exchange(sortData, auxData, i, right);
    return i;
  }

  private static void compareExchange(float[] sortData, float[] auxData, int idxA, int idxB) {
    if (sortData[idxB] < sortData[idxA]) {
      exchange(sortData, auxData, idxA, idxB);
    }
  }

  private static void exchange(float[] sortData, float[] auxData, int idxA, int idxB) {
    if (idxA == idxB) {
      return;
    }

    float tempSortVal = sortData[idxA];
    sortData[idxA] = sortData[idxB];
    sortData[idxB] = tempSortVal;

    float tempAuxVal = auxData[idxA];
    auxData[idxA] = auxData[idxB];
    auxData[idxB] = tempAuxVal;
  }

  /**
   * Converts an array of floats to an array of doubles.
   *
   * This cast is lossless (no loss of information).
   *
   * @param arr the array to convert
   * @return an array of doubles cast from the provided array of floats
   */
  public static double[] toDoubles(float[] arr) {
    double[] res = new double[arr.length];
    for (int i = 0; i < res.length; i++) {
      res[i] = arr[i];
    }

    return res;
  }

  /**
   * In-place sorts two parallel arrays in the natural order of elements of the first array.
   *
   * @param sortData the first array, whose values will determine the final sorted order
   * @param auxData the second array, whose values will be rearranged in parallel with the first array
   */
  public static void sort(float[] sortData, double[] auxData) {
    quicksort(sortData, auxData, 0, sortData.length - 1);
  }

  /**
   * In-place sorts two parallel arrays in the natural order of elements of the first array.
   *
   * @param sortData the first array, whose values will determine the final sorted order
   * @param auxData the second array, whose values will be rearranged in parallel with the first array
   * @param left the starting index of the subarray to be sorted.  To sort the entire array, specify 0.
   * @param right the ending index, INCLUSIVE, of the subarray to be sorted.  To sort the entire array, specify
   *              sortData.length - 1
   */
  private static void quicksort(float[] sortData, double[] auxData, int left, int right) {
    if (right <= left) {
      return;
    }

    // These exchanges are here to reduce both the runtime and the
    // stack usage (level of recursion) in degenerate cases such as
    // when the input is sorted or nearly sorted.
    exchange(sortData, auxData, (left + right) / 2, right - 1);
    compareExchange(sortData, auxData, left, right - 1);
    compareExchange(sortData, auxData, left, right);
    compareExchange(sortData, auxData, right - 1, right);

    if (right - 1 <= left) {
      return;
    }

    int i = partition(sortData, auxData, left + 1, right - 1);

    quicksort(sortData, auxData, left, i - 1);
    quicksort(sortData, auxData, i + 1, right);
  }

  private static int partition(float[] sortData, double[] auxData, int left, int right) {
    int i = left - 1;
    int j = right;

    float sortVal = sortData[right];

    while (true) {
      while (sortData[++i] < sortVal) {
        // this space intentionally left blank
      }

      while (sortVal < sortData[--j]) {
        if (j == left) {
          break;
        }
      }

      if (i >= j) {
        break;
      }

      exchange(sortData, auxData, i, j);
    }

    exchange(sortData, auxData, i, right);
    return i;
  }

  private static void compareExchange(float[] sortData, double[] auxData, int idxA, int idxB) {
    if (sortData[idxB] < sortData[idxA]) {
      exchange(sortData, auxData, idxA, idxB);
    }
  }

  private static void exchange(float[] sortData, double[] auxData, int idxA, int idxB) {
    if (idxA == idxB) {
      return;
    }

    float tempSortVal = sortData[idxA];
    sortData[idxA] = sortData[idxB];
    sortData[idxB] = tempSortVal;

    double tempAuxVal = auxData[idxA];
    auxData[idxA] = auxData[idxB];
    auxData[idxB] = tempAuxVal;
  }

  // ---------------- Begin methods for Doubles ----------------

  /**
   * An instance of an empty double array.  Using this instance rather than creating a new array each time an empty
   * array is needed avoids an unnecessary object creation.
   */
  public static final double[] EMPTY_DOUBLE_ARRAY = new double[0];

  /**
   * Concatenates one or more arrays.
   *
   * @param arrays one or more arrays to concatenate
   * @return the concatenated array
   */
  public static double[] concat(double[]... arrays) {
    int size = 0;
    for (double[] arr : arrays) {
      size += arr.length;
    }

    double[] res = new double[size];

    int offset = 0;
    for (double[] arr : arrays) {
      System.arraycopy(arr, 0, res, offset, arr.length);
      offset += arr.length;
    }

    return res;
  }

  /**
   * Wraps an array as a {@link java.util.List} just as {@link Arrays#asList(Object[])} does for reference types.
   *
   * However, unlike the list returned by {@link Arrays#asList(Object[])}, the returned list may still grow (or shrink),
   * in which case its underlying array may cease to be the {@code wrapped} array (such that changes in one will cease
   * to induce changes in the other).
   *
   * @param wrapped the array to wrap; until the list size changes, it is guaranteed that changes to the elements of
   *                the array will affect the list wrapper, and vice-versa
   * @return a list that wraps the provided array
   */
  public static DoubleArrayList asList(double... wrapped) {
    return DoubleArrayList.wrap(wrapped);
  }

  /**
   * Transposes a "matrix" comprised of an array of arrays; each element array[i][j] will be copied to transposed[j][i].
   *
   * If the original array of arrays is "jagged" (with subarray "rows" of differing lengths), the width of the matrix
   * will be taken as the longest of its rows and any "missing" elements in shorter rows will treated as if they were
   * 0.
   *
   * @param matrix the array of arrays to transpose; the subarray "rows" do not need to be of uniform length
   * @return a new, transposed array of arrays such that each element {@code matrix[i][j]} will be copied to
   *         {@code transposed[j][i]}
   */
  public static double[][] transpose(double[][] matrix) {
    // find the longest row in the matrix (its number of columns)--this will be our result matrix's width
    int newHeight = 0;
    for (double[] row : matrix) {
      newHeight = Math.max(newHeight, row.length);
    }

    double[][] transposed = new double[newHeight][matrix.length];
    for (int i = 0; i < matrix.length; i++) {
      double[] row = matrix[i];
      for (int j = 0; j < row.length; j++) {
        transposed[j][i] = row[j];
      }
    }

    return transposed;
  }

  /**
   * Given a sorted array (either least to greatest or greatest to least), places all unique elements at the start of
   * the array (maintaining the original sort order and overwriting their original values) and returns the number of
   * unique elements.
   *
   * For example, if this method is called on the array [1, 2, 2, 2, 3, 3, 4], it will return 4 (the number of unique
   * elements) and the array will be modified to [1, 2, 3, 4, 3, 3, 4].  Note that only the first 4 elements of this
   * array have been changed.
   *
   * The time complexity of this method is O(n), where n is the length of the input array.
   *
   * @param array the sorted array to deduplicate
   * @return the number of unique elements in the provided array
   */
  public static int deduplicateSortedArray(double[] array) {
    // handle empty-array edge case
    if (array.length == 0) {
      return 0;
    }

    // look for duplicates and shift elements up to overwrite any that are found
    int shift = 0;
    for (int i = 1; i < array.length; i++) {
      if (array[i] == array[i - 1]) {
        shift++;
      } else {
        array[i - shift] = array[i]; // if shift == 0 this is a noop
      }
    }

    return array.length - shift;
  }

  /**
   * Reverses the order of the elements of the array.
   *
   * @param array the array to be reversed
   */
  public static void reverse(double[] array) {
    for (int i = 0; i < array.length / 2; i++) {
      double val = array[array.length - i - 1];
      array[array.length - i - 1] = array[i];
      array[i] = val;
    }
  }

  /**
   * Returns true if the elements of the array are monotonically increasing (i.e. in natural order)
   *
   * @param array the array to be checked
   * @return true if the array is monotonically increasing, false otherwise
   */
  public static boolean isMonotonicallyIncreasing(double[] array) {
    if (array.length > 0) {
      double previousElement = array[0];
      for (int i = 1; i < array.length; i++) {
        if (array[i] < previousElement) {
          return false;
        }
        previousElement = array[i];
      }
    }

    return true;
  }

  /**
   * Returns true if the elements of the array are monotonically decreasing (i.e. in reverse natural order)
   *
   * @param array the array to be checked
   * @return true if the array is monotonically decreasing, false otherwise
   */
  public static boolean isMonotonicallyDecreasing(double[] array) {
    if (array.length > 0) {
      double previousElement = array[0];
      for (int i = 1; i < array.length; i++) {
        if (array[i] > previousElement) {
          return false;
        }
        previousElement = array[i];
      }
    }

    return true;
  }

  /**
   * Converts an {@link Iterable} of {@link Number}s to an array of doubles.
   *
   * This method is "lossy" because it does not know, a priori, the concrete types of the providers {@link Number}s,
   * and some information may be lost.  {@link Number#doubleValue()} is used to obtain the array values.
   *
   * A run-time exception will be thrown if the quantity of elements in the provided {@link Iterable} exceeds the
   * maximum array length on this JVM.
   *
   * @param numbers the numbers that should be converted into an array of doubles
   * @return an array of doubles, possibly subject to truncation or rounding
   */
  public static double[] toDoublesLossy(Iterable<? extends Number> numbers) {
    double[] res = new double[Math.toIntExact(Iterables.size64(numbers))];

    java.util.Iterator<? extends Number> iterator = numbers.iterator();
    try {
      for (int i = 0; i < res.length; i++) {
        res[i] = iterator.next().doubleValue();
      }
      return res;
    } finally {
      // properly close AutoCloseable iterators
      Closeables.tryClose(iterator);
    }
  }

  /**
   * In-place sorts two parallel arrays in the natural order of elements of the first array.
   *
   * @param sortData the first array, whose values will determine the final sorted order
   * @param auxData the second array, whose values will be rearranged in parallel with the first array
   */
  public static void sort(double[] sortData, Object[] auxData) {
    quicksort(sortData, auxData, 0, sortData.length - 1);
  }

  /**
   * In-place sorts two parallel arrays in the natural order of elements of the first array.
   *
   * @param sortData the first array, whose values will determine the final sorted order
   * @param auxData the second array, whose values will be rearranged in parallel with the first array
   * @param left the starting index of the subarray to be sorted.  To sort the entire array, specify 0.
   * @param right the ending index, INCLUSIVE, of the subarray to be sorted.  To sort the entire array, specify
   *              sortData.length - 1
   */
  private static void quicksort(double[] sortData, Object[] auxData, int left, int right) {
    if (right <= left) {
      return;
    }

    // These exchanges are here to reduce both the runtime and the
    // stack usage (level of recursion) in degenerate cases such as
    // when the input is sorted or nearly sorted.
    exchange(sortData, auxData, (left + right) / 2, right - 1);
    compareExchange(sortData, auxData, left, right - 1);
    compareExchange(sortData, auxData, left, right);
    compareExchange(sortData, auxData, right - 1, right);

    if (right - 1 <= left) {
      return;
    }

    int i = partition(sortData, auxData, left + 1, right - 1);

    quicksort(sortData, auxData, left, i - 1);
    quicksort(sortData, auxData, i + 1, right);
  }

  private static int partition(double[] sortData, Object[] auxData, int left, int right) {
    int i = left - 1;
    int j = right;

    double sortVal = sortData[right];

    while (true) {
      while (sortData[++i] < sortVal) {
        // this space intentionally left blank
      }

      while (sortVal < sortData[--j]) {
        if (j == left) {
          break;
        }
      }

      if (i >= j) {
        break;
      }

      exchange(sortData, auxData, i, j);
    }

    exchange(sortData, auxData, i, right);
    return i;
  }

  private static void compareExchange(double[] sortData, Object[] auxData, int idxA, int idxB) {
    if (sortData[idxB] < sortData[idxA]) {
      exchange(sortData, auxData, idxA, idxB);
    }
  }

  private static void exchange(double[] sortData, Object[] auxData, int idxA, int idxB) {
    if (idxA == idxB) {
      return;
    }

    double tempSortVal = sortData[idxA];
    sortData[idxA] = sortData[idxB];
    sortData[idxB] = tempSortVal;

    Object tempAuxVal = auxData[idxA];
    auxData[idxA] = auxData[idxB];
    auxData[idxB] = tempAuxVal;
  }

  /**
   * In-place sorts two parallel arrays in the natural order of elements of the first array.
   *
   * @param sortData the first array, whose values will determine the final sorted order
   * @param auxData the second array, whose values will be rearranged in parallel with the first array
   */
  public static void sort(double[] sortData, boolean[] auxData) {
    quicksort(sortData, auxData, 0, sortData.length - 1);
  }

  /**
   * In-place sorts two parallel arrays in the natural order of elements of the first array.
   *
   * @param sortData the first array, whose values will determine the final sorted order
   * @param auxData the second array, whose values will be rearranged in parallel with the first array
   * @param left the starting index of the subarray to be sorted.  To sort the entire array, specify 0.
   * @param right the ending index, INCLUSIVE, of the subarray to be sorted.  To sort the entire array, specify
   *              sortData.length - 1
   */
  private static void quicksort(double[] sortData, boolean[] auxData, int left, int right) {
    if (right <= left) {
      return;
    }

    // These exchanges are here to reduce both the runtime and the
    // stack usage (level of recursion) in degenerate cases such as
    // when the input is sorted or nearly sorted.
    exchange(sortData, auxData, (left + right) / 2, right - 1);
    compareExchange(sortData, auxData, left, right - 1);
    compareExchange(sortData, auxData, left, right);
    compareExchange(sortData, auxData, right - 1, right);

    if (right - 1 <= left) {
      return;
    }

    int i = partition(sortData, auxData, left + 1, right - 1);

    quicksort(sortData, auxData, left, i - 1);
    quicksort(sortData, auxData, i + 1, right);
  }

  private static int partition(double[] sortData, boolean[] auxData, int left, int right) {
    int i = left - 1;
    int j = right;

    double sortVal = sortData[right];

    while (true) {
      while (sortData[++i] < sortVal) {
        // this space intentionally left blank
      }

      while (sortVal < sortData[--j]) {
        if (j == left) {
          break;
        }
      }

      if (i >= j) {
        break;
      }

      exchange(sortData, auxData, i, j);
    }

    exchange(sortData, auxData, i, right);
    return i;
  }

  private static void compareExchange(double[] sortData, boolean[] auxData, int idxA, int idxB) {
    if (sortData[idxB] < sortData[idxA]) {
      exchange(sortData, auxData, idxA, idxB);
    }
  }

  private static void exchange(double[] sortData, boolean[] auxData, int idxA, int idxB) {
    if (idxA == idxB) {
      return;
    }

    double tempSortVal = sortData[idxA];
    sortData[idxA] = sortData[idxB];
    sortData[idxB] = tempSortVal;

    boolean tempAuxVal = auxData[idxA];
    auxData[idxA] = auxData[idxB];
    auxData[idxB] = tempAuxVal;
  }

  /**
   * Converts an array of doubles to an array of bytes.
   *
   * This cast is "lossy" and may lose information.
   *
   * @param arr the array to convert
   * @return an array of bytes cast from the provided array of doubles
   */
  public static byte[] toBytesLossy(double[] arr) {
    byte[] res = new byte[arr.length];
    for (int i = 0; i < res.length; i++) {
      res[i] = (byte) arr[i];
    }

    return res;
  }

  /**
   * Converts an array of doubles to an array of bytes, throwing an exception if the
   * converted values do not <i>exactly</i> match the originals (as determined by {@code !=}.)
   *
   * @param arr the array to convert
   * @return an array of bytes cast from the provided array of doubles
   * @throws ArithmeticException if the array cannot be losslessly converted
   */
  public static byte[] toBytesExact(double[] arr) {
    byte[] res = toBytesLossy(arr);
    for (int i = 0; i < res.length; i++) {
      if (res[i] != arr[i]) {
        throw new ArithmeticException("Cannot losslessly convert provided double[] to byte[] at index " + i + "; "
            + res[i] + " != " + arr[i]);
      }
    }

    return res;
  }

  /**
   * In-place sorts two parallel arrays in the natural order of elements of the first array.
   *
   * @param sortData the first array, whose values will determine the final sorted order
   * @param auxData the second array, whose values will be rearranged in parallel with the first array
   */
  public static void sort(double[] sortData, byte[] auxData) {
    quicksort(sortData, auxData, 0, sortData.length - 1);
  }

  /**
   * In-place sorts two parallel arrays in the natural order of elements of the first array.
   *
   * @param sortData the first array, whose values will determine the final sorted order
   * @param auxData the second array, whose values will be rearranged in parallel with the first array
   * @param left the starting index of the subarray to be sorted.  To sort the entire array, specify 0.
   * @param right the ending index, INCLUSIVE, of the subarray to be sorted.  To sort the entire array, specify
   *              sortData.length - 1
   */
  private static void quicksort(double[] sortData, byte[] auxData, int left, int right) {
    if (right <= left) {
      return;
    }

    // These exchanges are here to reduce both the runtime and the
    // stack usage (level of recursion) in degenerate cases such as
    // when the input is sorted or nearly sorted.
    exchange(sortData, auxData, (left + right) / 2, right - 1);
    compareExchange(sortData, auxData, left, right - 1);
    compareExchange(sortData, auxData, left, right);
    compareExchange(sortData, auxData, right - 1, right);

    if (right - 1 <= left) {
      return;
    }

    int i = partition(sortData, auxData, left + 1, right - 1);

    quicksort(sortData, auxData, left, i - 1);
    quicksort(sortData, auxData, i + 1, right);
  }

  private static int partition(double[] sortData, byte[] auxData, int left, int right) {
    int i = left - 1;
    int j = right;

    double sortVal = sortData[right];

    while (true) {
      while (sortData[++i] < sortVal) {
        // this space intentionally left blank
      }

      while (sortVal < sortData[--j]) {
        if (j == left) {
          break;
        }
      }

      if (i >= j) {
        break;
      }

      exchange(sortData, auxData, i, j);
    }

    exchange(sortData, auxData, i, right);
    return i;
  }

  private static void compareExchange(double[] sortData, byte[] auxData, int idxA, int idxB) {
    if (sortData[idxB] < sortData[idxA]) {
      exchange(sortData, auxData, idxA, idxB);
    }
  }

  private static void exchange(double[] sortData, byte[] auxData, int idxA, int idxB) {
    if (idxA == idxB) {
      return;
    }

    double tempSortVal = sortData[idxA];
    sortData[idxA] = sortData[idxB];
    sortData[idxB] = tempSortVal;

    byte tempAuxVal = auxData[idxA];
    auxData[idxA] = auxData[idxB];
    auxData[idxB] = tempAuxVal;
  }

  /**
   * Converts an array of doubles to an array of chars.
   *
   * This cast is "lossy" and may lose information.
   *
   * @param arr the array to convert
   * @return an array of chars cast from the provided array of doubles
   */
  public static char[] toCharactersLossy(double[] arr) {
    char[] res = new char[arr.length];
    for (int i = 0; i < res.length; i++) {
      res[i] = (char) arr[i];
    }

    return res;
  }

  /**
   * Converts an array of doubles to an array of chars, throwing an exception if the
   * converted values do not <i>exactly</i> match the originals (as determined by {@code !=}.)
   *
   * @param arr the array to convert
   * @return an array of chars cast from the provided array of doubles
   * @throws ArithmeticException if the array cannot be losslessly converted
   */
  public static char[] toCharactersExact(double[] arr) {
    char[] res = toCharactersLossy(arr);
    for (int i = 0; i < res.length; i++) {
      if (res[i] != arr[i]) {
        throw new ArithmeticException("Cannot losslessly convert provided double[] to char[] at index " + i + "; "
            + res[i] + " != " + arr[i]);
      }
    }

    return res;
  }

  /**
   * In-place sorts two parallel arrays in the natural order of elements of the first array.
   *
   * @param sortData the first array, whose values will determine the final sorted order
   * @param auxData the second array, whose values will be rearranged in parallel with the first array
   */
  public static void sort(double[] sortData, char[] auxData) {
    quicksort(sortData, auxData, 0, sortData.length - 1);
  }

  /**
   * In-place sorts two parallel arrays in the natural order of elements of the first array.
   *
   * @param sortData the first array, whose values will determine the final sorted order
   * @param auxData the second array, whose values will be rearranged in parallel with the first array
   * @param left the starting index of the subarray to be sorted.  To sort the entire array, specify 0.
   * @param right the ending index, INCLUSIVE, of the subarray to be sorted.  To sort the entire array, specify
   *              sortData.length - 1
   */
  private static void quicksort(double[] sortData, char[] auxData, int left, int right) {
    if (right <= left) {
      return;
    }

    // These exchanges are here to reduce both the runtime and the
    // stack usage (level of recursion) in degenerate cases such as
    // when the input is sorted or nearly sorted.
    exchange(sortData, auxData, (left + right) / 2, right - 1);
    compareExchange(sortData, auxData, left, right - 1);
    compareExchange(sortData, auxData, left, right);
    compareExchange(sortData, auxData, right - 1, right);

    if (right - 1 <= left) {
      return;
    }

    int i = partition(sortData, auxData, left + 1, right - 1);

    quicksort(sortData, auxData, left, i - 1);
    quicksort(sortData, auxData, i + 1, right);
  }

  private static int partition(double[] sortData, char[] auxData, int left, int right) {
    int i = left - 1;
    int j = right;

    double sortVal = sortData[right];

    while (true) {
      while (sortData[++i] < sortVal) {
        // this space intentionally left blank
      }

      while (sortVal < sortData[--j]) {
        if (j == left) {
          break;
        }
      }

      if (i >= j) {
        break;
      }

      exchange(sortData, auxData, i, j);
    }

    exchange(sortData, auxData, i, right);
    return i;
  }

  private static void compareExchange(double[] sortData, char[] auxData, int idxA, int idxB) {
    if (sortData[idxB] < sortData[idxA]) {
      exchange(sortData, auxData, idxA, idxB);
    }
  }

  private static void exchange(double[] sortData, char[] auxData, int idxA, int idxB) {
    if (idxA == idxB) {
      return;
    }

    double tempSortVal = sortData[idxA];
    sortData[idxA] = sortData[idxB];
    sortData[idxB] = tempSortVal;

    char tempAuxVal = auxData[idxA];
    auxData[idxA] = auxData[idxB];
    auxData[idxB] = tempAuxVal;
  }

  /**
   * Converts an array of doubles to an array of shorts.
   *
   * This cast is "lossy" and may lose information.
   *
   * @param arr the array to convert
   * @return an array of shorts cast from the provided array of doubles
   */
  public static short[] toShortsLossy(double[] arr) {
    short[] res = new short[arr.length];
    for (int i = 0; i < res.length; i++) {
      res[i] = (short) arr[i];
    }

    return res;
  }

  /**
   * Converts an array of doubles to an array of shorts, throwing an exception if the
   * converted values do not <i>exactly</i> match the originals (as determined by {@code !=}.)
   *
   * @param arr the array to convert
   * @return an array of shorts cast from the provided array of doubles
   * @throws ArithmeticException if the array cannot be losslessly converted
   */
  public static short[] toShortsExact(double[] arr) {
    short[] res = toShortsLossy(arr);
    for (int i = 0; i < res.length; i++) {
      if (res[i] != arr[i]) {
        throw new ArithmeticException("Cannot losslessly convert provided double[] to short[] at index " + i + "; "
            + res[i] + " != " + arr[i]);
      }
    }

    return res;
  }

  /**
   * In-place sorts two parallel arrays in the natural order of elements of the first array.
   *
   * @param sortData the first array, whose values will determine the final sorted order
   * @param auxData the second array, whose values will be rearranged in parallel with the first array
   */
  public static void sort(double[] sortData, short[] auxData) {
    quicksort(sortData, auxData, 0, sortData.length - 1);
  }

  /**
   * In-place sorts two parallel arrays in the natural order of elements of the first array.
   *
   * @param sortData the first array, whose values will determine the final sorted order
   * @param auxData the second array, whose values will be rearranged in parallel with the first array
   * @param left the starting index of the subarray to be sorted.  To sort the entire array, specify 0.
   * @param right the ending index, INCLUSIVE, of the subarray to be sorted.  To sort the entire array, specify
   *              sortData.length - 1
   */
  private static void quicksort(double[] sortData, short[] auxData, int left, int right) {
    if (right <= left) {
      return;
    }

    // These exchanges are here to reduce both the runtime and the
    // stack usage (level of recursion) in degenerate cases such as
    // when the input is sorted or nearly sorted.
    exchange(sortData, auxData, (left + right) / 2, right - 1);
    compareExchange(sortData, auxData, left, right - 1);
    compareExchange(sortData, auxData, left, right);
    compareExchange(sortData, auxData, right - 1, right);

    if (right - 1 <= left) {
      return;
    }

    int i = partition(sortData, auxData, left + 1, right - 1);

    quicksort(sortData, auxData, left, i - 1);
    quicksort(sortData, auxData, i + 1, right);
  }

  private static int partition(double[] sortData, short[] auxData, int left, int right) {
    int i = left - 1;
    int j = right;

    double sortVal = sortData[right];

    while (true) {
      while (sortData[++i] < sortVal) {
        // this space intentionally left blank
      }

      while (sortVal < sortData[--j]) {
        if (j == left) {
          break;
        }
      }

      if (i >= j) {
        break;
      }

      exchange(sortData, auxData, i, j);
    }

    exchange(sortData, auxData, i, right);
    return i;
  }

  private static void compareExchange(double[] sortData, short[] auxData, int idxA, int idxB) {
    if (sortData[idxB] < sortData[idxA]) {
      exchange(sortData, auxData, idxA, idxB);
    }
  }

  private static void exchange(double[] sortData, short[] auxData, int idxA, int idxB) {
    if (idxA == idxB) {
      return;
    }

    double tempSortVal = sortData[idxA];
    sortData[idxA] = sortData[idxB];
    sortData[idxB] = tempSortVal;

    short tempAuxVal = auxData[idxA];
    auxData[idxA] = auxData[idxB];
    auxData[idxB] = tempAuxVal;
  }

  /**
   * Converts an array of doubles to an array of ints.
   *
   * This cast is "lossy" and may lose information.
   *
   * @param arr the array to convert
   * @return an array of ints cast from the provided array of doubles
   */
  public static int[] toIntegersLossy(double[] arr) {
    int[] res = new int[arr.length];
    for (int i = 0; i < res.length; i++) {
      res[i] = (int) arr[i];
    }

    return res;
  }

  /**
   * Converts an array of doubles to an array of ints, throwing an exception if the
   * converted values do not <i>exactly</i> match the originals (as determined by {@code !=}.)
   *
   * @param arr the array to convert
   * @return an array of ints cast from the provided array of doubles
   * @throws ArithmeticException if the array cannot be losslessly converted
   */
  public static int[] toIntegersExact(double[] arr) {
    int[] res = toIntegersLossy(arr);
    for (int i = 0; i < res.length; i++) {
      if (res[i] != arr[i]) {
        throw new ArithmeticException("Cannot losslessly convert provided double[] to int[] at index " + i + "; "
            + res[i] + " != " + arr[i]);
      }
    }

    return res;
  }

  /**
   * In-place sorts two parallel arrays in the natural order of elements of the first array.
   *
   * @param sortData the first array, whose values will determine the final sorted order
   * @param auxData the second array, whose values will be rearranged in parallel with the first array
   */
  public static void sort(double[] sortData, int[] auxData) {
    quicksort(sortData, auxData, 0, sortData.length - 1);
  }

  /**
   * In-place sorts two parallel arrays in the natural order of elements of the first array.
   *
   * @param sortData the first array, whose values will determine the final sorted order
   * @param auxData the second array, whose values will be rearranged in parallel with the first array
   * @param left the starting index of the subarray to be sorted.  To sort the entire array, specify 0.
   * @param right the ending index, INCLUSIVE, of the subarray to be sorted.  To sort the entire array, specify
   *              sortData.length - 1
   */
  private static void quicksort(double[] sortData, int[] auxData, int left, int right) {
    if (right <= left) {
      return;
    }

    // These exchanges are here to reduce both the runtime and the
    // stack usage (level of recursion) in degenerate cases such as
    // when the input is sorted or nearly sorted.
    exchange(sortData, auxData, (left + right) / 2, right - 1);
    compareExchange(sortData, auxData, left, right - 1);
    compareExchange(sortData, auxData, left, right);
    compareExchange(sortData, auxData, right - 1, right);

    if (right - 1 <= left) {
      return;
    }

    int i = partition(sortData, auxData, left + 1, right - 1);

    quicksort(sortData, auxData, left, i - 1);
    quicksort(sortData, auxData, i + 1, right);
  }

  private static int partition(double[] sortData, int[] auxData, int left, int right) {
    int i = left - 1;
    int j = right;

    double sortVal = sortData[right];

    while (true) {
      while (sortData[++i] < sortVal) {
        // this space intentionally left blank
      }

      while (sortVal < sortData[--j]) {
        if (j == left) {
          break;
        }
      }

      if (i >= j) {
        break;
      }

      exchange(sortData, auxData, i, j);
    }

    exchange(sortData, auxData, i, right);
    return i;
  }

  private static void compareExchange(double[] sortData, int[] auxData, int idxA, int idxB) {
    if (sortData[idxB] < sortData[idxA]) {
      exchange(sortData, auxData, idxA, idxB);
    }
  }

  private static void exchange(double[] sortData, int[] auxData, int idxA, int idxB) {
    if (idxA == idxB) {
      return;
    }

    double tempSortVal = sortData[idxA];
    sortData[idxA] = sortData[idxB];
    sortData[idxB] = tempSortVal;

    int tempAuxVal = auxData[idxA];
    auxData[idxA] = auxData[idxB];
    auxData[idxB] = tempAuxVal;
  }

  /**
   * Converts an array of doubles to an array of longs.
   *
   * This cast is "lossy" and may lose information.
   *
   * @param arr the array to convert
   * @return an array of longs cast from the provided array of doubles
   */
  public static long[] toLongsLossy(double[] arr) {
    long[] res = new long[arr.length];
    for (int i = 0; i < res.length; i++) {
      res[i] = (long) arr[i];
    }

    return res;
  }

  /**
   * Converts an array of doubles to an array of longs, throwing an exception if the
   * converted values do not <i>exactly</i> match the originals (as determined by {@code !=}.)
   *
   * @param arr the array to convert
   * @return an array of longs cast from the provided array of doubles
   * @throws ArithmeticException if the array cannot be losslessly converted
   */
  public static long[] toLongsExact(double[] arr) {
    long[] res = toLongsLossy(arr);
    for (int i = 0; i < res.length; i++) {
      if (res[i] != arr[i]) {
        throw new ArithmeticException("Cannot losslessly convert provided double[] to long[] at index " + i + "; "
            + res[i] + " != " + arr[i]);
      }
    }

    return res;
  }

  /**
   * In-place sorts two parallel arrays in the natural order of elements of the first array.
   *
   * @param sortData the first array, whose values will determine the final sorted order
   * @param auxData the second array, whose values will be rearranged in parallel with the first array
   */
  public static void sort(double[] sortData, long[] auxData) {
    quicksort(sortData, auxData, 0, sortData.length - 1);
  }

  /**
   * In-place sorts two parallel arrays in the natural order of elements of the first array.
   *
   * @param sortData the first array, whose values will determine the final sorted order
   * @param auxData the second array, whose values will be rearranged in parallel with the first array
   * @param left the starting index of the subarray to be sorted.  To sort the entire array, specify 0.
   * @param right the ending index, INCLUSIVE, of the subarray to be sorted.  To sort the entire array, specify
   *              sortData.length - 1
   */
  private static void quicksort(double[] sortData, long[] auxData, int left, int right) {
    if (right <= left) {
      return;
    }

    // These exchanges are here to reduce both the runtime and the
    // stack usage (level of recursion) in degenerate cases such as
    // when the input is sorted or nearly sorted.
    exchange(sortData, auxData, (left + right) / 2, right - 1);
    compareExchange(sortData, auxData, left, right - 1);
    compareExchange(sortData, auxData, left, right);
    compareExchange(sortData, auxData, right - 1, right);

    if (right - 1 <= left) {
      return;
    }

    int i = partition(sortData, auxData, left + 1, right - 1);

    quicksort(sortData, auxData, left, i - 1);
    quicksort(sortData, auxData, i + 1, right);
  }

  private static int partition(double[] sortData, long[] auxData, int left, int right) {
    int i = left - 1;
    int j = right;

    double sortVal = sortData[right];

    while (true) {
      while (sortData[++i] < sortVal) {
        // this space intentionally left blank
      }

      while (sortVal < sortData[--j]) {
        if (j == left) {
          break;
        }
      }

      if (i >= j) {
        break;
      }

      exchange(sortData, auxData, i, j);
    }

    exchange(sortData, auxData, i, right);
    return i;
  }

  private static void compareExchange(double[] sortData, long[] auxData, int idxA, int idxB) {
    if (sortData[idxB] < sortData[idxA]) {
      exchange(sortData, auxData, idxA, idxB);
    }
  }

  private static void exchange(double[] sortData, long[] auxData, int idxA, int idxB) {
    if (idxA == idxB) {
      return;
    }

    double tempSortVal = sortData[idxA];
    sortData[idxA] = sortData[idxB];
    sortData[idxB] = tempSortVal;

    long tempAuxVal = auxData[idxA];
    auxData[idxA] = auxData[idxB];
    auxData[idxB] = tempAuxVal;
  }

  /**
   * Converts an array of doubles to an array of floats.
   *
   * This cast is "lossy" and may lose information.
   *
   * @param arr the array to convert
   * @return an array of floats cast from the provided array of doubles
   */
  public static float[] toFloatsLossy(double[] arr) {
    float[] res = new float[arr.length];
    for (int i = 0; i < res.length; i++) {
      res[i] = (float) arr[i];
    }

    return res;
  }

  /**
   * Converts an array of doubles to an array of floats, throwing an exception if the
   * converted values do not <i>exactly</i> match the originals (as determined by {@code !=}.)
   *
   * @param arr the array to convert
   * @return an array of floats cast from the provided array of doubles
   * @throws ArithmeticException if the array cannot be losslessly converted
   */
  public static float[] toFloatsExact(double[] arr) {
    float[] res = toFloatsLossy(arr);
    for (int i = 0; i < res.length; i++) {
      if (res[i] != arr[i]) {
        throw new ArithmeticException("Cannot losslessly convert provided double[] to float[] at index " + i + "; "
            + res[i] + " != " + arr[i]);
      }
    }

    return res;
  }

  /**
   * In-place sorts two parallel arrays in the natural order of elements of the first array.
   *
   * @param sortData the first array, whose values will determine the final sorted order
   * @param auxData the second array, whose values will be rearranged in parallel with the first array
   */
  public static void sort(double[] sortData, float[] auxData) {
    quicksort(sortData, auxData, 0, sortData.length - 1);
  }

  /**
   * In-place sorts two parallel arrays in the natural order of elements of the first array.
   *
   * @param sortData the first array, whose values will determine the final sorted order
   * @param auxData the second array, whose values will be rearranged in parallel with the first array
   * @param left the starting index of the subarray to be sorted.  To sort the entire array, specify 0.
   * @param right the ending index, INCLUSIVE, of the subarray to be sorted.  To sort the entire array, specify
   *              sortData.length - 1
   */
  private static void quicksort(double[] sortData, float[] auxData, int left, int right) {
    if (right <= left) {
      return;
    }

    // These exchanges are here to reduce both the runtime and the
    // stack usage (level of recursion) in degenerate cases such as
    // when the input is sorted or nearly sorted.
    exchange(sortData, auxData, (left + right) / 2, right - 1);
    compareExchange(sortData, auxData, left, right - 1);
    compareExchange(sortData, auxData, left, right);
    compareExchange(sortData, auxData, right - 1, right);

    if (right - 1 <= left) {
      return;
    }

    int i = partition(sortData, auxData, left + 1, right - 1);

    quicksort(sortData, auxData, left, i - 1);
    quicksort(sortData, auxData, i + 1, right);
  }

  private static int partition(double[] sortData, float[] auxData, int left, int right) {
    int i = left - 1;
    int j = right;

    double sortVal = sortData[right];

    while (true) {
      while (sortData[++i] < sortVal) {
        // this space intentionally left blank
      }

      while (sortVal < sortData[--j]) {
        if (j == left) {
          break;
        }
      }

      if (i >= j) {
        break;
      }

      exchange(sortData, auxData, i, j);
    }

    exchange(sortData, auxData, i, right);
    return i;
  }

  private static void compareExchange(double[] sortData, float[] auxData, int idxA, int idxB) {
    if (sortData[idxB] < sortData[idxA]) {
      exchange(sortData, auxData, idxA, idxB);
    }
  }

  private static void exchange(double[] sortData, float[] auxData, int idxA, int idxB) {
    if (idxA == idxB) {
      return;
    }

    double tempSortVal = sortData[idxA];
    sortData[idxA] = sortData[idxB];
    sortData[idxB] = tempSortVal;

    float tempAuxVal = auxData[idxA];
    auxData[idxA] = auxData[idxB];
    auxData[idxB] = tempAuxVal;
  }

  /**
   * In-place sorts two parallel arrays in the natural order of elements of the first array.
   *
   * @param sortData the first array, whose values will determine the final sorted order
   * @param auxData the second array, whose values will be rearranged in parallel with the first array
   */
  public static void sort(double[] sortData, double[] auxData) {
    quicksort(sortData, auxData, 0, sortData.length - 1);
  }

  /**
   * In-place sorts two parallel arrays in the natural order of elements of the first array.
   *
   * @param sortData the first array, whose values will determine the final sorted order
   * @param auxData the second array, whose values will be rearranged in parallel with the first array
   * @param left the starting index of the subarray to be sorted.  To sort the entire array, specify 0.
   * @param right the ending index, INCLUSIVE, of the subarray to be sorted.  To sort the entire array, specify
   *              sortData.length - 1
   */
  private static void quicksort(double[] sortData, double[] auxData, int left, int right) {
    if (right <= left) {
      return;
    }

    // These exchanges are here to reduce both the runtime and the
    // stack usage (level of recursion) in degenerate cases such as
    // when the input is sorted or nearly sorted.
    exchange(sortData, auxData, (left + right) / 2, right - 1);
    compareExchange(sortData, auxData, left, right - 1);
    compareExchange(sortData, auxData, left, right);
    compareExchange(sortData, auxData, right - 1, right);

    if (right - 1 <= left) {
      return;
    }

    int i = partition(sortData, auxData, left + 1, right - 1);

    quicksort(sortData, auxData, left, i - 1);
    quicksort(sortData, auxData, i + 1, right);
  }

  private static int partition(double[] sortData, double[] auxData, int left, int right) {
    int i = left - 1;
    int j = right;

    double sortVal = sortData[right];

    while (true) {
      while (sortData[++i] < sortVal) {
        // this space intentionally left blank
      }

      while (sortVal < sortData[--j]) {
        if (j == left) {
          break;
        }
      }

      if (i >= j) {
        break;
      }

      exchange(sortData, auxData, i, j);
    }

    exchange(sortData, auxData, i, right);
    return i;
  }

  private static void compareExchange(double[] sortData, double[] auxData, int idxA, int idxB) {
    if (sortData[idxB] < sortData[idxA]) {
      exchange(sortData, auxData, idxA, idxB);
    }
  }

  private static void exchange(double[] sortData, double[] auxData, int idxA, int idxB) {
    if (idxA == idxB) {
      return;
    }

    double tempSortVal = sortData[idxA];
    sortData[idxA] = sortData[idxB];
    sortData[idxB] = tempSortVal;

    double tempAuxVal = auxData[idxA];
    auxData[idxA] = auxData[idxB];
    auxData[idxB] = tempAuxVal;
  }

}
