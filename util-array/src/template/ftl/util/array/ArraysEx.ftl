<#import "../../common.ftl" as c />
<#import "common.ftl" as a />
<@c.AutoGeneratedWarning />

package com.linkedin.dagli.util.array;

import com.linkedin.dagli.util.closeable.Closeables;
import com.linkedin.dagli.util.invariant.Arguments;
import com.linkedin.dagli.util.collection.Iterables;
import java.lang.reflect.Array;
import java.util.Arrays;
import java.util.function.Function;
import java.util.function.IntFunction;
import java.util.Objects;
import java.util.function.Predicate;

<#list 1..a.maxType as typeIndex> <#-- start at 1 to omit Object -->
import it.unimi.dsi.fastutil.${a.primitiveType(typeIndex)?lower_case}s.${a.compositeTypeName(typeIndex)}ArrayList;
</#list>

/**
 * Utility methods for working with arrays.  These methods build on those provided by the {@link java.util.Arrays}
 * class.
 */
public abstract class ArraysEx {
  private ArraysEx() { }

  /**
   * Filters a range of elements in an array "in-place", according to a given {@code predicate}.
   *
   * After filtering, the {@code n} elements in the range for which {@code predicate} returned true will be placed
   * at the beginning of the range (starting at position {@code offset}) while the {@code count - n} elements in the
   * range will be replaced will {@code null}s.  The relative order of the kept items will remain the same.
   *
   * All elements outside the filtered range will be unmodified.
   *
   * @param array the array whose items should be filtered
   * @param startInclusive the first index of the range in {@code array} that should be filtered
   * @param endExclusive the end of the range (exclusive) in {@code array} to be filtered
   * @param predicate the predicate used to test whether an element should be kept
   * @return the number of elements in the range that were kept
   * @param <T> the type of element in the array
   */
  public static <T> int filterInPlace(T[] array, int startInclusive, int endExclusive, Predicate<? super T> predicate) {
    int nextDestination = startInclusive;
    for (int i = startInclusive; i < endExclusive; i++) {
      if (predicate.test(array[i])) {
        array[nextDestination++] = array[i];
      }
    }

    // fill remaining elements with nulls
    Arrays.fill(array, nextDestination, endExclusive, null);

    // return number of kept items
    return nextDestination - startInclusive;
  }

  /**
   * Copies a range of elements from a source array to a new array, possibly of a different type.  This method duplicates
   * the behavior of {@link Arrays#copyOfRange( Object[], int, int, Class)}; the difference between these methods is
   * that this method accepts an array generation function (typically the array's constructor) rather than an array
   * class.
   *
   * See {@link Arrays#copyOfRange( Object[], int, int, Class)} for more details.
   *
   * @param source the original array to copy
   * @param startInclusive where copying should begin in the source array
   * @param endExclusive where copying should end in the source array, exclusive (that is, elements at indices up to, but
   *                     not including, this index)
   * @param arrayConstructor a method that, given an array length, returns an array to receive the copied elements
   * @param <S> the element type of the source array
   * @param <T> the element type of the copy array
   * @return a (partial) copy of the provided array
   */
  public static <S extends T, T> T[] copyOfRange(S[] source, int startInclusive, int endExclusive,
      IntFunction<T[]> arrayConstructor) {
    Arguments.check(startInclusive <= endExclusive, "Start position cannot be later than the end");

    T[] result = arrayConstructor.apply(endExclusive - startInclusive);
    System.arraycopy(source, startInclusive, result, 0, Math.min(source.length - startInclusive, result.length));

    return result;
  }

  /**
   * Copies a the elements of a source array to a new array, possibly of a different type.  This method duplicates
   * the behavior of {@link Arrays#copyOf( Object[], int, Class)}; the difference between these methods is
   * that this method accepts an array generation function (typically the array's constructor) rather than an array
   * class.
   *
   * See {@link Arrays#copyOf( Object[], int, Class)} for more details.
   *
   * @param source the original array to copy
   * @param newLength the length of the result that will be returned (may be longer or shorter than <code>source</code>)
   * @param arrayConstructor a method that, given an array length, returns an array to receive the copied elements
   * @param <S> the element type of the source array
   * @param <T> the element type of the copy array
   * @return a copy of the provided array with the requested length
   */
  public static <S extends T, T> T[] copyOf(S[] source, int newLength, IntFunction<T[]> arrayConstructor) {
    return copyOfRange(source, 0, newLength, arrayConstructor);
  }

  /**
   * Analogous to {@link Arrays#deepToString(Object[])}, but computes the String representation for any type of object,
   * including Object arrays, primitive arrays, and non-arrays.
   */
  public static String deepToString(Object obj) {
    if (obj instanceof Object[]) {
      return Arrays.deepToString((Object[]) obj);
    }<#list 0..a.maxType as typeIndex><#if typeIndex != a.objectType> else if (obj instanceof ${a.primitiveType(typeIndex)}[]) {
      return Arrays.toString((${a.primitiveType(typeIndex)}[]) obj);
    }</#if></#list>

    return Objects.toString(obj);
  }

  /**
   * Concatenates one or more arrays.
   *
   * @param arrays one or more arrays to concatenate
   * @param <T> the type of the arrays
   * @return the concatenated array
   */
  @SafeVarargs
  @SuppressWarnings("unchecked") // we use reflection to create a result array of the right concrete type
  public static <T> T[] concat(T[]... arrays) {
    int size = 0;
    for (T[] arr : arrays) {
      size += arr.length;
    }

    T[] res = arrays.getClass().getComponentType().equals(Object[].class)
        ? (T[]) new Object[size]
        : (T[]) Array.newInstance(arrays.getClass().getComponentType().getComponentType(), size);

    int offset = 0;
    for (T[] arr : arrays) {
      System.arraycopy(arr, 0, res, offset, arr.length);
      offset += arr.length;
    }

    return res;
  }

  /**
   * Maps one array to another using a provided mapping function.
   *
   * Note that the same logic can be achieved via streams (Arrays.com.linkedin.dagli.util.stream(array).map(mapper).toArray()) but this method
   * is computationally cheaper.
   *
   * @param sourceArray the original array to map
   * @param targetArrayNew a function that creates a new array of a provided size; e.g. String[]::new
   * @param mapper a mapping function that transforms the original values
   * @param <S> the element type of the source array
   * @param <T> the element type of the target array
   * @return a new, transformed array of elements
   */
  public static <S, T> T[] mapArray(S[] sourceArray, IntFunction<T[]> targetArrayNew, Function<S, T> mapper) {
    T[] res = targetArrayNew.apply(sourceArray.length);
    for (int i = 0; i < sourceArray.length; i++) {
      res[i] = mapper.apply(sourceArray[i]);
    }

    return res;
  }

  <#list 0..a.maxType as typeIndex>
  <#assign boxedType = a.boxedType(typeIndex) />
  <#assign primitiveType = a.primitiveType(typeIndex) />

  // ---------------- Begin methods for ${boxedType}s ----------------

  /**
   * An instance of an empty ${primitiveType} array.  Using this instance rather than creating a new array each time an empty
   * array is needed avoids an unnecessary object creation.
   */
  public static final ${primitiveType}[] EMPTY_${boxedType?upper_case}_ARRAY = new ${primitiveType}[0];

  <#if typeIndex != a.objectType>
  /**
   * Concatenates one or more arrays.
   *
   * @param arrays one or more arrays to concatenate
   * @return the concatenated array
   */
  public static ${primitiveType}[] concat(${primitiveType}[]... arrays) {
    int size = 0;
    for (${primitiveType}[] arr : arrays) {
      size += arr.length;
    }

    ${primitiveType}[] res = new ${primitiveType}[size];

    int offset = 0;
    for (${primitiveType}[] arr : arrays) {
      System.arraycopy(arr, 0, res, offset, arr.length);
      offset += arr.length;
    }

    return res;
  }

  /**
   * Wraps an array as a {@link java.util.List} just as {@link Arrays#asList(Object[])} does for reference types.
   *
   * However, unlike the list returned by {@link Arrays#asList(Object[])}, the returned list may still grow (or shrink),
   * in which case its underlying array may cease to be the {@code wrapped} array (such that changes in one will cease
   * to induce changes in the other).
   *
   * @param wrapped the array to wrap; until the list size changes, it is guaranteed that changes to the elements of
   *                the array will affect the list wrapper, and vice-versa
   * @return a list that wraps the provided array
   */
  public static ${a.compositeTypeName(typeIndex)}ArrayList asList(${primitiveType}... wrapped) {
    return ${a.compositeTypeName(typeIndex)}ArrayList.wrap(wrapped);
  }
  </#if>

  /**
   * Transposes a "matrix" comprised of an array of arrays; each element array[i][j] will be copied to transposed[j][i].
   *
   * If the original array of arrays is "jagged" (with subarray "rows" of differing lengths), the width of the matrix
   * will be taken as the longest of its rows and any "missing" elements in shorter rows will treated as if they were
   * ${a.typeDefaultValue(typeIndex)}.
   *
   * @param matrix the array of arrays to transpose; the subarray "rows" do not need to be of uniform length
   * @return a new, transposed array of arrays such that each element {@code matrix[i][j]} will be copied to
   *         {@code transposed[j][i]}
   */
  public static ${primitiveType}[][] transpose(${primitiveType}[][] matrix) {
    // find the longest row in the matrix (its number of columns)--this will be our result matrix's width
    int newHeight = 0;
    for (${primitiveType}[] row : matrix) {
      newHeight = Math.max(newHeight, row.length);
    }

    ${primitiveType}[][] transposed = new ${primitiveType}[newHeight][matrix.length];
    for (int i = 0; i < matrix.length; i++) {
      ${primitiveType}[] row = matrix[i];
      for (int j = 0; j < row.length; j++) {
        transposed[j][i] = row[j];
      }
    }

    return transposed;
  }

  /**
   * Given a sorted array (either least to greatest or greatest to least), places all unique elements at the start of
   * the array (maintaining the original sort order and overwriting their original values) and returns the number of
   * unique elements.
   *
   * For example, if this method is called on the array [1, 2, 2, 2, 3, 3, 4], it will return 4 (the number of unique
   * elements) and the array will be modified to [1, 2, 3, 4, 3, 3, 4].  Note that only the first 4 elements of this
   * array have been changed.
   *
   * The time complexity of this method is O(n), where n is the length of the input array.
   *
   * @param array the sorted array to deduplicate
   * @return the number of unique elements in the provided array
   */
  public static int deduplicateSortedArray(${primitiveType}[] array) {
    // handle empty-array edge case
    if (array.length == 0) {
      return 0;
    }

    // look for duplicates and shift elements up to overwrite any that are found
    int shift = 0;
    for (int i = 1; i < array.length; i++) {
      if (<#if typeIndex == a.objectType>Objects.equals(array[i], array[i - 1])<#else>array[i] == array[i - 1]</#if>) {
        shift++;
      } else {
        array[i - shift] = array[i]; // if shift == 0 this is a noop
      }
    }

    return array.length - shift;
  }

  /**
   * Reverses the order of the elements of the array.
   *
   * @param array the array to be reversed
   */
  public static void reverse(${primitiveType}[] array) {
    for (int i = 0; i < array.length / 2; i++) {
      ${primitiveType} val = array[array.length - i - 1];
      array[array.length - i - 1] = array[i];
      array[i] = val;
    }
  }

  <#if a.typeIsNumeric(typeIndex)>
  /**
   * Returns true if the elements of the array are monotonically increasing (i.e. in natural order)
   *
   * @param array the array to be checked
   * @return true if the array is monotonically increasing, false otherwise
   */
  public static boolean isMonotonicallyIncreasing(${primitiveType}[] array) {
    if (array.length > 0) {
      ${primitiveType} previousElement = array[0];
      for (int i = 1; i < array.length; i++) {
        if (array[i] < previousElement) {
          return false;
        }
        previousElement = array[i];
      }
    }

    return true;
  }

  /**
   * Returns true if the elements of the array are monotonically decreasing (i.e. in reverse natural order)
   *
   * @param array the array to be checked
   * @return true if the array is monotonically decreasing, false otherwise
   */
  public static boolean isMonotonicallyDecreasing(${primitiveType}[] array) {
    if (array.length > 0) {
      ${primitiveType} previousElement = array[0];
      for (int i = 1; i < array.length; i++) {
        if (array[i] > previousElement) {
          return false;
        }
        previousElement = array[i];
      }
    }

    return true;
  }

  <#if a.typeIsNumber(typeIndex)>
  /**
   * Converts an {@link Iterable} of {@link Number}s to an array of ${primitiveType}s.
   *
   * This method is "lossy" because it does not know, a priori, the concrete types of the providers {@link Number}s,
   * and some information may be lost.  {@link Number#${primitiveType}Value()} is used to obtain the array values.
   *
   * A run-time exception will be thrown if the quantity of elements in the provided {@link Iterable} exceeds the
   * maximum array length on this JVM.
   *
   * @param numbers the numbers that should be converted into an array of ${primitiveType}s
   * @return an array of ${primitiveType}s, possibly subject to truncation or rounding
   */
  public static ${primitiveType}[] to${boxedType}sLossy(Iterable<? extends Number> numbers) {
    ${primitiveType}[] res = new ${primitiveType}[Math.toIntExact(Iterables.size64(numbers))];

    java.util.Iterator<? extends Number> iterator = numbers.iterator();
    try {
      for (int i = 0; i < res.length; i++) {
        res[i] = iterator.next().${primitiveType}Value();
      }
      return res;
    } finally {
      // properly close AutoCloseable iterators
      Closeables.tryClose(iterator);
    }
  }
  </#if>

  <#list 0..a.maxType as targetTypeIndex>
  <#assign targetPrimitiveType = a.primitiveType(targetTypeIndex) />

  <#if a.typeIsNumeric(targetTypeIndex) && targetTypeIndex != typeIndex>
  /**
   * Converts an array of ${primitiveType}s to an array of ${targetPrimitiveType}s.
   *
   * <#if a.canLosslesslyConvert(typeIndex, targetTypeIndex)>This cast is lossless (no loss of information).<#else>This cast is "lossy" and may lose information.</#if>
   *
   * @param arr the array to convert
   * @return an array of ${targetPrimitiveType}s cast from the provided array of ${primitiveType}s
   */
  public static ${targetPrimitiveType}[] to${a.boxedType(targetTypeIndex)}s<#if !a.canLosslesslyConvert(typeIndex, targetTypeIndex)>Lossy</#if>(${primitiveType}[] arr) {
    ${targetPrimitiveType}[] res = new ${targetPrimitiveType}[arr.length];
    for (int i = 0; i < res.length; i++) {
      res[i] = <#if a.needsExplicitCast(typeIndex, targetTypeIndex)>(${targetPrimitiveType}) </#if>arr[i];
    }

    return res;
  }

  <#if !a.canLosslesslyConvert(typeIndex, targetTypeIndex)>
  /**
   * Converts an array of ${primitiveType}s to an array of ${targetPrimitiveType}s, throwing an exception if the
   * converted values do not <i>exactly</i> match the originals (as determined by {@code !=}.)
   *
   * @param arr the array to convert
   * @return an array of ${targetPrimitiveType}s cast from the provided array of ${primitiveType}s
   * @throws ArithmeticException if the array cannot be losslessly converted
   */
  public static ${targetPrimitiveType}[] to${a.boxedType(targetTypeIndex)}sExact(${primitiveType}[] arr) {
    ${targetPrimitiveType}[] res = to${a.boxedType(targetTypeIndex)}sLossy(arr);
    for (int i = 0; i < res.length; i++) {
      if (res[i] != arr[i]) {
        throw new ArithmeticException("Cannot losslessly convert provided ${primitiveType}[] to ${targetPrimitiveType}[] at index " + i + "; " + res[i] + " != " + arr[i]);
      }
    }

    return res;
  }
  </#if> <#-- !canLosslesslyConvert -->

  </#if> <#-- targetTypeIndex is numeric -->

  /**
   * In-place sorts two parallel arrays in the natural order of elements of the first array.
   *
   * @param sortData the first array, whose values will determine the final sorted order
   * @param auxData the second array, whose values will be rearranged in parallel with the first array
   */
  public static void sort(${primitiveType}[] sortData, ${targetPrimitiveType}[] auxData) {
    quicksort(sortData, auxData, 0, sortData.length - 1);
  }

  /**
   * In-place sorts two parallel arrays in the natural order of elements of the first array.
   *
   * @param sortData the first array, whose values will determine the final sorted order
   * @param auxData the second array, whose values will be rearranged in parallel with the first array
   * @param left the starting index of the subarray to be sorted.  To sort the entire array, specify 0.
   * @param right the ending index, INCLUSIVE, of the subarray to be sorted.  To sort the entire array, specify
   *              sortData.length - 1
   */
  private static void quicksort(${primitiveType}[] sortData, ${targetPrimitiveType}[] auxData, int left, int right) {
    if (right <= left) {
      return;
    }

    // These exchanges are here to reduce both the runtime and the
    // stack usage (level of recursion) in degenerate cases such as
    // when the input is sorted or nearly sorted.
    exchange(sortData, auxData, (left + right) / 2, right - 1);
    compareExchange(sortData, auxData, left, right - 1);
    compareExchange(sortData, auxData, left, right);
    compareExchange(sortData, auxData, right - 1, right);

    if (right - 1 <= left) {
      return;
    }

    int i = partition(sortData, auxData, left + 1, right - 1);

    quicksort(sortData, auxData, left, i - 1);
    quicksort(sortData, auxData, i + 1, right);
  }

  private static int partition(${primitiveType}[] sortData, ${targetPrimitiveType}[] auxData, int left, int right) {
    int i = left - 1;
    int j = right;

    ${primitiveType} sortVal = sortData[right];

    while (true) {
      while (sortData[++i] < sortVal) {
        // this space intentionally left blank
      }

      while (sortVal < sortData[--j]) {
        if (j == left) {
          break;
        }
      }

      if (i >= j) {
        break;
      }

      exchange(sortData, auxData, i, j);
    }

    exchange(sortData, auxData, i, right);
    return i;
  }

  private static void compareExchange(${primitiveType}[] sortData, ${targetPrimitiveType}[] auxData, int idxA, int idxB) {
    if (sortData[idxB] < sortData[idxA]) {
      exchange(sortData, auxData, idxA, idxB);
    }
  }

  private static void exchange(${primitiveType}[] sortData, ${targetPrimitiveType}[] auxData, int idxA, int idxB) {
    if (idxA == idxB) {
      return;
    }

    ${primitiveType} tempSortVal = sortData[idxA];
    sortData[idxA] = sortData[idxB];
    sortData[idxB] = tempSortVal;

    ${targetPrimitiveType} tempAuxVal = auxData[idxA];
    auxData[idxA] = auxData[idxB];
    auxData[idxB] = tempAuxVal;
  }
  </#list> <#-- iteration over "target" types -->

  </#if> <#-- typeIndex is numeric -->

  </#list> <#-- iteration over typeIndex values -->
}
