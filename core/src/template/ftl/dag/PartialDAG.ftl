<#import "../common.ftl" as c />
<@c.AutoGeneratedWarning />
package com.linkedin.dagli.dag;

import java.util.Arrays;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import com.linkedin.dagli.producer.MissingInput;
import com.linkedin.dagli.producer.Producer;
import com.linkedin.dagli.placeholder.Placeholder;
import com.linkedin.dagli.reducer.Reducer;
import com.linkedin.dagli.util.cloneable.AbstractCloneable;

<#macro OutputProducerArguments count name="output">
  <@compress single_line=true>
    <#list 1..count as index>Producer<? extends ${c.ResultGenericArgument(index)}> ${name}${c.InputSuffix(index)}<#sep>, </#list>
  </@compress>
</#macro>

<#macro InputProducerArguments count name="output">
  <@compress single_line=true>
    <#list 1..count as index>Producer<? extends ${c.InputGenericArgument(index)}> ${name}${c.InputSuffix(index)}<#sep>, </#list>
  </@compress>
</#macro>

<#macro WithPlaceholders placeholderArity>
  <@compress single_line=true>
  WithPlaceholders${placeholderArity}<<@c.InputGenericArguments placeholderArity />>
  </@compress>
</#macro>

<#macro AbstractWithPlaceholders placeholderArity S>
  <@compress single_line=true>
  AbstractWithPlaceholders${placeholderArity}<<@c.InputGenericArguments placeholderArity />, ${S}>
  </@compress>
</#macro>

<#macro WithOutputs placeholderArity outputArity>
  <@compress single_line=true>
  WithOutputs${placeholderArity}x${outputArity}<<@c.InputGenericArguments placeholderArity />, <@c.ResultGenericArguments outputArity />>
  </@compress>
</#macro>

<#macro WithOutputsMethod placeholderArity outputArity preparedDAG forceSingular=false>
    /**
     * Creates a completed DAG by supplying this partial DAG with its outputs (outputs).
     *
     <#list 1..outputArity as outputIndex>
     * @param output${c.InputSuffix(outputIndex)} the ${c.positionNames[outputIndex]} output (output) of the DAG
     </#list>
     <@c.Indent 2><@c.GenericResultTypesJavadoc outputArity /></@c.Indent>
     * @return a completed DAG with ${placeholderArity} input<@c.s placeholderArity /> (placeholders) and ${outputArity} output<@c.s outputArity /> (outputs).
     */
    public <<@c.ResultGenericArguments outputArity />> <#if preparedDAG><@c.PreparedDAG placeholderArity outputArity /><#else><@c.DAG placeholderArity outputArity /></#if> withOutput<#if !forceSingular>s</#if>(<@OutputProducerArguments outputArity "output" />) {
      <#list 1..outputArity as index>
      Objects.requireNonNull(output${c.InputSuffix(index)}, "Output ${c.InputSuffix(index)} may not be null");
      </#list>

      if (_shouldRemapInputs) {
        Map<Producer<?>, Producer<?>> inputMapping = DAGUtil.createInputMap(<#list 1..placeholderArity as index>_input${c.InputSuffix(index)}, _placeholder${c.InputSuffix(index)}<#sep>, </#list>);
        <#list 1..outputArity as index>
        output${c.InputSuffix(index)} = DAGUtil.replaceInputs(output${c.InputSuffix(index)}, inputMapping);
        </#list>
      }

      List<Producer<?>> inputs = Arrays.asList(<#list 1..placeholderArity as index>_input${c.InputSuffix(index)}<#sep>, </#list>);

      return ((<#if preparedDAG><@c.PreparedDAGClassName placeholderArity outputArity /><#else><@c.DAGClassName placeholderArity outputArity /></#if>)
        DAGUtil.create<#if preparedDAG>Prepared<#else>Preparable</#if>DAG(Arrays.asList(<@c.InputSuffixedList "_placeholder" placeholderArity />), Arrays.asList(<@c.InputSuffixedList "output" outputArity />)<#if preparedDAG></#if>).internalAPI().withInputsUnsafe(inputs)).withReduction(_minimumReducerLevel);
    }
    <#-- Add singular "withOutput(...) method, too --->
    <#if outputArity == 1 && !forceSingular><@WithOutputsMethod placeholderArity outputArity preparedDAG true /></#if>
</#macro>

<#macro WithOutputsMethods placeholderArity preparedDAG>
<#list 1..c.maxArity as outputArity>
<@WithOutputsMethod placeholderArity outputArity preparedDAG />
</#list>
</#macro>

<#macro WithPlaceholdersClassJavadoc placeholderArity>
/**
  * A partial DAG with ${placeholderArity} placeholder.  Partial DAGs are <i>completed</i> to create a usable DAG by specifying
  * the outputs (<i>outputs</i>) of the DAG using the withOutputs(...) methods.
  *
  <@c.GenericInputTypesJavadoc placeholderArity />
  */
</#macro>

<#macro WithPlaceholdersConstructorJavadoc placeholderArity>
/**
 * Creates a new partial DAG that will be rooted at the provided placeholders.
 *
 <#list 1..placeholderArity as index>
 * @param placeholder${c.InputSuffix(index)} the ${c.positionNames[index]} placeholder
 </#list>
 */
</#macro>

<#macro WithPlaceholdersConstructorWithInputsJavadoc placeholderArity>
/**
 * Creates a new partial DAG that will be rooted at the provided placeholders, which will replace ("remap") the provided
 * "input" nodes that define a subgraph of the original graph (as defined by the ancestors of the outputs that will
 * be provided when the partial DAG is completed).  The input nodes, and any nodes that were exclusively the
 * ancestors of the input nodes, are truncated from the resulting graph.
 *
 <#list 1..placeholderArity as index>
 * @param placeholder${c.InputSuffix(index)} the ${c.positionNames[index]} placeholder
 </#list>
 <#list 1..placeholderArity as index>
 * @param input${c.InputSuffix(index)} the ${c.positionNames[index]} input
 </#list>
 */
</#macro>

/**
 * PartialDAGs are an intermediate step when building a DAG with methods like DAG.withPlaceholders(...).  Such methods return
 * a PartialDAG.WithPlaceholdersX instance on which you may then specify the outputs using .withOutputs(...) to get a fully-
 * typed DAG.  You would not ordinarily instantiate or even store a PartialDAG.WithPlaceholdersX class in client code; it is
 * normally a short-lived intermediate value in the aforementioned invocation chain to get a (real) DAGXxY object.
 */
public class PartialDAG {
  private PartialDAG() { }

  <#list 1..c.maxArity as placeholderArity>
  <#assign subclass>S extends <@AbstractWithPlaceholders placeholderArity "S" /></#assign>
  /**
   * The abstract base class of a partial DAG with ${placeholderArity} placeholder<@c.s placeholderArity />.  A base class is used to allow the prepared and
   * preparable {@link Prepared.WithPlaceholders${placeholderArity}} and {@link WithPlaceholders${placeholderArity}} to share their common logic.
   *
   <@c.Indent 1><@c.GenericInputTypesJavadoc placeholderArity /></@c.Indent>
   * @param <S> the derived type ({@link Prepared.WithPlaceholders${placeholderArity}} or {@link WithPlaceholders${placeholderArity}})
   */
  private static class <@AbstractWithPlaceholders placeholderArity subclass /> extends AbstractCloneable<S> {
    <#list 1..placeholderArity as index>
    final Placeholder<? extends ${c.InputGenericArgument(index)}> _placeholder${c.InputSuffix(index)};
    </#list>
    <#list 1..placeholderArity as index>
    final Producer<? extends ${c.InputGenericArgument(index)}> _input${c.InputSuffix(index)};
    </#list>
    boolean _shouldRemapInputs; // true iff inputs were provided (which will be remapped to the provided placeholders)
    Reducer.Level _minimumReducerLevel = Reducer.Level.NORMAL;

    <@c.Indent 2><@WithPlaceholdersConstructorJavadoc placeholderArity /></@c.Indent>
    AbstractWithPlaceholders${placeholderArity}(<@c.ValuesArguments "Placeholder" placeholderArity "placeholder" />) {
      this(<#list 1..placeholderArity as index>placeholder${c.InputSuffix(index)}<#sep>, </#list>,
           <#list 1..placeholderArity as index>MissingInput.get()<#sep>, </#list>);
      _shouldRemapInputs = false;
    }

    <@c.Indent 2><@WithPlaceholdersConstructorWithInputsJavadoc placeholderArity /></@c.Indent>
    AbstractWithPlaceholders${placeholderArity}(<@c.ValuesArguments "Placeholder" placeholderArity "placeholder" />, <@InputProducerArguments placeholderArity "input" />) {
      <#list 1..placeholderArity as index>
      _placeholder${c.InputSuffix(index)} = Objects.requireNonNull(placeholder${c.InputSuffix(index)}, "Placeholder ${c.InputSuffix(index)} may not be null");
      </#list>
      <#list 1..placeholderArity as index>
      _input${c.InputSuffix(index)} = Objects.requireNonNull(input${c.InputSuffix(index)}, "Input ${c.InputSuffix(index)} may not be null");
      </#list>
      _shouldRemapInputs = true;
    }

    /**
     * The created DAG will not be reduced if this method if invoked.
     *
     * DAG reduction can greatly speed up execution of a DAG, but can be relatively expensive.  Disabling reduction may
     * be useful for debugging or in corner cases where large DAGs are being very frequently created and applied to
     * small numbers of examples.
     *
     * @return a copy of the partial DAG that will not use reductions
     */
    public S withNoReduction() {
      return clone(c -> c._minimumReducerLevel = null);
    }

    /**
     * The created DAG will execute reductions that meet the minimum level specified.
     *
     * The default reduction level is {@link Reducer.Level#NORMAL}.  It may be possible to speed up DAG reduction by
     * using only the most critical reducers by passing {@link Reducer.Level#ESSENTIAL}; conversely, when reduction
     * speed is unimportant, {@link Reducer.Level#EXPENSIVE} may be used.
     *
     * @param minimumReducerLevel the minimum level of reducers that should be run
     * @return a copy of this partial DAG that will use reducers at or above the given level
     */
    public S withReduction(Reducer.Level minimumReducerLevel) {
      return clone(c -> c._minimumReducerLevel = minimumReducerLevel);
    }
  }
  </#list>

  <#list 1..c.maxArity as placeholderArity>
  <#assign subclass><@WithPlaceholders placeholderArity /></#assign>

  <@c.Indent 1><@WithPlaceholdersClassJavadoc placeholderArity /></@c.Indent>
  public static class <@WithPlaceholders placeholderArity /> extends <@AbstractWithPlaceholders placeholderArity subclass /> {
    <@c.Indent 2><@WithPlaceholdersConstructorJavadoc placeholderArity /></@c.Indent>
    WithPlaceholders${placeholderArity}(<@c.ValuesArguments "Placeholder" placeholderArity "placeholder" />) {
      super(<@c.InputSuffixedList "placeholder" placeholderArity />);
    }

    <@c.Indent 2><@WithPlaceholdersConstructorWithInputsJavadoc placeholderArity /></@c.Indent>
    WithPlaceholders${placeholderArity}(<@c.ValuesArguments "Placeholder" placeholderArity "placeholder" />, <@InputProducerArguments placeholderArity "input" />) {
      super(<@c.InputSuffixedList "placeholder" placeholderArity />, <@c.InputSuffixedList "input" placeholderArity />);
    }

    <@WithOutputsMethods placeholderArity false />
  }
  </#list>

  /**
   * The {@link Prepared} class hosts internal classes (mirroring those in the parent {@link PartialDAG} class) used to
   * build DAGs.
   */
  public static class Prepared {
    private Prepared() { }

    <#list 1..c.maxArity as placeholderArity>
    <#assign subclass><@WithPlaceholders placeholderArity /></#assign>
    <@c.Indent 2><@WithPlaceholdersClassJavadoc placeholderArity /></@c.Indent>
    public static class <@WithPlaceholders placeholderArity /> extends <@AbstractWithPlaceholders placeholderArity subclass /> {
      <@c.Indent 3><@WithPlaceholdersConstructorJavadoc placeholderArity /></@c.Indent>
      WithPlaceholders${placeholderArity}(<@c.ValuesArguments "Placeholder" placeholderArity "placeholder" />) {
        super(<@c.InputSuffixedList "placeholder" placeholderArity />);
      }

      <@c.Indent 3><@WithPlaceholdersConstructorWithInputsJavadoc placeholderArity /></@c.Indent>
      WithPlaceholders${placeholderArity}(<@c.ValuesArguments "Placeholder" placeholderArity "placeholder" />, <@InputProducerArguments placeholderArity "input" />) {
        super(<@c.InputSuffixedList "placeholder" placeholderArity />, <@c.InputSuffixedList "input" placeholderArity />);
      }

      <@WithOutputsMethods placeholderArity true />
    }
    </#list>
  }
}
