<#import "../common.ftl" as c />
<@c.AutoGeneratedWarning />
package com.linkedin.dagli.dag;

import java.util.Collection;
import java.util.Collections;

import com.linkedin.dagli.annotation.equality.IgnoredByValueEquality;
import com.linkedin.dagli.annotation.equality.ValueEquality;
import com.linkedin.dagli.objectio.ObjectIterator;
import com.linkedin.dagli.objectio.ObjectReader;
import com.linkedin.dagli.preparer.Preparer${arity};
import com.linkedin.dagli.preparer.AbstractBatchPreparer${arity};
import com.linkedin.dagli.preparer.PreparerContext;
import com.linkedin.dagli.preparer.PreparerResultMixed;
import com.linkedin.dagli.producer.Producer;
import com.linkedin.dagli.reducer.Reducer;
import com.linkedin.dagli.transformer.AbstractPreparableTransformer${arity};
import com.linkedin.dagli.transformer.AbstractPreparedTransformer${arity};
import com.linkedin.dagli.transformer.PreparedTransformer${arity};
import com.linkedin.dagli.util.array.AutoCloseableArray;

<#if (arity > 1)>
import com.linkedin.dagli.generator.Generator;
import com.linkedin.dagli.placeholder.Placeholder;
</#if>

<#if (resultArity >= 2)>
import com.linkedin.dagli.tuple.${c.tuples[resultArity]};
</#if>
<#if (arity >= 2 && arity != resultArity)>
import com.linkedin.dagli.tuple.${c.tuples[arity]};
</#if>

<#if (resultArity > 1 && arity > 1)>
  <#list 1..resultArity as resultIndex>
import com.linkedin.dagli.transformer.Value${resultIndex-1}FromTuple;
  </#list>
</#if>

<#macro AbstractPreparable>AbstractPreparableTransformer${arity}<<@c.InputGenericArguments arity />, <@c.ResultTuple resultArity />, <@c.PreparedDAG arity resultArity />, <@c.DAG arity resultArity />></#macro>
<#macro AbstractPrepared>AbstractPreparedTransformer${arity}<<@c.InputGenericArguments arity />, <@c.ResultTuple resultArity />, <@c.PreparedDAG arity resultArity />></#macro>

<#-- Use a macro for this Javadoc blurb to avoid repeating in multiple times -->
<#macro InputSequencesJavadocBlurb>
 * The inputs to this method take the form of parallel sequences of values.  Each sequence will provide the values
 * for a particular {@link com.linkedin.dagli.placeholder.Placeholder} in the DAG (the ordering of the
 * {@link com.linkedin.dagli.placeholder.Placeholder}s in a DAG is determined by their
 * ordering in the call to "DAG.withPlaceholders(...)...." that created it).  They are "parallel" because, e.g. all the
 * values corresponding to the fourth example will be the fourth value in their respective input sequences (all
 * sequences must, of course, be equal in size).
</#macro>

<#-- Javadoc for the prepareAndApply(...) methods -->
<#macro PrepareAndApplyJavadoc arity>
/**
 * Prepares (trains) the DAG on the provided input data (examples), and applies it to this same data.  The returned
 * {@link Result} instance contains both the prepared DAG as well as the results from applying the DAG on the
 * preparation data.
 *
 <@InputSequencesJavadocBlurb />
 *
 * Note that the results from applying the DAG to the preparation data with this method are not necessarily the same
 * results that would be obtained from calling the apply(...) method on prepared DAG with the same data.  This is
 * because certain transformers (e.g. KFoldCrossTrained and PreparedByGroup) intentionally transform training data in
 * a different way than inference data.  Please see the documentation of these transformers for details.
 *
 <#list 1..arity as index>
 * @param values${c.InputSuffix(index)} the sequence of values for the ${c.positionNames[index]}
 * {@link com.linkedin.dagli.placeholder.Placeholder} in the DAG.
 </#list>
 * @return a {@link Result} instance containing both the prepared DAG and the result of applying the DAG on the
 *         preparation data
 */
</#macro>

<#-- Javadoc for the prepare(...) methods -->
<#macro PrepareJavadoc arity>
/**
 * Prepares (trains) the DAG on the provided input data (examples).  The resultant prepared (trained) DAG can then be
 * applied to new examples (inference).
 *
 <@InputSequencesJavadocBlurb />
 *
 <#list 1..arity as index>
 * @param values${c.InputSuffix(index)} the sequence of values for the ${c.positionNames[index]}
 * {@link com.linkedin.dagli.placeholder.Placeholder} in the DAG.
 </#list>
 * @return a prepared (trained) DAG that can be applied to new examples (inference)
 */
</#macro>

<#macro ApplyAllJavadoc arity>
/**
 * Applies the DAG to the provided input data (examples), running the model on the data and producing the results as a
 * {@link Result} instance.
 *
 <@InputSequencesJavadocBlurb />
 *
 <#list 1..arity as index>
 * @param values${c.InputSuffix(index)} the sequence of values for the ${c.positionNames[index]}
 * {@link com.linkedin.dagli.placeholder.Placeholder} in the DAG.
 </#list>
 * @return a {@link Result} instance containing the results of applying the DAG on the provided data
 */
</#macro>

<#macro MaybePreparedDAG prepared><#if prepared><@c.PreparedDAG arity resultArity /><#else><@c.DAG arity resultArity /></#if></#macro>

<#macro CommonMethods prepared>

  /**
   * Returns a DAG derived from this one that has been reduced to at least the specified level.
   *
   * If level is less than this DAG's current reduction level, {@code this} DAG is returned.
   *
   * Otherwise, this DAG is reduced, and the new, reduced DAG is returned.
   *
   * @param level the level of reduction desired; all reducers at or above this level will be applied
   * @return a DAG that has been reduced to at least the specified level (possibly this same DAG)
   */
  @Override
  public <@MaybePreparedDAG prepared /> withReduction(Reducer.Level level) {
    if (Reducer.Level.compare(level, _reductionLevel) >= 0) {
      return this;
    }

    DeduplicatedDAG reduced = DAGReducer.reduce(new DeduplicatedDAG(_dag), level);
    return clone(c -> {
      c._dag = new DAGStructure<>(reduced);
      c._reductionLevel = level;
    });
  }

  @Override
  public InternalAPI internalAPI() {
   return new InternalAPI();
  }

  public class InternalAPI extends <#if prepared><@AbstractPrepared /><#else><@AbstractPreparable /></#if>.InternalAPI implements <#if prepared>Prepared<#else>Preparable</#if>DAGTransformer.InternalAPI<<@c.ResultTuple resultArity />, <#if !prepared><@c.PreparedDAG arity, resultArity />, </#if><@MaybePreparedDAG prepared />> {
    @Override
    public DAGStructure<<@c.ResultTuple resultArity />> getDAGStructure() {
      return _dag;
    }

    @Override
    public Reducer.Level getReductionLevel() {
      return _reductionLevel;
    }

    @Override
    public <#if prepared>Prepared</#if>DAGExecutor getDAGExecutor() {
      return _executor;
    }

    @Override
    public <@MaybePreparedDAG prepared /> getInstance() {
      return DAG${arity}x${resultArity}<#if prepared>.Prepared</#if>.this;
    }
  }

  @Override
  protected Collection<? extends Reducer<? super <@MaybePreparedDAG prepared />>> getGraphReducers() {
    return Collections.singletonList(DAGTransformerReducer.INSTANCE);
  }

  @Override
  protected boolean hasAlwaysConstantResult() {
    return _dag._isAlwaysConstant;
  }

  /**
   * Returns a copy of this DAG that will use the given {@link <#if prepared>Prepared</#if>DAGExecutor} that will be used to execute this DAG.
<#if !prepared>   *
   * This executor will also be "inherited" by the resultant prepared DAG.</#if>
   *
   * @param executor the {@link DAGExecutor} to use
   * @return a copy of this instance that will use the provided executor
   */
  public <@MaybePreparedDAG prepared /> withExecutor(<#if prepared>Prepared</#if>DAGExecutor executor) {
    return clone(r -> r._executor = executor);
  }
</#macro>

/**
 * DAGs, directed acyclic graphs, contain root nodes ({@link com.linkedin.dagli.placeholder.Placeholder}s and {@link com.linkedin.dagli.generator.Generator}s) and child nodes
 * ({@link com.linkedin.dagli.transformer.PreparedTransformer}s,
 * {@link com.linkedin.dagli.transformer.PreparableTransformer}s, and {@link com.linkedin.dagli.view.TransformerView}s).
 *
 * DAG${arity}x${resultArity} is a <i>preparable</i> DAG.
 *
 * Before it can be used to transform new examples, it must be prepared with training data (e.g. by calling the
 * prepare() method).  The prepareAndApply() method both trains the DAG and applies it to the training data, yielding
 * both the prepared DAG and the results of applying the DAG to the training data (this can be useful in autoevaluation,
 * e.g. how well a classification model performs when predicting labels for its own training data).
 *
 * DAG${arity}x${resultArity} is also a {@link com.linkedin.dagli.transformer.PreparableTransformer} and can be used as
 * a transformer within other DAGs.
 *
 <@c.GenericInputTypesJavadoc arity />
 <@c.GenericResultTypesJavadoc resultArity />
 */
@ValueEquality
public class <@c.DAG arity resultArity /> extends <@AbstractPreparable /> implements PreparableDAGTransformer<<@c.ResultTuple resultArity />, <@c.PreparedDAG arity resultArity />, <@c.DAG arity resultArity />> {

  private static final long serialVersionUID = 1;

  // the DAGStructure stores the actual graph
  private DAGStructure<<@c.ResultTuple resultArity />> _dag;

  // keep track of what level of reduction we used to construct this DAG; this will be carried over to the prepared DAG
  @IgnoredByValueEquality // irrelevant given _dag and not (directly) externally observable
  private Reducer.Level _reductionLevel = null; // null -> no reductions applied

  // remember what executor should be used to prepare the DAG; this will also be "inherited" by the prepared DAG and
  // used for inference
  @IgnoredByValueEquality // not a factor in the semantics of the DAG and not (directly) externally observable
  private DAGExecutor _executor;

  /**
   * Creates a new DAG instance from the specified {@link DAGStructure} graph with the specified input<@c.s arity />.  DAG objects
   * have inputs because they can also serve as transformers within other DAGs.  In the common case where the DAG is
   * used directly and not embedded within another DAG, these inputs don't matter (and can simply be left as
   * {@link com.linkedin.dagli.producer.MissingInput}s).
   *
   * By default, this DAG will use a {@link LocalDAGExecutor}; to use a different executor, use the
   * {@link #withExecutor(DAGExecutor)} method.  When this DAG is prepared, the DAG executor will be "inherited" by the
   * resultant prepared DAG.
   *
   * @param dag the {@link DAGStructure} representing the actual graph of nodes and directed (parent/child) edges
   <@c.Indent><@c.TransformerInputsJavadoc arity /></@c.Indent>
   */
  DAG${arity}x${resultArity}(DAGStructure<<@c.ResultTuple resultArity />> dag, <@c.InputProducerList arity />) {
    super(<@c.InputSuffixedList "input" arity />);
    _dag = dag;
    _executor = new LocalDAGExecutor();
  }

  <@CommonMethods false />

  @Override
  protected boolean hasIdempotentPreparer() {
    return _dag._hasIdempotentPreparer;
  }

  <@c.TransformerWithInputsJavadoc arity />
  public <@c.DAG arity resultArity /> withInput<@c.s arity />(<@c.InputProducerList arity />) {
    return super.withAllInputs(<@c.InputSuffixedList "input" arity />);
  }

  <@c.Indent 1><@c.WithGeneratorAsInput false arity resultArity /></@c.Indent>

  /**
   * The {@link com.linkedin.dagli.preparer.Preparer} that prepares (trains) the DAG.
   *
   <@c.Indent 1>
   <@c.GenericInputTypesJavadoc arity />
   <@c.GenericResultTypesJavadoc resultArity />
   </@c.Indent>
   */
  private static class Preparer<<@c.InputGenericArguments arity />, <@c.ResultGenericArguments resultArity />> extends AbstractBatchPreparer${arity}<<@c.InputGenericArguments arity />, <@c.ResultTuple resultArity />, <@c.PreparedDAG arity resultArity />> {
    // the DAG being prepared
    private final <@c.DAG arity resultArity /> _dag;

    /**
     * Creates a new instance.
     *
     * @param dag the DAG that will be prepared
     */
    Preparer(<@c.DAG arity resultArity /> dag) {
      _dag = dag;
    }

    @Override
    @SuppressWarnings("unchecked") // we know the returned type is correct by the semantics of executors
    public PreparerResultMixed<PreparedTransformer${arity}<<@c.InputGenericArguments arity />, <@c.ResultTuple resultArity />>, <@c.PreparedDAG arity resultArity />> finish(ObjectReader<<@c.TupleOrUnitType arity />> inputs) {
      <#-- tuple -> array -> split is inefficient, but the assumption is that this method will--when the DAG is optimized--never be called -->
      return (PreparerResultMixed) _dag._executor.internalAPI().prepareUnsafe(_dag, <#if arity == 1>new ObjectReader[] { inputs }<#else>ObjectReader.split(${arity}, inputs.lazyMap(tuple -> tuple.toArray()))</#if>);
    }

    @Override
    public void process(<@c.InputSuffixedParameters "value" arity />) {
      // noop
    }
  }

  @Override
  protected Preparer${arity}<<@c.InputGenericArguments arity />, <@c.ResultTuple resultArity />, <@c.PreparedDAG arity resultArity />> getPreparer(PreparerContext context) {
    return new Preparer<>(this);
  }

  <@c.Indent 1><@PrepareAndApplyJavadoc arity /></@c.Indent>
  public <@c.DAGResultLocal arity resultArity /> prepareAndApply(<@c.ValuesArguments "Iterable" arity />) {
    DAGExecutionResult<<@c.ResultTuple resultArity />, <@c.PreparedDAG arity resultArity />> res =  _executor.internalAPI().prepareAndApplyUnsafe(this, new ObjectReader[] { <@c.InputSuffixedList "ObjectReader.wrap(values" arity ")" /> });
    return new Result<>((<@c.PreparedDAG arity resultArity />) res.getPreparerResult().getPreparedTransformerForNewData(), res.getOutputs());
  }

  <@c.Indent 1><@PrepareJavadoc arity /></@c.Indent>
  public <@c.PreparedDAG arity resultArity /> prepare(<@c.ValuesArguments "Iterable" arity />) {
    return (<@c.PreparedDAG arity resultArity />) _executor.internalAPI().prepareUnsafe(this, new ObjectReader[] { <@c.InputSuffixedList "ObjectReader.wrap(values" arity ")" /> }).getPreparedTransformerForNewData();
  }

  /**
   * {@link Result}s are returned by the DAG's prepareAndApply(...) methods and contain both the prepared (trained) DAG
   * and the results of applying that DAG to the preparation (training) data.
   *
   <@c.GenericInputTypesJavadoc arity />
   <@c.GenericResultTypesJavadoc resultArity />
   */
  public static final class <@c.DAGResultLocal arity resultArity /> extends <@c.AbstractDAGResult resultArity /> {
    // the prepared DAG
    private final <@c.PreparedDAG arity resultArity /> _preparedDAG;

    /**
     * @return the {@link Prepared} DAG that was prepared (trained) on the provided preparation (training) data.
     */
    public <@c.PreparedDAG arity resultArity /> getPreparedDAG() {
      return _preparedDAG;
    }

    /**
     * Creates a new instance.
     *
     * @param preparedDAG the prepared DAG to be stored in this instance
     * @param results an array of {@link ObjectReader}s that contain each resultant output value of applying the DAG to
     *                the preparation (training) data
     */
    Result(<@c.PreparedDAG arity resultArity /> preparedDAG, ObjectReader<?>[] results) {
      super(results);
      _preparedDAG = preparedDAG;
    }
  }

  /**
   * Prepared DAGs (directed acyclic graphs) contain root nodes ({@link com.linkedin.dagli.placeholder.Placeholder}s and
   * {@link com.linkedin.dagli.generator.Generator}s) and child nodes
   * ({@link com.linkedin.dagli.transformer.PreparedTransformer}s)  Unlike preparable DAGs, prepared DAGs do not contain
   * {@link com.linkedin.dagli.transformer.PreparableTransformer}s nor {@link com.linkedin.dagli.view.TransformerView}s
   * and can be applied to examples to transform them to some desired result (often an inference, such as a
   * classification or regression) using the apply(...) (for single examples) or applyAll(...) (for multiple examples)
   * methods.
   *
   * Prepared DAGs are also themselves {@link com.linkedin.dagli.transformer.PreparedTransformer}s, and can be used as
   * such within another DAG.
   *
   <@c.GenericInputTypesJavadoc arity />
   <@c.GenericResultTypesJavadoc resultArity />
   */
  @ValueEquality
  public static class <@c.PreparedDAGLocal arity resultArity /> extends <@AbstractPrepared /> implements PreparedDAGTransformer<<@c.ResultTuple resultArity />, <@c.PreparedDAG arity resultArity />> {

    private static final long serialVersionUID = 1;

    // the DAGStructure stores the actual graph
    private DAGStructure<<@c.ResultTuple resultArity />> _dag;

    // keep track of what level of reduction we used to construct this DAG
    @IgnoredByValueEquality // irrelevant given _dag and not (directly) externally observable
    private Reducer.Level _reductionLevel = null; // null -> no reductions applied

    // the executor that will be used to apply the DAG to new examples
    @IgnoredByValueEquality // not a factor in the semantics of the DAG and not (directly) externally observable
    private PreparedDAGExecutor _executor;

    /**
     * Creates a new DAG instance from the specified {@link DAGStructure} graph with the specified input<@c.s arity />.  DAG objects
     * have inputs because they can also serve as transformers within other DAGs.  In the common case where the DAG is
     * used directly and not embedded within another DAG, these inputs don't matter (and can simply be left as
     * {@link com.linkedin.dagli.producer.MissingInput}s).
     *
     * By default, this DAG will use a {@link LocalDAGExecutor}; to use a different executor, use the
     * {@link #withExecutor(DAGExecutor)} method.
     *
     * @param dag the {@link DAGStructure} representing the actual graph of nodes and directed (parent/child) edges
     <@c.Indent><@c.TransformerInputsJavadoc arity /></@c.Indent>
     */
    Prepared(DAGStructure<<@c.ResultTuple resultArity />> dag, <@c.InputProducerList arity />) {
      super(<@c.InputSuffixedList "input" arity />);
      _dag = dag;
      _executor = new LocalDAGExecutor();
    }

    <@CommonMethods true />

    <@c.Indent 2><@c.TransformerWithInputsJavadoc arity /></@c.Indent>
    public <@c.PreparedDAG arity resultArity /> withInput<@c.s arity />(<@c.InputProducerList arity />) {
      return super.withAllInputs(<@c.InputSuffixedList "input" arity />);
    }

    <@c.WithGeneratorAsInput true arity resultArity />

    <@c.Indent 2><@ApplyAllJavadoc arity /></@c.Indent>
    public <@c.PreparedDAGResultLocal resultArity /> applyAll(<@c.ValuesArguments "Iterable" arity />) {
      return new <@c.PreparedDAGResultLocal resultArity />(_executor.internalAPI().applyUnsafe(this, new ObjectReader[] { <@c.InputSuffixedList "ObjectReader.wrap(values" arity ")" /> }));
    }

    @Override
    public <@c.ResultTuple resultArity /> apply(<@c.InputSuffixedParameters "value" arity />) {
      try (
          AutoCloseableArray<ObjectReader<?>> res = new AutoCloseableArray<>(_executor.internalAPI().applyUnsafe(this,
            new ObjectReader[]{<#list 1..arity as index>ObjectReader.singleton(value${c.InputSuffix(index)})<#sep>, </#list>}));

        <#list 0..(resultArity-1) as index>ObjectIterator<?> resultIterator${index} = res.get(${index}).iterator()<#sep>;
        </#list>) {
      <#if (resultArity > 1)>
      return (<@c.ResultTuple resultArity />) ${c.tuples[resultArity]}.of(<#list 0..(resultArity-1) as index>resultIterator${index}.next()<#sep>, </#list>);
      <#else>
      return (${c.ResultGenericArgument(1)}) resultIterator0.next();
      </#if>
      }
    }

    /**
     * Contains the results of applying the DAG to one or more examples, as produced by a call to applyAll(...).
     *
     <@c.Indent 2><@c.GenericResultTypesJavadoc resultArity /></@c.Indent>
     */
    public static final class <@c.PreparedDAGResultLocal resultArity /> extends <@c.AbstractDAGResult resultArity /> {
      /**
       * Creates a new instance.
       *
       * @param results an array of {@link ObjectReader}s that contain each resultant output value of applying the DAG to
       *                the provided examples
       */
      Result(ObjectReader<?>[] results) {
        super(results);
      }
    }
  }
}
