<#import "../common.ftl" as c />
<@c.AutoGeneratedWarning />
package com.linkedin.dagli.preparer;

import com.linkedin.dagli.objectio.ObjectReader;
import com.linkedin.dagli.transformer.PreparedTransformer${arity};
import com.linkedin.dagli.util.invariant.Arguments;

<#if (arity > 1)>
import com.linkedin.dagli.tuple.Tuple${arity};
</#if>

<#assign preparedType>N extends <@c.PreparedTransformer arity /></#assign>
public interface Preparer${arity}<<@c.InputGenericArguments arity />, R, ${preparedType}> extends Preparer<R, N> {
  @Override
  default void processUnsafe(Object[] values) {
    <@c.LengthCheck "values" arity />
    process(<#list 1..arity as index>(${c.InputGenericArgument(index)}) values[${index - 1}]<#sep>, </#list>);
  }

 /**
  * Processes a single example of preparation data.  To prepare a {@link Preparer}, process(...) will be called on
  * each and every preparation example before finish(...) is called to complete preparation.
  *
  * This method is not assumed to be thread-safe and will not be invoked concurrently on the same {@link Preparer}.
  *
  <#list 1..arity as index>
  * @param value${c.InputSuffix(index)} the ${c.positionNames[index]} value of the preparation example to be processed
  </#list>
  */
  void process(<@c.InputValueList arity />);

  @Override
  default PreparerResultMixed<? extends <@c.LoosePreparedTransformer arity />, N> finishUnsafe(ObjectReader<Object[]> inputs) {
    return finish(inputs == null ? null : <@c.ObjectReaderArrayToTupleOrUnit arity />);
  }

  /**
   * Completes preparation to obtain the final, prepared transformer result.  This method is called after all
   * preparation data has been process(...)'ed.
   *
   * @param inputs an {@link ObjectReader} that can be used by the {@link Preparer} to iterate over the preparation data
   *               as many times as desired.
   * @return a {@link PreparerResultMixed} containing the resultant prepared transformers (often these are the same
   *         instance; a {@link Preparer} can, however, return a different transformer to be used on preparation and
   *         future ("new") data, which is useful in certain sophisticated use cases)
   */
  PreparerResultMixed<? extends <@c.LoosePreparedTransformer arity />, N> finish(ObjectReader<<@c.TupleOrUnitType arity />> inputs);

  /**
   * Casts a preparer to a "supertype".  This cast is safe due to the semantics of preparers.
   *
   * @param preparer the preparer to cast
<#list 1..arity as index>   * @param <${c.InputGenericArgument(index)}> the new type of input #${index}
</#list>
   * @param <R> the new result type
   * @param <N> the new prepared transformer type
   * @return the provided {@code preparer}, cast to the desired "supertype"
   */
  @SuppressWarnings("unchecked")
  static <<@c.InputGenericArguments arity />, R, ${preparedType}> Preparer${arity}<<@c.InputGenericArguments arity />, R, N> cast(Preparer${arity}<<@c.SuperInputGenericArguments arity />, ? extends R, ? extends N> preparer) {
    // safe due to semantics of preparers:
    return (Preparer${arity}<<@c.InputGenericArguments arity />, R, N>) preparer;
  }
}
