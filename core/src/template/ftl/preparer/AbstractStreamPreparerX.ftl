<#import "../common.ftl" as c />
<@c.AutoGeneratedWarning />
package com.linkedin.dagli.preparer;

import com.linkedin.dagli.transformer.PreparedTransformer${arity};
import com.linkedin.dagli.objectio.ObjectReader;
<#if (arity > 1)>import com.linkedin.dagli.tuple.Tuple${arity};</#if>

<#assign preparedType>N extends <@c.PreparedTransformer arity /></#assign>
<#assign thisType>AbstractStreamPreparer${arity}<<@c.InputGenericArguments arity />, R, N></#assign>

/**
 * A common abstract base class that {@link Preparer}s prepared using {@link PreparerMode#STREAM} mode are highly
 * encouraged to extend.  Besides simplifying the code and improving readability, this also helps insulate the derived
 * class's implementation from future changes in the Dagli Framework.
 *
 <@c.GenericInputTypesJavadoc arity />
 * @param <R> result type of the transformer prepared by this preparer
 * @param <N> the type of {@link com.linkedin.dagli.transformer.PreparedTransformer} prepared by this preparer
 */
public abstract class AbstractStreamPreparer${arity}<<@c.InputGenericArguments arity />, R, ${preparedType}>
  extends <@c.AbstractPreparer arity /> {
  @Override
  public final PreparerMode getMode() {
    return PreparerMode.STREAM;
  }

  /**
   * Completes preparation to obtain the final, prepared transformer result.  This method is called after all
   * preparation data has been process(...)'ed
   *
   * @return a {@link PreparerResultMixed} containing the resultant prepared transformers (often these are the same
   *         instance; a {@link Preparer} can, however, return a different transformer to be used on preparation and
   *         future ("new") data, which is useful in certain sophisticated use cases)
   */
  public abstract PreparerResultMixed<? extends <@c.LoosePreparedTransformer arity />, N> finish();

  @Override
  public final PreparerResultMixed<? extends <@c.LoosePreparedTransformer arity />, N> finish(ObjectReader<<@c.TupleOrUnitType arity />> inputs) {
    return finish();
  }
}