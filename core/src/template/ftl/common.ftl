<#macro AutoGeneratedWarning>
// AUTOGENERATED CODE.  DO NOT MODIFY DIRECTLY!  Instead, please modify the ${.caller_template_name} file.
// See the README in the module's src/template directory for details.
</#macro>

<#assign tuples = ["Nil", "Tuple1", "Tuple2", "Tuple3", "Tuple4", "Tuple5", "Tuple6", "Tuple7", "Tuple8", "Tuple9",
                   "Tuple10"] />

<#assign inputLetters = ["Z", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J"] />

<#assign positionNames = ["zeroth", "first", "second", "third", "fourth", "fifth", "sixth", "seventh", "eighth", "ninth", "tenth"] />

<#assign resultLetter = "R" />

<#assign executionCacheLetter = "Q" />

<#assign maxArity = 10 />

<#-- Gets the generic type parameter name corresponding to the provided 1-based index -->
<#function InputGenericArgument number>
  <#return inputLetters[number] />
</#function>

<#-- Gets the generic result tuple subtype parameter name corresponding to the provided 1-based index -->
<#-- e.g. RA, RB, RC... -->
<#function ResultGenericArgument number>
  <#return "R" + inputLetters[number] />
</#function>

<#-- Gets the suffix appended to an input value or producer corresponding to the provided 1-based index -->
<#function InputSuffix number>
  <#return number />
</#function>

<#-- Gets indentation whitespace for a specified level.  This returned string will have 2 * indentLevel spaces. -->
<#function Indentation level>
  <#return ''?left_pad(level * 2, ' ') />
</#function>

<#-- Indents each line of whatever this macro contains through a necessarily convoluted scheme -->
<#macro Indent level=1>
<#assign nestedString><#nested /></#assign>
<#assign indentedNestedString = Indentation(level) + nestedString?replace("\n", "\n" + Indentation(level)) />
${indentedNestedString?keep_before_last(Indentation(level))}</#macro> <#-- remove extra indent added to end of the input -->

<#-- Adds lists of @param's for Javadoc, explaining the generic input types (e.g. <A>, <B>, <C>...) -->
<#macro GenericInputTypesJavadoc arity>
<#list 1..arity as index>
 * @param <${InputGenericArgument(index)}> the type of the ${positionNames[index]} input
</#list>
</#macro>

<#-- Adds lists of @param's for Javadoc, explaining the generic result types used by DAGs (e.g. <RA>, <RB>, <RC>...) -->
<#macro GenericResultTypesJavadoc arity>
<#list 1..arity as index>
 * @param <${ResultGenericArgument(index)}> the type of the ${positionNames[index]} result
</#list>
</#macro>

<#-- Adds lists of @param's for Javadoc, explaining the input parameters to a transformer (e.g. input0, input1...) -->
<#macro TransformerInputsJavadoc arity>
  <#list 1..arity as index>
 * @param input${InputSuffix(index)} the {@link Producer} providing the ${positionNames[index]} input to the transformer
  </#list>
</#macro>

<#-- Adds Javadoc for the withInputs(...) methods of transformers -->
<#macro TransformerWithInputsJavadoc arity>
/**
 * Sets the parent<@s arity /> of this transformer.  The results of the parent node<@s arity /> will be the input<@s arity /> to the transformer.
 *
<@TransformerInputsJavadoc arity />
 * @return a copy of this instance that will have the specified parent<@s arity />
 */
</#macro>

<#macro InputSuffixedList prefix count extraSuffix="">
  <@compress single_line=true>
    <#list 1..count as index>${prefix}${InputSuffix(index)}${extraSuffix}<#sep>, </#list>
  </@compress>
</#macro>

<#macro InputSuffixTwiceInsertedList prefix infix suffix count>
  <@compress single_line=true>
    <#list 1..count as index>${prefix}${InputSuffix(index)}${infix}${InputSuffix(index)}${suffix}<#sep>, </#list>
  </@compress>
</#macro>

<#macro InputSuffixedParameters prefix count>
  <@compress single_line=true>
    <#list 1..count as index>${InputGenericArgument(index)} ${prefix}${InputSuffix(index)}<#sep>, </#list>
  </@compress>
</#macro>

<#macro ObjectReaderArrayToTupleOrUnit arity>
  <@compress single_line=true>
    <#if arity == 1>
      inputs.lazyMap(arr -> (A) arr[0])
    <#else>
      inputs.lazyMap(Tuple${arity}::fromArrayUnsafe)
    </#if>
  </@compress>
</#macro>

<#-- e.g. Tuple2<A, B> -->
<#macro TupleOrUnitType arity>
  <@compress single_line=true>
    <#if arity == 1>${InputGenericArgument(1)}<#else>${tuples[arity]}<<#list 1..arity as index>${InputGenericArgument(index)}<#sep>, </#list>></#if>
  </@compress>
</#macro>

<#-- e.g. Tuple2<? extends A, ? extends B> -->
<#macro UpperBoundedTupleOrUnitType arity>
    <@compress single_line=true>
        <#if arity == 1>? extends ${InputGenericArgument(1)}<#else>${tuples[arity]}<<#list 1..arity as index>? extends ${InputGenericArgument(index)}<#sep>, </#list>></#if>
    </@compress>
</#macro>

<#-- e.g. Pair<? extends A, ? extends B> -->
<#macro ValueTupleType count>
  <@compress single_line=true>
    ${tuples[count]}<<#list 1..count as index>? extends ${InputGenericArgument(index)}<#sep>, </#list>>
  </@compress>
</#macro>

<#macro InputGenericArguments count startingAt=1>
  <@compress single_line=true>
    <#list startingAt..<(count+1) as index>${InputGenericArgument(index)}<#sep>, </#list>
  </@compress>
</#macro>

<#macro SuperInputGenericArguments count startingAt=1>
    <@compress single_line=true>
        <#list startingAt..<(count+1) as index>? super ${InputGenericArgument(index)}<#sep>, </#list>
    </@compress>
</#macro>

<#macro InputGenericArgumentsExcept count exception>
  <@compress single_line=true>
    <#list ((1..<exception) + (exception+1..<(count+1))) as index>${InputGenericArgument(index)}<#sep>, </#list>
  </@compress>
</#macro>

<#macro ResultGenericArguments count startingAt=1>
  <@compress single_line=true>
    <#list startingAt..count as index>${ResultGenericArgument(index)}<#sep>, </#list>
  </@compress>
</#macro>

<#-- Producer<? extends A> input0, Producer<? extends B> input1, ... -->
<#macro InputProducerList count name="input">
  <@compress single_line=true>
    <#list 1..count as index>Producer<? extends ${InputGenericArgument(index)}> ${name}${InputSuffix(index)}<#sep>, </#list>
  </@compress>
</#macro>

<#-- getInput0(), getInput1(), ... -->
<#macro GetInputList count prepend="">
  <@compress single_line=true>
    <#list 1..count as index>${prepend}getInput${InputSuffix(index)}()<#sep>, </#list>
  </@compress>
</#macro>

<#-- CollectionType<? extends A> values0, CollectionType<? extends B> values1, ... -->
<#macro ValuesArguments collectionType count name="values">
  <@compress single_line=true>
    <#list 1..count as index>${collectionType}<? extends ${InputGenericArgument(index)}> ${name}${InputSuffix(index)}<#sep>, </#list>
  </@compress>
</#macro>

<#-- CollectionType<A> values0, CollectionType<B> values1, ... -->
<#macro ValuesArgumentsExact collectionType count name="values">
  <@compress single_line=true>
    <#list 1..count as index>${collectionType}<${InputGenericArgument(index)}> ${name}${InputSuffix(index)}<#sep>, </#list>
  </@compress>
</#macro>

<#macro InputValueList count>
  <@compress single_line=true>
    <#list 1..count as index>${InputGenericArgument(index)} value${InputSuffix(index)}<#sep>, </#list>
  </@compress>
</#macro>

<#macro Transformer arity offset=0>
  <@compress single_line=true>
    Transformer${arity}<<@InputGenericArguments arity />, R>
  </@compress>
</#macro>

<#macro LoosePreparedTransformer arity>
    <@compress single_line=true>
      PreparedTransformer${arity}<<@SuperInputGenericArguments arity />, ? extends R>
    </@compress>
</#macro>

<#macro LoosePreparableTransformer arity prepared>
    <@compress single_line=true>
      PreparableTransformer${arity}<<@SuperInputGenericArguments arity />, ? extends R, ${prepared}>
    </@compress>
</#macro>


<#macro PreparedTransformer arity>
  <@compress single_line=true>
    PreparedTransformer${arity}<<@InputGenericArguments arity />, R>
  </@compress>
</#macro>

<#macro PreparableTransformer arity preparedType>
  <@compress single_line=true>
    PreparableTransformer${arity}<<@InputGenericArguments arity />, R, ${preparedType}>
  </@compress>
</#macro>

<#macro TransformerInternalAPI arity subclass>
  <@compress single_line=true>
    Transformer${arity}InternalAPI<<@InputGenericArguments arity />, R, ${subclass}>
  </@compress>
</#macro>

<#macro PreparableTransformerInternalAPI arity preparedType subclass>
  <@compress single_line=true>
    PreparableTransformer${arity}InternalAPI<<@InputGenericArguments arity />, R, ${preparedType}, ${subclass}>
  </@compress>
</#macro>

<#macro PreparedTransformerInternalAPI arity subclass>
  <@compress single_line=true>
    PreparedTransformer${arity}InternalAPI<<@InputGenericArguments arity />, R, ${subclass}>
  </@compress>
</#macro>

<#macro AbstractTransformer arity api_interface subclass>
  <@compress single_line=true>
    AbstractTransformer${arity}<<@InputGenericArguments arity />, R, ${api_interface}, ${subclass}>
  </@compress>
</#macro>

<#macro AbstractPreparer arity>
  <@compress single_line=true>
    AbstractPreparer${arity}<<@c.InputGenericArguments arity />, R, N>
  </@compress>
</#macro>


<#macro AbstractPreparedTransformer arity subclass>
  <@compress single_line=true>
    AbstractPreparedTransformer${arity}<<@InputGenericArguments arity />, R, ${subclass}>
  </@compress>
</#macro>

<#macro AbstractPreparedStatefulTransformer arity subclass>
    <@compress single_line=true>
      AbstractPreparedStatefulTransformer${arity}<<@InputGenericArguments arity />, R, ${executionCacheLetter}, ${subclass}>
    </@compress>
</#macro>

<#macro AbstractPreparableTransformer arity preparedType subclass>
  <@compress single_line=true>
    AbstractPreparableTransformer${arity}<<@InputGenericArguments arity />, R, ${preparedType}, ${subclass}>
  </@compress>
</#macro>

<#macro ConstantResultTransformation arity>
  <@compress single_line=true>
    ConstantResultTransformation${arity}<<@InputGenericArguments arity />, R>
  </@compress>
</#macro>

<#macro PreparedConstantResultTransformation arity>
  <@compress single_line=true>
    ConstantResultTransformation${arity}.Prepared<<@InputGenericArguments arity />, R>
  </@compress>
</#macro>

<#macro Preparer arity resultType>
  <@compress single_line=true>
    Preparer${arity}<<@InputGenericArguments arity />, R, ${resultType}>
  </@compress>
</#macro>

<#macro AbstractStreamPreparer arity resultType>
  <@compress single_line=true>
    AbstractStreamPreparer${arity}<<@InputGenericArguments arity />, R, ${resultType}>
  </@compress>
</#macro>

<#macro TrivialPreparer arity resultType="?">
  <@compress single_line=true>
    TrivialPreparer${arity}<<@InputGenericArguments arity />, R, ${resultType}>
  </@compress>
</#macro>

<#macro AbstractTransformerBuilder arity>
  <@compress single_line=true>
    AbstractTransformerBuilder${arity}<<@InputGenericArguments arity />, R, <#nested />>
  </@compress>
</#macro>

<#macro Tupled arity>
  <@compress single_line=true>
    Tupled${arity}<<@InputGenericArguments arity />>
  </@compress>
</#macro>

<#macro MethodResult arity>
  <@compress single_line=true>
  MethodResult${arity}<<@InputGenericArguments arity />, R>
  </@compress>
</#macro>

<#macro FunctionResult arity>
  <@compress single_line=true>
  FunctionResult${arity}<<@InputGenericArguments arity />, R>
  </@compress>
</#macro>

<#macro DAGClassName inputArity outputArity>
  <@compress single_line=true>
  DAG${inputArity}x${outputArity}
  </@compress>
</#macro>

<#macro DAG inputArity outputArity>
  <@compress single_line=true>
    <@DAGClassName inputArity outputArity /><<@InputGenericArguments inputArity />, <@ResultGenericArguments outputArity />>
  </@compress>
</#macro>

<#macro AbstractDAGResultName outputArity>
  <@compress single_line=true>
  AbstractDAGResult${outputArity}
  </@compress>
</#macro>

<#macro AbstractDAGResult outputArity>
  <@compress single_line=true>
    <@AbstractDAGResultName outputArity /><<@ResultGenericArguments outputArity />>
  </@compress>
</#macro>


<#macro DAGResultInterfaceName outputArity>
  <@compress single_line=true>
  DAGResult${outputArity}
  </@compress>
</#macro>

<#macro DAGResultInterface outputArity>
  <@compress single_line=true>
    <@DAGResultInterfaceName outputArity /><<@ResultGenericArguments outputArity />>
  </@compress>
</#macro>

<#macro DAGResultClassName inputArity outputArity>
  <@compress single_line=true>
  DAG${inputArity}x${outputArity}.Result
  </@compress>
</#macro>

<#macro DAGResult inputArity outputArity>
  <@compress single_line=true>
    <@DAGResultClassName inputArity outputArity /><<@InputGenericArguments inputArity />, <@ResultGenericArguments outputArity />>
  </@compress>
</#macro>

<#macro DAGResultLocal inputArity outputArity>
  <@compress single_line=true>
    Result<<@InputGenericArguments inputArity />, <@ResultGenericArguments outputArity />>
  </@compress>
</#macro>

<#macro PreparedDAGResultClassName inputArity outputArity>
  <@compress single_line=true>
  DAG${inputArity}x${outputArity}.Prepared.Result
  </@compress>
</#macro>

<#macro PreparedDAGResult inputArity outputArity>
  <@compress single_line=true>
    <@PreparedDAGResultClassName inputArity outputArity /><<@ResultGenericArguments outputArity />>
  </@compress>
</#macro>

<#macro PreparedDAGResultLocal outputArity>
  <@compress single_line=true>
    Result<<@ResultGenericArguments outputArity />>
  </@compress>
</#macro>

<#macro PreparedDAGClassName inputArity outputArity>
  <@compress single_line=true>
      DAG${inputArity}x${outputArity}.Prepared
  </@compress>
</#macro>

<#-- Class signature as used outside the class and enclosing class -->
<#macro PreparedDAG inputArity outputArity>
  <@compress single_line=true>
    <@PreparedDAGClassName inputArity outputArity /><<@InputGenericArguments inputArity />, <@ResultGenericArguments outputArity />>
  </@compress>
</#macro>

<#-- Class signature as used within the class and enclosing class -->
<#macro PreparedDAGLocal inputArity outputArity>
  <@compress single_line=true>
    Prepared<<@InputGenericArguments inputArity />, <@ResultGenericArguments outputArity />>
  </@compress>
</#macro>

<#-- Tuple type used to return results from DAGs.  For a single value, the value type is used directly, e.g. RA -->
<#-- For multiple values, this becomes, e.g. Tuple2<RA, RB>, Tuple3<RA, RB, RC>, etc. -->
<#macro ResultTuple outputArity>
  <@compress single_line=true>
    <#if (outputArity > 1)>
      ${tuples[outputArity]}<<@ResultGenericArguments outputArity />>
    <#else>
      ${ResultGenericArgument(1)}
    </#if>
  </@compress>
</#macro>

<#macro ResultTupleOrUnit outputArity>
  <@compress single_line=true>
    ${tuples[outputArity]}<<@ResultGenericArguments outputArity />>
  </@compress>
</#macro>

<#macro LengthCheck variable arity>
  Arguments.check(${variable}.length == ${arity}, "${arity} argument<#if (arity > 1)>s</#if> must be provided");
</#macro>

<#macro SizeCheck variable arity>
  Arguments.check(${variable}.size() == ${arity}, "${arity} argument<#if (arity > 1)>s</#if> must be provided");
</#macro>

<#-- Generate a list of "MissingInput.get(), MissingInput.get(), ..., MissingInput.get()" -->
<#macro MissingInputs arity>
  <@compress single_line=true>
    <#list 1..arity as index>MissingInput.get()<#sep>, </#list>
  </@compress>
</#macro>

<#macro s arity>
  <@compress single_line=true>
    <#if (arity > 1)>s</#if>
  </@compress>
</#macro>

<#macro TransformerParameterJavadoc arity>
<#list 1..arity as index>
 * @param <${InputGenericArgument(index)}> the type of the ${positionNames[index]} input to the transformer
</#list>
 * @param <R> the type of result produced by the transformer
</#macro>
<#macro WithGeneratorAsInput prepared arity resultArity><#if (arity > 1)><#list 1..arity as index>
/**
 * Creates a new DAG that invokes this transformer, except that the ${positionNames[index]} input is replaced by the specified {@link Generator}.
 * The resultant DAG will thus have an arity of ${arity-1} (one less than this transformer), and values that were formerly
 * provided as the ${positionNames[index]} input to the transformer will now instead be generated by the {@link Generator}.
 *
 * This method is useful for eliding inputs to a transformer.  For example, a prepared classifier might have a
 * "vestigial" label input (inherited from a corresponding preparable classifier from which it was obtained) that can
 * be replaced by <code>Constant.nullValue()</code>.  Since the label input isn't used by the
 * prepared classifier (instead, it predicts a label from its other inputs and produces this as its result) replacing
 * it with a null has no effect and eliminates an unnecessary input.
 *
 * @param generator the generator that will provide a value for the ${positionNames[index]} input
 * @return a new DAG that invokes this transformer with the same inputs, except the ${positionNames[index]}, whose value is replaced by
 *         the produced by the provided generator
 */
public <#if prepared><@PreparedDAGClassName arity-1 resultArity /><#else><@DAGClassName arity-1 resultArity /></#if><<@InputGenericArgumentsExcept arity index />, <@ResultGenericArguments resultArity />> withGeneratorAsInput${index}(Generator<${InputGenericArgument(index)}> generator) {
  <#list ((1..<index) + ((index+1)..<(arity+1))) as placeholderIndex>
  Placeholder<${InputGenericArgument(placeholderIndex)}> nestedPlaceholder${InputSuffix(placeholderIndex)} = new Placeholder<>("Original Input ${InputSuffix(placeholderIndex)}");
  </#list>
  <#if prepared><@PreparedDAG arity resultArity /><#else><@DAG arity resultArity /></#if> dag =
    this.withInputs(<#list 1..<index as placeholderIndex>nestedPlaceholder${InputSuffix(placeholderIndex)}, </#list>generator<#list (index+1)..<(arity+1) as placeholderIndex>, nestedPlaceholder${InputSuffix(placeholderIndex)}</#list>);

  return DAG<#if prepared>.Prepared</#if>
    .withPlaceholder<@s arity-1 />(<#list ((1..<index) + ((index+1)..<(arity+1))) as placeholderIndex>nestedPlaceholder${InputSuffix(placeholderIndex)}<#sep>, </#list>)
    <#if (resultArity > 1)>
    .withOutputs(<#list 1..resultArity as resultIndex>new Value${resultIndex-1}FromTuple<>(dag)<#sep>, </#list>)
    <#else>
    .withOutput(dag)
    </#if>
    .withExecutor(_executor)
    .withInput<@s arity-1 />(<#list ((1..<index) + ((index+1)..<(arity+1))) as placeholderIndex>getInput${InputSuffix(placeholderIndex)}()<#sep>, </#list>);
}
</#list></#if></#macro>

