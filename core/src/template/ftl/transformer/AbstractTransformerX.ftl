<#import "../common.ftl" as c />
<@c.AutoGeneratedWarning />
package com.linkedin.dagli.transformer;

import com.linkedin.dagli.annotation.equality.IgnoredByValueEquality;
import com.linkedin.dagli.transformer.internal.Transformer${arity}InternalAPI;
import com.linkedin.dagli.producer.Producer;
import com.linkedin.dagli.producer.MissingInput;
import java.util.Arrays;
import java.util.List;
import java.util.Objects;

<#assign interface>IF extends <@c.TransformerInternalAPI arity, "S" /></#assign>
<#assign subclass>S extends <@c.AbstractTransformer arity "IF" "S" /></#assign>
@IgnoredByValueEquality
abstract class <@c.AbstractTransformer arity interface subclass />
    extends AbstractTransformer<R, IF, S> implements <@c.Transformer arity /> {

  private static final long serialVersionUID = 1;

  @Override
  protected List<Producer<?>> getInputList() {
    return Arrays.asList(<@c.GetInputList arity />);
  }

  <#list 1..arity as index>
  protected Producer<? extends ${c.InputGenericArgument(index)}> _input${c.InputSuffix(index)};
  </#list>

  <#list 1..arity as index>
  protected Producer<? extends ${c.InputGenericArgument(index)}> getInput${c.InputSuffix(index)}() {
    return _input${c.InputSuffix(index)};
  }
  </#list>

  public AbstractTransformer${arity}() {
    this(<@c.MissingInputs arity />);
  }

  public AbstractTransformer${arity}(<@c.InputProducerList arity />) {
    <#list 1..arity as index>
    _input${c.InputSuffix(index)} = Objects.requireNonNull(input${c.InputSuffix(index)});
    </#list>
  }
  /**
   * Returns a copy of this instance that will accept the specified inputs.
   *
   * The returned copy <strong>must</strong> be a new instance, as Dagli may rely on this invariant.
   *
<#list 1..arity as index>   * @param input${index} the ${c.positionNames[index]} input
</#list>
   * @return a copy of this instance that will accept the specified inputs
   */
  <#-- All arities get withInputs method -->
  protected S withAllInputs(<@c.InputProducerList arity />) {
    return clone(c -> {
      <#list 1..arity as index>
      c._input${c.InputSuffix(index)} = Objects.requireNonNull(input${c.InputSuffix(index)});
      </#list>
    });
  }

  <#-- Convenience methods for the benefit of derived classes -->
  <#list 1..arity as index>
  /**
   * Returns a copy of this instance that will accept the provided {@link Producer} as its ${c.positionNames[arity]}
   * input.
   *
   * @param input${c.InputSuffix(index)} the input to use
   * @return a copy of this instance that will accept the specified input
   */
  protected S withInput${c.InputSuffix(index)}(Producer<? extends ${c.InputGenericArgument(index)}> input${c.InputSuffix(index)}) {
    return clone(c -> c._input${c.InputSuffix(index)} = Objects.requireNonNull(input${c.InputSuffix(index)}));
  }
  </#list>

  protected abstract class InternalAPI extends AbstractTransformer<R, IF, S>.InternalAPI implements <@c.TransformerInternalAPI arity, "S" /> {
    <#list 1..arity as index>
    @Override
    public Producer<? extends ${c.InputGenericArgument(index)}> getInput${c.InputSuffix(index)}() {
      return AbstractTransformer${arity}.this.getInput${c.InputSuffix(index)}();
    }
    </#list>

    @Override
    public S withInputs(<@c.InputProducerList arity />) {
      return AbstractTransformer${arity}.this.withAllInputs(<@c.InputSuffixedList "input" arity />);
    }

    @Override
    public List<Producer<?>> getInputList() {
      return AbstractTransformer${arity}.this.getInputList();
    }
  }
}
