<#import "../common.ftl" as c />
<@c.AutoGeneratedWarning />
package com.linkedin.dagli.transformer;

import com.linkedin.dagli.producer.Producer;
import com.linkedin.dagli.transformer.internal.PreparedTransformer${arity}InternalAPI;

<#assign subclass>S extends <@c.AbstractPreparedTransformer arity "S" /></#assign>
<#assign interface><@c.PreparedTransformerInternalAPI arity "S" /></#assign>

/**
 * Base class for prepared transformers of arity ${arity} that do not cache temporary data during execution and do not
 * minibatch their inputs (transformers that do so should instead derive from
 * {@link AbstractPreparedStatefulTransformer${arity}}.)
 *
<@c.TransformerParameterJavadoc arity />
 * @param <S> the ultimate derived class
 */
public abstract class <@c.AbstractPreparedTransformer arity subclass />
    extends <@c.AbstractTransformer arity, interface, "S" />
    implements <@c.PreparedTransformer arity /> {

  private static final long serialVersionUID = 1;

  public AbstractPreparedTransformer${arity}() {
    super();
  }

  @Override
  public <@c.PreparedTransformerInternalAPI arity, "S" /> internalAPI() {
    return (<@c.PreparedTransformerInternalAPI arity, "S" />) super.internalAPI();
  }

  @Override
  protected <@c.PreparedTransformerInternalAPI arity, "S" /> createInternalAPI() {
    return new InternalAPI();
  }

  protected class InternalAPI extends <@c.AbstractTransformer arity, interface, "S" />.InternalAPI
      implements <@c.PreparedTransformerInternalAPI arity, "S" /> {
    @Override
    public R apply(Object executionCache, <@c.InputSuffixedParameters "value" arity />) {
      return AbstractPreparedTransformer${arity}.this.apply(<@c.InputSuffixedList "value" arity />);
    }
  }

  public AbstractPreparedTransformer${arity}(<@c.InputProducerList arity />) {
    super(<@c.InputSuffixedList "input" arity />);
  }
}
