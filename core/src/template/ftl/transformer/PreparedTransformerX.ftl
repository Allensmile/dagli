<#import "../common.ftl" as c />
<#import "transformer.ftl" as t />
<@c.AutoGeneratedWarning />
package com.linkedin.dagli.transformer;

import java.util.ArrayList;
import java.util.Arrays;

import com.linkedin.dagli.objectio.biglist.BigListWriter;
import com.linkedin.dagli.objectio.ObjectReader;
import com.linkedin.dagli.transformer.internal.PreparedTransformer${arity}InternalAPI;
import com.linkedin.dagli.util.collection.Iterables;


<#assign subclass>? extends <@c.PreparedTransformer arity /></#assign>
public interface <@c.PreparedTransformer arity /> extends <@c.Transformer arity />, PreparedTransformer<R> {

  /**
   * Applies the transformer to the given input value<@c.s arity />.
   *
   * This method must be thread-safe as it may be invoked concurrently on the same instance.
   *
<#list 1..arity as index>   * @param value${c.InputSuffix(index)} the ${c.positionNames[index]} input value
</#list>
   * @return the result of applying this transformer to the given example
   */
  R apply(<@c.InputSuffixedParameters "value" arity />);

  /**
   * Applies the transformer to the given examples, provided <#if (arity>1)>as parallel {@link Iterable}s<#else>as an {@link Iterable}</#if> of values.  Each position
   * in each value list corresponds to a particular example; e.g. values1.get(5) is the first input value for the
   * 6th example.
   *
<#list 1..arity as index>   * @param values${c.InputSuffix(index)} the list of values for the ${c.positionNames[index]} input
</#list>
   * @return an {@link ObjectReader} containing the results of the transformation
   */
  default ObjectReader<R> applyAll(<@c.ValuesArguments "Iterable" arity />) {
    long count = Iterables.size64(values1);
    Object executionObject = internalAPI().createExecutionCache(count);

    int minibatchSize = (int) Math.min(count, Math.max(1024, internalAPI().getPreferredMinibatchSize()));
    ArrayList<R> resultBuffer = new ArrayList<>(minibatchSize);
    BigListWriter<R> result = new BigListWriter<>(count);

    ObjectReader.concatenate(Object[]::new, <@c.InputSuffixedList "ObjectReader.wrap(values" arity ")" />)
        .lazyMap(Arrays::asList)
        .forEachBatch(minibatchSize, batch -> {
          internalAPI().applyAllUnsafe(executionObject, batch.size(), batch, resultBuffer);
          result.writeAll(resultBuffer);
          resultBuffer.clear();
        });

    return result.createReader();
  }

  @Override
  <@c.PreparedTransformerInternalAPI arity subclass /> internalAPI();

  /**
   * Casts a prepared transformer to a "supertype".  This cast is safe due to the semantics of prepared transformers.
   *
   * @param prepared the prepared transformer to cast
<#list 1..arity as index>   * @param <${c.InputGenericArgument(index)}> the new type of input #${index}
</#list>
   * @param <R> the new result type
   * @return the provided {@code prepared}, cast to the desired "supertype"
   */
  @SuppressWarnings("unchecked")
  static <<@c.InputGenericArguments arity />, R> PreparedTransformer${arity}<<@c.InputGenericArguments arity />, R> cast(PreparedTransformer${arity}<<@c.SuperInputGenericArguments arity />, ? extends R> prepared) {
    // safe due to semantics of prepared transformers:
    return (PreparedTransformer${arity}<<@c.InputGenericArguments arity />, R>) prepared;
  }
}