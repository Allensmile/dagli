<#import "../../common.ftl" as c />
<#import "../transformer.ftl" as t />
<@c.AutoGeneratedWarning />
package com.linkedin.dagli.transformer.internal;

import com.linkedin.dagli.objectio.ConcatenatedReader;
import com.linkedin.dagli.transformer.PreparableTransformer${arity};
import com.linkedin.dagli.transformer.PreparedTransformer${arity};
import com.linkedin.dagli.preparer.Preparer${arity};
import com.linkedin.dagli.preparer.PreparerContext;
import com.linkedin.dagli.preparer.PreparerResultMixed;
import com.linkedin.dagli.dag.DAGExecutor;
import java.util.Collection;
import com.linkedin.dagli.objectio.ObjectIterator;
import com.linkedin.dagli.objectio.ObjectReader;

import com.linkedin.dagli.dag.DAG;
import com.linkedin.dagli.placeholder.Placeholder;
import com.linkedin.dagli.producer.Producer;

<#if (arity > 1)>
import com.linkedin.dagli.transformer.PreparableTransformer1;
import com.linkedin.dagli.transformer.PreparedTransformer1;
</#if>

<#if (arity < c.maxArity)>
import com.linkedin.dagli.transformer.PreparableTransformer${arity+1};
import com.linkedin.dagli.transformer.PreparedTransformer${arity+1};
</#if>

<#if (arity > 1)>
  import com.linkedin.dagli.tuple.${c.tuples[arity]};
    <#list 0..arity-1 as index>
      import com.linkedin.dagli.transformer.Value${index}FromTuple;
    </#list>
</#if>

<#assign preparedTypeBound>N extends <@c.PreparedTransformer arity /></#assign>
<#assign subclass>S extends <@c.PreparableTransformer arity "N" /></#assign>
public interface <@c.PreparableTransformerInternalAPI arity preparedTypeBound subclass />
    extends <@c.TransformerInternalAPI arity "S" />, PreparableTransformerInternalAPI<R, N, S> {

  @Override
  <@c.Preparer arity "N" /> getPreparer(PreparerContext context);

  default PreparerResultMixed<? extends <@c.LoosePreparedTransformer arity />, N> prepare(
      PreparerContext context, <@c.ValuesArguments "Iterable" arity />) {
    <@c.Preparer arity "N" /> preparer = getPreparer(context);

    try (
    <#list 1..arity as index>
      ObjectIterator<? extends ${c.InputGenericArgument(index)}> iter${c.InputSuffix(index)} = ObjectIterator.wrap(values${c.InputSuffix(index)}.iterator())<#sep>;
    </#list>
    ) {
      while (iter${c.InputSuffix(1)}.hasNext()) {
        preparer.process(<#list 1..arity as index>iter${c.InputSuffix(index)}.next()<#sep>, </#list>);
      }

      <#if (arity > 1)>
      <#list 2..arity as index>
      assert !iter${c.InputSuffix(index)}.hasNext();
      </#list>
      </#if>
    }

    return preparer.finishUnsafe(new ConcatenatedReader<>(Object[]::new, <#list 1..arity as index>ObjectReader.wrap(values${c.InputSuffix(index)})<#sep>, </#list>));
  }

  default PreparerResultMixed<? extends <@c.LoosePreparedTransformer arity />, N> prepare(
      DAGExecutor executor, <@c.ValuesArguments "Collection" arity />) {
    return prepare(PreparerContext.builder(values${c.InputSuffix(1)}.size()).setExecutor(executor).build(), <#list 1..arity as index>values${c.InputSuffix(index)}<#sep>, </#list>);
  }

  <@t.WithArityMethods arity false />
}
