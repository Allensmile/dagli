// AUTOGENERATED CODE.  DO NOT MODIFY DIRECTLY!  Instead, please modify the preparer/PreparerX.ftl file.
// See the README in the module's src/template directory for details.
package com.linkedin.dagli.preparer;

import com.linkedin.dagli.objectio.ObjectReader;
import com.linkedin.dagli.transformer.PreparedTransformer1;
import com.linkedin.dagli.util.invariant.Arguments;


public interface Preparer1<A, R, N extends PreparedTransformer1<A, R>> extends Preparer<R, N> {
  @Override
  default void processUnsafe(Object[] values) {
    Arguments.check(values.length == 1, "1 argument must be provided");
    process((A) values[0]);
  }

  /**
   * Processes a single example of preparation data.  To prepare a {@link Preparer}, process(...) will be called on
   * each and every preparation example before finish(...) is called to complete preparation.
   *
   * This method is not assumed to be thread-safe and will not be invoked concurrently on the same {@link Preparer}.
   *
   * @param value1 the first value of the preparation example to be processed
   */
  void process(A value1);

  @Override
  default PreparerResultMixed<? extends PreparedTransformer1<? super A, ? extends R>, N> finishUnsafe(
      ObjectReader<Object[]> inputs) {
    return finish(inputs == null ? null : inputs.lazyMap(arr -> (A) arr[0]));
  }

  /**
   * Completes preparation to obtain the final, prepared transformer result.  This method is called after all
   * preparation data has been process(...)'ed.
   *
   * @param inputs an {@link ObjectReader} that can be used by the {@link Preparer} to iterate over the preparation data
   *               as many times as desired.
   * @return a {@link PreparerResultMixed} containing the resultant prepared transformers (often these are the same
   *         instance; a {@link Preparer} can, however, return a different transformer to be used on preparation and
   *         future ("new") data, which is useful in certain sophisticated use cases)
   */
  PreparerResultMixed<? extends PreparedTransformer1<? super A, ? extends R>, N> finish(ObjectReader<A> inputs);

  /**
   * Casts a preparer to a "supertype".  This cast is safe due to the semantics of preparers.
   *
   * @param preparer the preparer to cast
   * @param <A> the new type of input #1
   * @param <R> the new result type
   * @param <N> the new prepared transformer type
   * @return the provided {@code preparer}, cast to the desired "supertype"
   */
  @SuppressWarnings("unchecked")
  static <A, R, N extends PreparedTransformer1<A, R>> Preparer1<A, R, N> cast(
      Preparer1<? super A, ? extends R, ? extends N> preparer) {
    // safe due to semantics of preparers:
    return (Preparer1<A, R, N>) preparer;
  }
}
