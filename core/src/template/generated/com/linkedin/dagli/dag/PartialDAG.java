// AUTOGENERATED CODE.  DO NOT MODIFY DIRECTLY!  Instead, please modify the dag/PartialDAG.ftl file.
// See the README in the module's src/template directory for details.
package com.linkedin.dagli.dag;

import java.util.Arrays;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import com.linkedin.dagli.producer.MissingInput;
import com.linkedin.dagli.producer.Producer;
import com.linkedin.dagli.placeholder.Placeholder;
import com.linkedin.dagli.reducer.Reducer;
import com.linkedin.dagli.util.cloneable.AbstractCloneable;


/**
 * PartialDAGs are an intermediate step when building a DAG with methods like DAG.withPlaceholders(...).  Such methods return
 * a PartialDAG.WithPlaceholdersX instance on which you may then specify the outputs using .withOutputs(...) to get a fully-
 * typed DAG.  You would not ordinarily instantiate or even store a PartialDAG.WithPlaceholdersX class in client code; it is
 * normally a short-lived intermediate value in the aforementioned invocation chain to get a (real) DAGXxY object.
 */
public class PartialDAG {
  private PartialDAG() {
  }

  /**
   * The abstract base class of a partial DAG with 1 placeholder.  A base class is used to allow the prepared and
   * preparable {@link Prepared.WithPlaceholders1} and {@link WithPlaceholders1} to share their common logic.
   *
   * @param <A> the type of the first input
   * @param <S> the derived type ({@link Prepared.WithPlaceholders1} or {@link WithPlaceholders1})
   */
  private static class AbstractWithPlaceholders1<A, S extends AbstractWithPlaceholders1<A, S>> extends
      AbstractCloneable<S> {
    final Placeholder<? extends A> _placeholder1;
    final Producer<? extends A> _input1;
    boolean _shouldRemapInputs; // true iff inputs were provided (which will be remapped to the provided placeholders)
    Reducer.Level _minimumReducerLevel = Reducer.Level.NORMAL;

    /**
     * Creates a new partial DAG that will be rooted at the provided placeholders.
     *
     * @param placeholder1 the first placeholder
     */
    AbstractWithPlaceholders1(Placeholder<? extends A> placeholder1) {
      this(placeholder1, MissingInput.get());
      _shouldRemapInputs = false;
    }

    /**
     * Creates a new partial DAG that will be rooted at the provided placeholders, which will replace ("remap") the provided
     * "input" nodes that define a subgraph of the original graph (as defined by the ancestors of the outputs that will
     * be provided when the partial DAG is completed).  The input nodes, and any nodes that were exclusively the
     * ancestors of the input nodes, are truncated from the resulting graph.
     *
     * @param placeholder1 the first placeholder
     * @param input1 the first input
     */
    AbstractWithPlaceholders1(Placeholder<? extends A> placeholder1, Producer<? extends A> input1) {
      _placeholder1 = Objects.requireNonNull(placeholder1, "Placeholder 1 may not be null");
      _input1 = Objects.requireNonNull(input1, "Input 1 may not be null");
      _shouldRemapInputs = true;
    }

    /**
     * The created DAG will not be reduced if this method if invoked.
     *
     * DAG reduction can greatly speed up execution of a DAG, but can be relatively expensive.  Disabling reduction may
     * be useful for debugging or in corner cases where large DAGs are being very frequently created and applied to
     * small numbers of examples.
     *
     * @return a copy of the partial DAG that will not use reductions
     */
    public S withNoReduction() {
      return clone(c -> c._minimumReducerLevel = null);
    }

    /**
     * The created DAG will execute reductions that meet the minimum level specified.
     *
     * The default reduction level is {@link Reducer.Level#NORMAL}.  It may be possible to speed up DAG reduction by
     * using only the most critical reducers by passing {@link Reducer.Level#ESSENTIAL}; conversely, when reduction
     * speed is unimportant, {@link Reducer.Level#EXPENSIVE} may be used.
     *
     * @param minimumReducerLevel the minimum level of reducers that should be run
     * @return a copy of this partial DAG that will use reducers at or above the given level
     */
    public S withReduction(Reducer.Level minimumReducerLevel) {
      return clone(c -> c._minimumReducerLevel = minimumReducerLevel);
    }
  }

  /**
   * The abstract base class of a partial DAG with 2 placeholders.  A base class is used to allow the prepared and
   * preparable {@link Prepared.WithPlaceholders2} and {@link WithPlaceholders2} to share their common logic.
   *
   * @param <A> the type of the first input
   * @param <B> the type of the second input
   * @param <S> the derived type ({@link Prepared.WithPlaceholders2} or {@link WithPlaceholders2})
   */
  private static class AbstractWithPlaceholders2<A, B, S extends AbstractWithPlaceholders2<A, B, S>> extends
      AbstractCloneable<S> {
    final Placeholder<? extends A> _placeholder1;
    final Placeholder<? extends B> _placeholder2;
    final Producer<? extends A> _input1;
    final Producer<? extends B> _input2;
    boolean _shouldRemapInputs; // true iff inputs were provided (which will be remapped to the provided placeholders)
    Reducer.Level _minimumReducerLevel = Reducer.Level.NORMAL;

    /**
     * Creates a new partial DAG that will be rooted at the provided placeholders.
     *
     * @param placeholder1 the first placeholder
     * @param placeholder2 the second placeholder
     */
    AbstractWithPlaceholders2(Placeholder<? extends A> placeholder1, Placeholder<? extends B> placeholder2) {
      this(placeholder1, placeholder2, MissingInput.get(), MissingInput.get());
      _shouldRemapInputs = false;
    }

    /**
     * Creates a new partial DAG that will be rooted at the provided placeholders, which will replace ("remap") the provided
     * "input" nodes that define a subgraph of the original graph (as defined by the ancestors of the outputs that will
     * be provided when the partial DAG is completed).  The input nodes, and any nodes that were exclusively the
     * ancestors of the input nodes, are truncated from the resulting graph.
     *
     * @param placeholder1 the first placeholder
     * @param placeholder2 the second placeholder
     * @param input1 the first input
     * @param input2 the second input
     */
    AbstractWithPlaceholders2(Placeholder<? extends A> placeholder1, Placeholder<? extends B> placeholder2,
        Producer<? extends A> input1, Producer<? extends B> input2) {
      _placeholder1 = Objects.requireNonNull(placeholder1, "Placeholder 1 may not be null");
      _placeholder2 = Objects.requireNonNull(placeholder2, "Placeholder 2 may not be null");
      _input1 = Objects.requireNonNull(input1, "Input 1 may not be null");
      _input2 = Objects.requireNonNull(input2, "Input 2 may not be null");
      _shouldRemapInputs = true;
    }

    /**
     * The created DAG will not be reduced if this method if invoked.
     *
     * DAG reduction can greatly speed up execution of a DAG, but can be relatively expensive.  Disabling reduction may
     * be useful for debugging or in corner cases where large DAGs are being very frequently created and applied to
     * small numbers of examples.
     *
     * @return a copy of the partial DAG that will not use reductions
     */
    public S withNoReduction() {
      return clone(c -> c._minimumReducerLevel = null);
    }

    /**
     * The created DAG will execute reductions that meet the minimum level specified.
     *
     * The default reduction level is {@link Reducer.Level#NORMAL}.  It may be possible to speed up DAG reduction by
     * using only the most critical reducers by passing {@link Reducer.Level#ESSENTIAL}; conversely, when reduction
     * speed is unimportant, {@link Reducer.Level#EXPENSIVE} may be used.
     *
     * @param minimumReducerLevel the minimum level of reducers that should be run
     * @return a copy of this partial DAG that will use reducers at or above the given level
     */
    public S withReduction(Reducer.Level minimumReducerLevel) {
      return clone(c -> c._minimumReducerLevel = minimumReducerLevel);
    }
  }

  /**
   * The abstract base class of a partial DAG with 3 placeholders.  A base class is used to allow the prepared and
   * preparable {@link Prepared.WithPlaceholders3} and {@link WithPlaceholders3} to share their common logic.
   *
   * @param <A> the type of the first input
   * @param <B> the type of the second input
   * @param <C> the type of the third input
   * @param <S> the derived type ({@link Prepared.WithPlaceholders3} or {@link WithPlaceholders3})
   */
  private static class AbstractWithPlaceholders3<A, B, C, S extends AbstractWithPlaceholders3<A, B, C, S>> extends
      AbstractCloneable<S> {
    final Placeholder<? extends A> _placeholder1;
    final Placeholder<? extends B> _placeholder2;
    final Placeholder<? extends C> _placeholder3;
    final Producer<? extends A> _input1;
    final Producer<? extends B> _input2;
    final Producer<? extends C> _input3;
    boolean _shouldRemapInputs; // true iff inputs were provided (which will be remapped to the provided placeholders)
    Reducer.Level _minimumReducerLevel = Reducer.Level.NORMAL;

    /**
     * Creates a new partial DAG that will be rooted at the provided placeholders.
     *
     * @param placeholder1 the first placeholder
     * @param placeholder2 the second placeholder
     * @param placeholder3 the third placeholder
     */
    AbstractWithPlaceholders3(Placeholder<? extends A> placeholder1, Placeholder<? extends B> placeholder2,
        Placeholder<? extends C> placeholder3) {
      this(placeholder1, placeholder2, placeholder3, MissingInput.get(), MissingInput.get(), MissingInput.get());
      _shouldRemapInputs = false;
    }

    /**
     * Creates a new partial DAG that will be rooted at the provided placeholders, which will replace ("remap") the provided
     * "input" nodes that define a subgraph of the original graph (as defined by the ancestors of the outputs that will
     * be provided when the partial DAG is completed).  The input nodes, and any nodes that were exclusively the
     * ancestors of the input nodes, are truncated from the resulting graph.
     *
     * @param placeholder1 the first placeholder
     * @param placeholder2 the second placeholder
     * @param placeholder3 the third placeholder
     * @param input1 the first input
     * @param input2 the second input
     * @param input3 the third input
     */
    AbstractWithPlaceholders3(Placeholder<? extends A> placeholder1, Placeholder<? extends B> placeholder2,
        Placeholder<? extends C> placeholder3, Producer<? extends A> input1, Producer<? extends B> input2,
        Producer<? extends C> input3) {
      _placeholder1 = Objects.requireNonNull(placeholder1, "Placeholder 1 may not be null");
      _placeholder2 = Objects.requireNonNull(placeholder2, "Placeholder 2 may not be null");
      _placeholder3 = Objects.requireNonNull(placeholder3, "Placeholder 3 may not be null");
      _input1 = Objects.requireNonNull(input1, "Input 1 may not be null");
      _input2 = Objects.requireNonNull(input2, "Input 2 may not be null");
      _input3 = Objects.requireNonNull(input3, "Input 3 may not be null");
      _shouldRemapInputs = true;
    }

    /**
     * The created DAG will not be reduced if this method if invoked.
     *
     * DAG reduction can greatly speed up execution of a DAG, but can be relatively expensive.  Disabling reduction may
     * be useful for debugging or in corner cases where large DAGs are being very frequently created and applied to
     * small numbers of examples.
     *
     * @return a copy of the partial DAG that will not use reductions
     */
    public S withNoReduction() {
      return clone(c -> c._minimumReducerLevel = null);
    }

    /**
     * The created DAG will execute reductions that meet the minimum level specified.
     *
     * The default reduction level is {@link Reducer.Level#NORMAL}.  It may be possible to speed up DAG reduction by
     * using only the most critical reducers by passing {@link Reducer.Level#ESSENTIAL}; conversely, when reduction
     * speed is unimportant, {@link Reducer.Level#EXPENSIVE} may be used.
     *
     * @param minimumReducerLevel the minimum level of reducers that should be run
     * @return a copy of this partial DAG that will use reducers at or above the given level
     */
    public S withReduction(Reducer.Level minimumReducerLevel) {
      return clone(c -> c._minimumReducerLevel = minimumReducerLevel);
    }
  }

  /**
   * The abstract base class of a partial DAG with 4 placeholders.  A base class is used to allow the prepared and
   * preparable {@link Prepared.WithPlaceholders4} and {@link WithPlaceholders4} to share their common logic.
   *
   * @param <A> the type of the first input
   * @param <B> the type of the second input
   * @param <C> the type of the third input
   * @param <D> the type of the fourth input
   * @param <S> the derived type ({@link Prepared.WithPlaceholders4} or {@link WithPlaceholders4})
   */
  private static class AbstractWithPlaceholders4<A, B, C, D, S extends AbstractWithPlaceholders4<A, B, C, D, S>>
      extends AbstractCloneable<S> {
    final Placeholder<? extends A> _placeholder1;
    final Placeholder<? extends B> _placeholder2;
    final Placeholder<? extends C> _placeholder3;
    final Placeholder<? extends D> _placeholder4;
    final Producer<? extends A> _input1;
    final Producer<? extends B> _input2;
    final Producer<? extends C> _input3;
    final Producer<? extends D> _input4;
    boolean _shouldRemapInputs; // true iff inputs were provided (which will be remapped to the provided placeholders)
    Reducer.Level _minimumReducerLevel = Reducer.Level.NORMAL;

    /**
     * Creates a new partial DAG that will be rooted at the provided placeholders.
     *
     * @param placeholder1 the first placeholder
     * @param placeholder2 the second placeholder
     * @param placeholder3 the third placeholder
     * @param placeholder4 the fourth placeholder
     */
    AbstractWithPlaceholders4(Placeholder<? extends A> placeholder1, Placeholder<? extends B> placeholder2,
        Placeholder<? extends C> placeholder3, Placeholder<? extends D> placeholder4) {
      this(placeholder1, placeholder2, placeholder3, placeholder4, MissingInput.get(), MissingInput.get(), MissingInput
          .get(), MissingInput.get());
      _shouldRemapInputs = false;
    }

    /**
     * Creates a new partial DAG that will be rooted at the provided placeholders, which will replace ("remap") the provided
     * "input" nodes that define a subgraph of the original graph (as defined by the ancestors of the outputs that will
     * be provided when the partial DAG is completed).  The input nodes, and any nodes that were exclusively the
     * ancestors of the input nodes, are truncated from the resulting graph.
     *
     * @param placeholder1 the first placeholder
     * @param placeholder2 the second placeholder
     * @param placeholder3 the third placeholder
     * @param placeholder4 the fourth placeholder
     * @param input1 the first input
     * @param input2 the second input
     * @param input3 the third input
     * @param input4 the fourth input
     */
    AbstractWithPlaceholders4(Placeholder<? extends A> placeholder1, Placeholder<? extends B> placeholder2,
        Placeholder<? extends C> placeholder3, Placeholder<? extends D> placeholder4, Producer<? extends A> input1,
        Producer<? extends B> input2, Producer<? extends C> input3, Producer<? extends D> input4) {
      _placeholder1 = Objects.requireNonNull(placeholder1, "Placeholder 1 may not be null");
      _placeholder2 = Objects.requireNonNull(placeholder2, "Placeholder 2 may not be null");
      _placeholder3 = Objects.requireNonNull(placeholder3, "Placeholder 3 may not be null");
      _placeholder4 = Objects.requireNonNull(placeholder4, "Placeholder 4 may not be null");
      _input1 = Objects.requireNonNull(input1, "Input 1 may not be null");
      _input2 = Objects.requireNonNull(input2, "Input 2 may not be null");
      _input3 = Objects.requireNonNull(input3, "Input 3 may not be null");
      _input4 = Objects.requireNonNull(input4, "Input 4 may not be null");
      _shouldRemapInputs = true;
    }

    /**
     * The created DAG will not be reduced if this method if invoked.
     *
     * DAG reduction can greatly speed up execution of a DAG, but can be relatively expensive.  Disabling reduction may
     * be useful for debugging or in corner cases where large DAGs are being very frequently created and applied to
     * small numbers of examples.
     *
     * @return a copy of the partial DAG that will not use reductions
     */
    public S withNoReduction() {
      return clone(c -> c._minimumReducerLevel = null);
    }

    /**
     * The created DAG will execute reductions that meet the minimum level specified.
     *
     * The default reduction level is {@link Reducer.Level#NORMAL}.  It may be possible to speed up DAG reduction by
     * using only the most critical reducers by passing {@link Reducer.Level#ESSENTIAL}; conversely, when reduction
     * speed is unimportant, {@link Reducer.Level#EXPENSIVE} may be used.
     *
     * @param minimumReducerLevel the minimum level of reducers that should be run
     * @return a copy of this partial DAG that will use reducers at or above the given level
     */
    public S withReduction(Reducer.Level minimumReducerLevel) {
      return clone(c -> c._minimumReducerLevel = minimumReducerLevel);
    }
  }

  /**
   * The abstract base class of a partial DAG with 5 placeholders.  A base class is used to allow the prepared and
   * preparable {@link Prepared.WithPlaceholders5} and {@link WithPlaceholders5} to share their common logic.
   *
   * @param <A> the type of the first input
   * @param <B> the type of the second input
   * @param <C> the type of the third input
   * @param <D> the type of the fourth input
   * @param <E> the type of the fifth input
   * @param <S> the derived type ({@link Prepared.WithPlaceholders5} or {@link WithPlaceholders5})
   */
  private static class AbstractWithPlaceholders5<A, B, C, D, E, S extends AbstractWithPlaceholders5<A, B, C, D, E, S>>
      extends AbstractCloneable<S> {
    final Placeholder<? extends A> _placeholder1;
    final Placeholder<? extends B> _placeholder2;
    final Placeholder<? extends C> _placeholder3;
    final Placeholder<? extends D> _placeholder4;
    final Placeholder<? extends E> _placeholder5;
    final Producer<? extends A> _input1;
    final Producer<? extends B> _input2;
    final Producer<? extends C> _input3;
    final Producer<? extends D> _input4;
    final Producer<? extends E> _input5;
    boolean _shouldRemapInputs; // true iff inputs were provided (which will be remapped to the provided placeholders)
    Reducer.Level _minimumReducerLevel = Reducer.Level.NORMAL;

    /**
     * Creates a new partial DAG that will be rooted at the provided placeholders.
     *
     * @param placeholder1 the first placeholder
     * @param placeholder2 the second placeholder
     * @param placeholder3 the third placeholder
     * @param placeholder4 the fourth placeholder
     * @param placeholder5 the fifth placeholder
     */
    AbstractWithPlaceholders5(Placeholder<? extends A> placeholder1, Placeholder<? extends B> placeholder2,
        Placeholder<? extends C> placeholder3, Placeholder<? extends D> placeholder4,
        Placeholder<? extends E> placeholder5) {
      this(placeholder1, placeholder2, placeholder3, placeholder4, placeholder5, MissingInput.get(),
          MissingInput.get(), MissingInput.get(), MissingInput.get(), MissingInput.get());
      _shouldRemapInputs = false;
    }

    /**
     * Creates a new partial DAG that will be rooted at the provided placeholders, which will replace ("remap") the provided
     * "input" nodes that define a subgraph of the original graph (as defined by the ancestors of the outputs that will
     * be provided when the partial DAG is completed).  The input nodes, and any nodes that were exclusively the
     * ancestors of the input nodes, are truncated from the resulting graph.
     *
     * @param placeholder1 the first placeholder
     * @param placeholder2 the second placeholder
     * @param placeholder3 the third placeholder
     * @param placeholder4 the fourth placeholder
     * @param placeholder5 the fifth placeholder
     * @param input1 the first input
     * @param input2 the second input
     * @param input3 the third input
     * @param input4 the fourth input
     * @param input5 the fifth input
     */
    AbstractWithPlaceholders5(Placeholder<? extends A> placeholder1, Placeholder<? extends B> placeholder2,
        Placeholder<? extends C> placeholder3, Placeholder<? extends D> placeholder4,
        Placeholder<? extends E> placeholder5, Producer<? extends A> input1, Producer<? extends B> input2,
        Producer<? extends C> input3, Producer<? extends D> input4, Producer<? extends E> input5) {
      _placeholder1 = Objects.requireNonNull(placeholder1, "Placeholder 1 may not be null");
      _placeholder2 = Objects.requireNonNull(placeholder2, "Placeholder 2 may not be null");
      _placeholder3 = Objects.requireNonNull(placeholder3, "Placeholder 3 may not be null");
      _placeholder4 = Objects.requireNonNull(placeholder4, "Placeholder 4 may not be null");
      _placeholder5 = Objects.requireNonNull(placeholder5, "Placeholder 5 may not be null");
      _input1 = Objects.requireNonNull(input1, "Input 1 may not be null");
      _input2 = Objects.requireNonNull(input2, "Input 2 may not be null");
      _input3 = Objects.requireNonNull(input3, "Input 3 may not be null");
      _input4 = Objects.requireNonNull(input4, "Input 4 may not be null");
      _input5 = Objects.requireNonNull(input5, "Input 5 may not be null");
      _shouldRemapInputs = true;
    }

    /**
     * The created DAG will not be reduced if this method if invoked.
     *
     * DAG reduction can greatly speed up execution of a DAG, but can be relatively expensive.  Disabling reduction may
     * be useful for debugging or in corner cases where large DAGs are being very frequently created and applied to
     * small numbers of examples.
     *
     * @return a copy of the partial DAG that will not use reductions
     */
    public S withNoReduction() {
      return clone(c -> c._minimumReducerLevel = null);
    }

    /**
     * The created DAG will execute reductions that meet the minimum level specified.
     *
     * The default reduction level is {@link Reducer.Level#NORMAL}.  It may be possible to speed up DAG reduction by
     * using only the most critical reducers by passing {@link Reducer.Level#ESSENTIAL}; conversely, when reduction
     * speed is unimportant, {@link Reducer.Level#EXPENSIVE} may be used.
     *
     * @param minimumReducerLevel the minimum level of reducers that should be run
     * @return a copy of this partial DAG that will use reducers at or above the given level
     */
    public S withReduction(Reducer.Level minimumReducerLevel) {
      return clone(c -> c._minimumReducerLevel = minimumReducerLevel);
    }
  }

  /**
   * The abstract base class of a partial DAG with 6 placeholders.  A base class is used to allow the prepared and
   * preparable {@link Prepared.WithPlaceholders6} and {@link WithPlaceholders6} to share their common logic.
   *
   * @param <A> the type of the first input
   * @param <B> the type of the second input
   * @param <C> the type of the third input
   * @param <D> the type of the fourth input
   * @param <E> the type of the fifth input
   * @param <F> the type of the sixth input
   * @param <S> the derived type ({@link Prepared.WithPlaceholders6} or {@link WithPlaceholders6})
   */
  private static class AbstractWithPlaceholders6<A, B, C, D, E, F, S extends AbstractWithPlaceholders6<A, B, C, D, E, F, S>>
      extends AbstractCloneable<S> {
    final Placeholder<? extends A> _placeholder1;
    final Placeholder<? extends B> _placeholder2;
    final Placeholder<? extends C> _placeholder3;
    final Placeholder<? extends D> _placeholder4;
    final Placeholder<? extends E> _placeholder5;
    final Placeholder<? extends F> _placeholder6;
    final Producer<? extends A> _input1;
    final Producer<? extends B> _input2;
    final Producer<? extends C> _input3;
    final Producer<? extends D> _input4;
    final Producer<? extends E> _input5;
    final Producer<? extends F> _input6;
    boolean _shouldRemapInputs; // true iff inputs were provided (which will be remapped to the provided placeholders)
    Reducer.Level _minimumReducerLevel = Reducer.Level.NORMAL;

    /**
     * Creates a new partial DAG that will be rooted at the provided placeholders.
     *
     * @param placeholder1 the first placeholder
     * @param placeholder2 the second placeholder
     * @param placeholder3 the third placeholder
     * @param placeholder4 the fourth placeholder
     * @param placeholder5 the fifth placeholder
     * @param placeholder6 the sixth placeholder
     */
    AbstractWithPlaceholders6(Placeholder<? extends A> placeholder1, Placeholder<? extends B> placeholder2,
        Placeholder<? extends C> placeholder3, Placeholder<? extends D> placeholder4,
        Placeholder<? extends E> placeholder5, Placeholder<? extends F> placeholder6) {
      this(placeholder1, placeholder2, placeholder3, placeholder4, placeholder5, placeholder6, MissingInput.get(),
          MissingInput.get(), MissingInput.get(), MissingInput.get(), MissingInput.get(), MissingInput.get());
      _shouldRemapInputs = false;
    }

    /**
     * Creates a new partial DAG that will be rooted at the provided placeholders, which will replace ("remap") the provided
     * "input" nodes that define a subgraph of the original graph (as defined by the ancestors of the outputs that will
     * be provided when the partial DAG is completed).  The input nodes, and any nodes that were exclusively the
     * ancestors of the input nodes, are truncated from the resulting graph.
     *
     * @param placeholder1 the first placeholder
     * @param placeholder2 the second placeholder
     * @param placeholder3 the third placeholder
     * @param placeholder4 the fourth placeholder
     * @param placeholder5 the fifth placeholder
     * @param placeholder6 the sixth placeholder
     * @param input1 the first input
     * @param input2 the second input
     * @param input3 the third input
     * @param input4 the fourth input
     * @param input5 the fifth input
     * @param input6 the sixth input
     */
    AbstractWithPlaceholders6(Placeholder<? extends A> placeholder1, Placeholder<? extends B> placeholder2,
        Placeholder<? extends C> placeholder3, Placeholder<? extends D> placeholder4,
        Placeholder<? extends E> placeholder5, Placeholder<? extends F> placeholder6, Producer<? extends A> input1,
        Producer<? extends B> input2, Producer<? extends C> input3, Producer<? extends D> input4,
        Producer<? extends E> input5, Producer<? extends F> input6) {
      _placeholder1 = Objects.requireNonNull(placeholder1, "Placeholder 1 may not be null");
      _placeholder2 = Objects.requireNonNull(placeholder2, "Placeholder 2 may not be null");
      _placeholder3 = Objects.requireNonNull(placeholder3, "Placeholder 3 may not be null");
      _placeholder4 = Objects.requireNonNull(placeholder4, "Placeholder 4 may not be null");
      _placeholder5 = Objects.requireNonNull(placeholder5, "Placeholder 5 may not be null");
      _placeholder6 = Objects.requireNonNull(placeholder6, "Placeholder 6 may not be null");
      _input1 = Objects.requireNonNull(input1, "Input 1 may not be null");
      _input2 = Objects.requireNonNull(input2, "Input 2 may not be null");
      _input3 = Objects.requireNonNull(input3, "Input 3 may not be null");
      _input4 = Objects.requireNonNull(input4, "Input 4 may not be null");
      _input5 = Objects.requireNonNull(input5, "Input 5 may not be null");
      _input6 = Objects.requireNonNull(input6, "Input 6 may not be null");
      _shouldRemapInputs = true;
    }

    /**
     * The created DAG will not be reduced if this method if invoked.
     *
     * DAG reduction can greatly speed up execution of a DAG, but can be relatively expensive.  Disabling reduction may
     * be useful for debugging or in corner cases where large DAGs are being very frequently created and applied to
     * small numbers of examples.
     *
     * @return a copy of the partial DAG that will not use reductions
     */
    public S withNoReduction() {
      return clone(c -> c._minimumReducerLevel = null);
    }

    /**
     * The created DAG will execute reductions that meet the minimum level specified.
     *
     * The default reduction level is {@link Reducer.Level#NORMAL}.  It may be possible to speed up DAG reduction by
     * using only the most critical reducers by passing {@link Reducer.Level#ESSENTIAL}; conversely, when reduction
     * speed is unimportant, {@link Reducer.Level#EXPENSIVE} may be used.
     *
     * @param minimumReducerLevel the minimum level of reducers that should be run
     * @return a copy of this partial DAG that will use reducers at or above the given level
     */
    public S withReduction(Reducer.Level minimumReducerLevel) {
      return clone(c -> c._minimumReducerLevel = minimumReducerLevel);
    }
  }

  /**
   * The abstract base class of a partial DAG with 7 placeholders.  A base class is used to allow the prepared and
   * preparable {@link Prepared.WithPlaceholders7} and {@link WithPlaceholders7} to share their common logic.
   *
   * @param <A> the type of the first input
   * @param <B> the type of the second input
   * @param <C> the type of the third input
   * @param <D> the type of the fourth input
   * @param <E> the type of the fifth input
   * @param <F> the type of the sixth input
   * @param <G> the type of the seventh input
   * @param <S> the derived type ({@link Prepared.WithPlaceholders7} or {@link WithPlaceholders7})
   */
  private static class AbstractWithPlaceholders7<A, B, C, D, E, F, G, S extends AbstractWithPlaceholders7<A, B, C, D, E, F, G, S>>
      extends AbstractCloneable<S> {
    final Placeholder<? extends A> _placeholder1;
    final Placeholder<? extends B> _placeholder2;
    final Placeholder<? extends C> _placeholder3;
    final Placeholder<? extends D> _placeholder4;
    final Placeholder<? extends E> _placeholder5;
    final Placeholder<? extends F> _placeholder6;
    final Placeholder<? extends G> _placeholder7;
    final Producer<? extends A> _input1;
    final Producer<? extends B> _input2;
    final Producer<? extends C> _input3;
    final Producer<? extends D> _input4;
    final Producer<? extends E> _input5;
    final Producer<? extends F> _input6;
    final Producer<? extends G> _input7;
    boolean _shouldRemapInputs; // true iff inputs were provided (which will be remapped to the provided placeholders)
    Reducer.Level _minimumReducerLevel = Reducer.Level.NORMAL;

    /**
     * Creates a new partial DAG that will be rooted at the provided placeholders.
     *
     * @param placeholder1 the first placeholder
     * @param placeholder2 the second placeholder
     * @param placeholder3 the third placeholder
     * @param placeholder4 the fourth placeholder
     * @param placeholder5 the fifth placeholder
     * @param placeholder6 the sixth placeholder
     * @param placeholder7 the seventh placeholder
     */
    AbstractWithPlaceholders7(Placeholder<? extends A> placeholder1, Placeholder<? extends B> placeholder2,
        Placeholder<? extends C> placeholder3, Placeholder<? extends D> placeholder4,
        Placeholder<? extends E> placeholder5, Placeholder<? extends F> placeholder6,
        Placeholder<? extends G> placeholder7) {
      this(placeholder1, placeholder2, placeholder3, placeholder4, placeholder5, placeholder6, placeholder7,
          MissingInput.get(), MissingInput.get(), MissingInput.get(), MissingInput.get(), MissingInput.get(),
          MissingInput.get(), MissingInput.get());
      _shouldRemapInputs = false;
    }

    /**
     * Creates a new partial DAG that will be rooted at the provided placeholders, which will replace ("remap") the provided
     * "input" nodes that define a subgraph of the original graph (as defined by the ancestors of the outputs that will
     * be provided when the partial DAG is completed).  The input nodes, and any nodes that were exclusively the
     * ancestors of the input nodes, are truncated from the resulting graph.
     *
     * @param placeholder1 the first placeholder
     * @param placeholder2 the second placeholder
     * @param placeholder3 the third placeholder
     * @param placeholder4 the fourth placeholder
     * @param placeholder5 the fifth placeholder
     * @param placeholder6 the sixth placeholder
     * @param placeholder7 the seventh placeholder
     * @param input1 the first input
     * @param input2 the second input
     * @param input3 the third input
     * @param input4 the fourth input
     * @param input5 the fifth input
     * @param input6 the sixth input
     * @param input7 the seventh input
     */
    AbstractWithPlaceholders7(Placeholder<? extends A> placeholder1, Placeholder<? extends B> placeholder2,
        Placeholder<? extends C> placeholder3, Placeholder<? extends D> placeholder4,
        Placeholder<? extends E> placeholder5, Placeholder<? extends F> placeholder6,
        Placeholder<? extends G> placeholder7, Producer<? extends A> input1, Producer<? extends B> input2,
        Producer<? extends C> input3, Producer<? extends D> input4, Producer<? extends E> input5,
        Producer<? extends F> input6, Producer<? extends G> input7) {
      _placeholder1 = Objects.requireNonNull(placeholder1, "Placeholder 1 may not be null");
      _placeholder2 = Objects.requireNonNull(placeholder2, "Placeholder 2 may not be null");
      _placeholder3 = Objects.requireNonNull(placeholder3, "Placeholder 3 may not be null");
      _placeholder4 = Objects.requireNonNull(placeholder4, "Placeholder 4 may not be null");
      _placeholder5 = Objects.requireNonNull(placeholder5, "Placeholder 5 may not be null");
      _placeholder6 = Objects.requireNonNull(placeholder6, "Placeholder 6 may not be null");
      _placeholder7 = Objects.requireNonNull(placeholder7, "Placeholder 7 may not be null");
      _input1 = Objects.requireNonNull(input1, "Input 1 may not be null");
      _input2 = Objects.requireNonNull(input2, "Input 2 may not be null");
      _input3 = Objects.requireNonNull(input3, "Input 3 may not be null");
      _input4 = Objects.requireNonNull(input4, "Input 4 may not be null");
      _input5 = Objects.requireNonNull(input5, "Input 5 may not be null");
      _input6 = Objects.requireNonNull(input6, "Input 6 may not be null");
      _input7 = Objects.requireNonNull(input7, "Input 7 may not be null");
      _shouldRemapInputs = true;
    }

    /**
     * The created DAG will not be reduced if this method if invoked.
     *
     * DAG reduction can greatly speed up execution of a DAG, but can be relatively expensive.  Disabling reduction may
     * be useful for debugging or in corner cases where large DAGs are being very frequently created and applied to
     * small numbers of examples.
     *
     * @return a copy of the partial DAG that will not use reductions
     */
    public S withNoReduction() {
      return clone(c -> c._minimumReducerLevel = null);
    }

    /**
     * The created DAG will execute reductions that meet the minimum level specified.
     *
     * The default reduction level is {@link Reducer.Level#NORMAL}.  It may be possible to speed up DAG reduction by
     * using only the most critical reducers by passing {@link Reducer.Level#ESSENTIAL}; conversely, when reduction
     * speed is unimportant, {@link Reducer.Level#EXPENSIVE} may be used.
     *
     * @param minimumReducerLevel the minimum level of reducers that should be run
     * @return a copy of this partial DAG that will use reducers at or above the given level
     */
    public S withReduction(Reducer.Level minimumReducerLevel) {
      return clone(c -> c._minimumReducerLevel = minimumReducerLevel);
    }
  }

  /**
   * The abstract base class of a partial DAG with 8 placeholders.  A base class is used to allow the prepared and
   * preparable {@link Prepared.WithPlaceholders8} and {@link WithPlaceholders8} to share their common logic.
   *
   * @param <A> the type of the first input
   * @param <B> the type of the second input
   * @param <C> the type of the third input
   * @param <D> the type of the fourth input
   * @param <E> the type of the fifth input
   * @param <F> the type of the sixth input
   * @param <G> the type of the seventh input
   * @param <H> the type of the eighth input
   * @param <S> the derived type ({@link Prepared.WithPlaceholders8} or {@link WithPlaceholders8})
   */
  private static class AbstractWithPlaceholders8<A, B, C, D, E, F, G, H, S extends AbstractWithPlaceholders8<A, B, C, D, E, F, G, H, S>>
      extends AbstractCloneable<S> {
    final Placeholder<? extends A> _placeholder1;
    final Placeholder<? extends B> _placeholder2;
    final Placeholder<? extends C> _placeholder3;
    final Placeholder<? extends D> _placeholder4;
    final Placeholder<? extends E> _placeholder5;
    final Placeholder<? extends F> _placeholder6;
    final Placeholder<? extends G> _placeholder7;
    final Placeholder<? extends H> _placeholder8;
    final Producer<? extends A> _input1;
    final Producer<? extends B> _input2;
    final Producer<? extends C> _input3;
    final Producer<? extends D> _input4;
    final Producer<? extends E> _input5;
    final Producer<? extends F> _input6;
    final Producer<? extends G> _input7;
    final Producer<? extends H> _input8;
    boolean _shouldRemapInputs; // true iff inputs were provided (which will be remapped to the provided placeholders)
    Reducer.Level _minimumReducerLevel = Reducer.Level.NORMAL;

    /**
     * Creates a new partial DAG that will be rooted at the provided placeholders.
     *
     * @param placeholder1 the first placeholder
     * @param placeholder2 the second placeholder
     * @param placeholder3 the third placeholder
     * @param placeholder4 the fourth placeholder
     * @param placeholder5 the fifth placeholder
     * @param placeholder6 the sixth placeholder
     * @param placeholder7 the seventh placeholder
     * @param placeholder8 the eighth placeholder
     */
    AbstractWithPlaceholders8(Placeholder<? extends A> placeholder1, Placeholder<? extends B> placeholder2,
        Placeholder<? extends C> placeholder3, Placeholder<? extends D> placeholder4,
        Placeholder<? extends E> placeholder5, Placeholder<? extends F> placeholder6,
        Placeholder<? extends G> placeholder7, Placeholder<? extends H> placeholder8) {
      this(placeholder1, placeholder2, placeholder3, placeholder4, placeholder5, placeholder6, placeholder7,
          placeholder8, MissingInput.get(), MissingInput.get(), MissingInput.get(), MissingInput.get(), MissingInput
              .get(), MissingInput.get(), MissingInput.get(), MissingInput.get());
      _shouldRemapInputs = false;
    }

    /**
     * Creates a new partial DAG that will be rooted at the provided placeholders, which will replace ("remap") the provided
     * "input" nodes that define a subgraph of the original graph (as defined by the ancestors of the outputs that will
     * be provided when the partial DAG is completed).  The input nodes, and any nodes that were exclusively the
     * ancestors of the input nodes, are truncated from the resulting graph.
     *
     * @param placeholder1 the first placeholder
     * @param placeholder2 the second placeholder
     * @param placeholder3 the third placeholder
     * @param placeholder4 the fourth placeholder
     * @param placeholder5 the fifth placeholder
     * @param placeholder6 the sixth placeholder
     * @param placeholder7 the seventh placeholder
     * @param placeholder8 the eighth placeholder
     * @param input1 the first input
     * @param input2 the second input
     * @param input3 the third input
     * @param input4 the fourth input
     * @param input5 the fifth input
     * @param input6 the sixth input
     * @param input7 the seventh input
     * @param input8 the eighth input
     */
    AbstractWithPlaceholders8(Placeholder<? extends A> placeholder1, Placeholder<? extends B> placeholder2,
        Placeholder<? extends C> placeholder3, Placeholder<? extends D> placeholder4,
        Placeholder<? extends E> placeholder5, Placeholder<? extends F> placeholder6,
        Placeholder<? extends G> placeholder7, Placeholder<? extends H> placeholder8, Producer<? extends A> input1,
        Producer<? extends B> input2, Producer<? extends C> input3, Producer<? extends D> input4,
        Producer<? extends E> input5, Producer<? extends F> input6, Producer<? extends G> input7,
        Producer<? extends H> input8) {
      _placeholder1 = Objects.requireNonNull(placeholder1, "Placeholder 1 may not be null");
      _placeholder2 = Objects.requireNonNull(placeholder2, "Placeholder 2 may not be null");
      _placeholder3 = Objects.requireNonNull(placeholder3, "Placeholder 3 may not be null");
      _placeholder4 = Objects.requireNonNull(placeholder4, "Placeholder 4 may not be null");
      _placeholder5 = Objects.requireNonNull(placeholder5, "Placeholder 5 may not be null");
      _placeholder6 = Objects.requireNonNull(placeholder6, "Placeholder 6 may not be null");
      _placeholder7 = Objects.requireNonNull(placeholder7, "Placeholder 7 may not be null");
      _placeholder8 = Objects.requireNonNull(placeholder8, "Placeholder 8 may not be null");
      _input1 = Objects.requireNonNull(input1, "Input 1 may not be null");
      _input2 = Objects.requireNonNull(input2, "Input 2 may not be null");
      _input3 = Objects.requireNonNull(input3, "Input 3 may not be null");
      _input4 = Objects.requireNonNull(input4, "Input 4 may not be null");
      _input5 = Objects.requireNonNull(input5, "Input 5 may not be null");
      _input6 = Objects.requireNonNull(input6, "Input 6 may not be null");
      _input7 = Objects.requireNonNull(input7, "Input 7 may not be null");
      _input8 = Objects.requireNonNull(input8, "Input 8 may not be null");
      _shouldRemapInputs = true;
    }

    /**
     * The created DAG will not be reduced if this method if invoked.
     *
     * DAG reduction can greatly speed up execution of a DAG, but can be relatively expensive.  Disabling reduction may
     * be useful for debugging or in corner cases where large DAGs are being very frequently created and applied to
     * small numbers of examples.
     *
     * @return a copy of the partial DAG that will not use reductions
     */
    public S withNoReduction() {
      return clone(c -> c._minimumReducerLevel = null);
    }

    /**
     * The created DAG will execute reductions that meet the minimum level specified.
     *
     * The default reduction level is {@link Reducer.Level#NORMAL}.  It may be possible to speed up DAG reduction by
     * using only the most critical reducers by passing {@link Reducer.Level#ESSENTIAL}; conversely, when reduction
     * speed is unimportant, {@link Reducer.Level#EXPENSIVE} may be used.
     *
     * @param minimumReducerLevel the minimum level of reducers that should be run
     * @return a copy of this partial DAG that will use reducers at or above the given level
     */
    public S withReduction(Reducer.Level minimumReducerLevel) {
      return clone(c -> c._minimumReducerLevel = minimumReducerLevel);
    }
  }

  /**
   * The abstract base class of a partial DAG with 9 placeholders.  A base class is used to allow the prepared and
   * preparable {@link Prepared.WithPlaceholders9} and {@link WithPlaceholders9} to share their common logic.
   *
   * @param <A> the type of the first input
   * @param <B> the type of the second input
   * @param <C> the type of the third input
   * @param <D> the type of the fourth input
   * @param <E> the type of the fifth input
   * @param <F> the type of the sixth input
   * @param <G> the type of the seventh input
   * @param <H> the type of the eighth input
   * @param <I> the type of the ninth input
   * @param <S> the derived type ({@link Prepared.WithPlaceholders9} or {@link WithPlaceholders9})
   */
  private static class AbstractWithPlaceholders9<A, B, C, D, E, F, G, H, I, S extends AbstractWithPlaceholders9<A, B, C, D, E, F, G, H, I, S>>
      extends AbstractCloneable<S> {
    final Placeholder<? extends A> _placeholder1;
    final Placeholder<? extends B> _placeholder2;
    final Placeholder<? extends C> _placeholder3;
    final Placeholder<? extends D> _placeholder4;
    final Placeholder<? extends E> _placeholder5;
    final Placeholder<? extends F> _placeholder6;
    final Placeholder<? extends G> _placeholder7;
    final Placeholder<? extends H> _placeholder8;
    final Placeholder<? extends I> _placeholder9;
    final Producer<? extends A> _input1;
    final Producer<? extends B> _input2;
    final Producer<? extends C> _input3;
    final Producer<? extends D> _input4;
    final Producer<? extends E> _input5;
    final Producer<? extends F> _input6;
    final Producer<? extends G> _input7;
    final Producer<? extends H> _input8;
    final Producer<? extends I> _input9;
    boolean _shouldRemapInputs; // true iff inputs were provided (which will be remapped to the provided placeholders)
    Reducer.Level _minimumReducerLevel = Reducer.Level.NORMAL;

    /**
     * Creates a new partial DAG that will be rooted at the provided placeholders.
     *
     * @param placeholder1 the first placeholder
     * @param placeholder2 the second placeholder
     * @param placeholder3 the third placeholder
     * @param placeholder4 the fourth placeholder
     * @param placeholder5 the fifth placeholder
     * @param placeholder6 the sixth placeholder
     * @param placeholder7 the seventh placeholder
     * @param placeholder8 the eighth placeholder
     * @param placeholder9 the ninth placeholder
     */
    AbstractWithPlaceholders9(Placeholder<? extends A> placeholder1, Placeholder<? extends B> placeholder2,
        Placeholder<? extends C> placeholder3, Placeholder<? extends D> placeholder4,
        Placeholder<? extends E> placeholder5, Placeholder<? extends F> placeholder6,
        Placeholder<? extends G> placeholder7, Placeholder<? extends H> placeholder8,
        Placeholder<? extends I> placeholder9) {
      this(placeholder1, placeholder2, placeholder3, placeholder4, placeholder5, placeholder6, placeholder7,
          placeholder8, placeholder9, MissingInput.get(), MissingInput.get(), MissingInput.get(), MissingInput.get(),
          MissingInput.get(), MissingInput.get(), MissingInput.get(), MissingInput.get(), MissingInput.get());
      _shouldRemapInputs = false;
    }

    /**
     * Creates a new partial DAG that will be rooted at the provided placeholders, which will replace ("remap") the provided
     * "input" nodes that define a subgraph of the original graph (as defined by the ancestors of the outputs that will
     * be provided when the partial DAG is completed).  The input nodes, and any nodes that were exclusively the
     * ancestors of the input nodes, are truncated from the resulting graph.
     *
     * @param placeholder1 the first placeholder
     * @param placeholder2 the second placeholder
     * @param placeholder3 the third placeholder
     * @param placeholder4 the fourth placeholder
     * @param placeholder5 the fifth placeholder
     * @param placeholder6 the sixth placeholder
     * @param placeholder7 the seventh placeholder
     * @param placeholder8 the eighth placeholder
     * @param placeholder9 the ninth placeholder
     * @param input1 the first input
     * @param input2 the second input
     * @param input3 the third input
     * @param input4 the fourth input
     * @param input5 the fifth input
     * @param input6 the sixth input
     * @param input7 the seventh input
     * @param input8 the eighth input
     * @param input9 the ninth input
     */
    AbstractWithPlaceholders9(Placeholder<? extends A> placeholder1, Placeholder<? extends B> placeholder2,
        Placeholder<? extends C> placeholder3, Placeholder<? extends D> placeholder4,
        Placeholder<? extends E> placeholder5, Placeholder<? extends F> placeholder6,
        Placeholder<? extends G> placeholder7, Placeholder<? extends H> placeholder8,
        Placeholder<? extends I> placeholder9, Producer<? extends A> input1, Producer<? extends B> input2,
        Producer<? extends C> input3, Producer<? extends D> input4, Producer<? extends E> input5,
        Producer<? extends F> input6, Producer<? extends G> input7, Producer<? extends H> input8,
        Producer<? extends I> input9) {
      _placeholder1 = Objects.requireNonNull(placeholder1, "Placeholder 1 may not be null");
      _placeholder2 = Objects.requireNonNull(placeholder2, "Placeholder 2 may not be null");
      _placeholder3 = Objects.requireNonNull(placeholder3, "Placeholder 3 may not be null");
      _placeholder4 = Objects.requireNonNull(placeholder4, "Placeholder 4 may not be null");
      _placeholder5 = Objects.requireNonNull(placeholder5, "Placeholder 5 may not be null");
      _placeholder6 = Objects.requireNonNull(placeholder6, "Placeholder 6 may not be null");
      _placeholder7 = Objects.requireNonNull(placeholder7, "Placeholder 7 may not be null");
      _placeholder8 = Objects.requireNonNull(placeholder8, "Placeholder 8 may not be null");
      _placeholder9 = Objects.requireNonNull(placeholder9, "Placeholder 9 may not be null");
      _input1 = Objects.requireNonNull(input1, "Input 1 may not be null");
      _input2 = Objects.requireNonNull(input2, "Input 2 may not be null");
      _input3 = Objects.requireNonNull(input3, "Input 3 may not be null");
      _input4 = Objects.requireNonNull(input4, "Input 4 may not be null");
      _input5 = Objects.requireNonNull(input5, "Input 5 may not be null");
      _input6 = Objects.requireNonNull(input6, "Input 6 may not be null");
      _input7 = Objects.requireNonNull(input7, "Input 7 may not be null");
      _input8 = Objects.requireNonNull(input8, "Input 8 may not be null");
      _input9 = Objects.requireNonNull(input9, "Input 9 may not be null");
      _shouldRemapInputs = true;
    }

    /**
     * The created DAG will not be reduced if this method if invoked.
     *
     * DAG reduction can greatly speed up execution of a DAG, but can be relatively expensive.  Disabling reduction may
     * be useful for debugging or in corner cases where large DAGs are being very frequently created and applied to
     * small numbers of examples.
     *
     * @return a copy of the partial DAG that will not use reductions
     */
    public S withNoReduction() {
      return clone(c -> c._minimumReducerLevel = null);
    }

    /**
     * The created DAG will execute reductions that meet the minimum level specified.
     *
     * The default reduction level is {@link Reducer.Level#NORMAL}.  It may be possible to speed up DAG reduction by
     * using only the most critical reducers by passing {@link Reducer.Level#ESSENTIAL}; conversely, when reduction
     * speed is unimportant, {@link Reducer.Level#EXPENSIVE} may be used.
     *
     * @param minimumReducerLevel the minimum level of reducers that should be run
     * @return a copy of this partial DAG that will use reducers at or above the given level
     */
    public S withReduction(Reducer.Level minimumReducerLevel) {
      return clone(c -> c._minimumReducerLevel = minimumReducerLevel);
    }
  }

  /**
   * The abstract base class of a partial DAG with 10 placeholders.  A base class is used to allow the prepared and
   * preparable {@link Prepared.WithPlaceholders10} and {@link WithPlaceholders10} to share their common logic.
   *
   * @param <A> the type of the first input
   * @param <B> the type of the second input
   * @param <C> the type of the third input
   * @param <D> the type of the fourth input
   * @param <E> the type of the fifth input
   * @param <F> the type of the sixth input
   * @param <G> the type of the seventh input
   * @param <H> the type of the eighth input
   * @param <I> the type of the ninth input
   * @param <J> the type of the tenth input
   * @param <S> the derived type ({@link Prepared.WithPlaceholders10} or {@link WithPlaceholders10})
   */
  private static class AbstractWithPlaceholders10<A, B, C, D, E, F, G, H, I, J, S extends AbstractWithPlaceholders10<A, B, C, D, E, F, G, H, I, J, S>>
      extends AbstractCloneable<S> {
    final Placeholder<? extends A> _placeholder1;
    final Placeholder<? extends B> _placeholder2;
    final Placeholder<? extends C> _placeholder3;
    final Placeholder<? extends D> _placeholder4;
    final Placeholder<? extends E> _placeholder5;
    final Placeholder<? extends F> _placeholder6;
    final Placeholder<? extends G> _placeholder7;
    final Placeholder<? extends H> _placeholder8;
    final Placeholder<? extends I> _placeholder9;
    final Placeholder<? extends J> _placeholder10;
    final Producer<? extends A> _input1;
    final Producer<? extends B> _input2;
    final Producer<? extends C> _input3;
    final Producer<? extends D> _input4;
    final Producer<? extends E> _input5;
    final Producer<? extends F> _input6;
    final Producer<? extends G> _input7;
    final Producer<? extends H> _input8;
    final Producer<? extends I> _input9;
    final Producer<? extends J> _input10;
    boolean _shouldRemapInputs; // true iff inputs were provided (which will be remapped to the provided placeholders)
    Reducer.Level _minimumReducerLevel = Reducer.Level.NORMAL;

    /**
     * Creates a new partial DAG that will be rooted at the provided placeholders.
     *
     * @param placeholder1 the first placeholder
     * @param placeholder2 the second placeholder
     * @param placeholder3 the third placeholder
     * @param placeholder4 the fourth placeholder
     * @param placeholder5 the fifth placeholder
     * @param placeholder6 the sixth placeholder
     * @param placeholder7 the seventh placeholder
     * @param placeholder8 the eighth placeholder
     * @param placeholder9 the ninth placeholder
     * @param placeholder10 the tenth placeholder
     */
    AbstractWithPlaceholders10(Placeholder<? extends A> placeholder1, Placeholder<? extends B> placeholder2,
        Placeholder<? extends C> placeholder3, Placeholder<? extends D> placeholder4,
        Placeholder<? extends E> placeholder5, Placeholder<? extends F> placeholder6,
        Placeholder<? extends G> placeholder7, Placeholder<? extends H> placeholder8,
        Placeholder<? extends I> placeholder9, Placeholder<? extends J> placeholder10) {
      this(placeholder1, placeholder2, placeholder3, placeholder4, placeholder5, placeholder6, placeholder7,
          placeholder8, placeholder9, placeholder10, MissingInput.get(), MissingInput.get(), MissingInput.get(),
          MissingInput.get(), MissingInput.get(), MissingInput.get(), MissingInput.get(), MissingInput.get(),
          MissingInput.get(), MissingInput.get());
      _shouldRemapInputs = false;
    }

    /**
     * Creates a new partial DAG that will be rooted at the provided placeholders, which will replace ("remap") the provided
     * "input" nodes that define a subgraph of the original graph (as defined by the ancestors of the outputs that will
     * be provided when the partial DAG is completed).  The input nodes, and any nodes that were exclusively the
     * ancestors of the input nodes, are truncated from the resulting graph.
     *
     * @param placeholder1 the first placeholder
     * @param placeholder2 the second placeholder
     * @param placeholder3 the third placeholder
     * @param placeholder4 the fourth placeholder
     * @param placeholder5 the fifth placeholder
     * @param placeholder6 the sixth placeholder
     * @param placeholder7 the seventh placeholder
     * @param placeholder8 the eighth placeholder
     * @param placeholder9 the ninth placeholder
     * @param placeholder10 the tenth placeholder
     * @param input1 the first input
     * @param input2 the second input
     * @param input3 the third input
     * @param input4 the fourth input
     * @param input5 the fifth input
     * @param input6 the sixth input
     * @param input7 the seventh input
     * @param input8 the eighth input
     * @param input9 the ninth input
     * @param input10 the tenth input
     */
    AbstractWithPlaceholders10(Placeholder<? extends A> placeholder1, Placeholder<? extends B> placeholder2,
        Placeholder<? extends C> placeholder3, Placeholder<? extends D> placeholder4,
        Placeholder<? extends E> placeholder5, Placeholder<? extends F> placeholder6,
        Placeholder<? extends G> placeholder7, Placeholder<? extends H> placeholder8,
        Placeholder<? extends I> placeholder9, Placeholder<? extends J> placeholder10, Producer<? extends A> input1,
        Producer<? extends B> input2, Producer<? extends C> input3, Producer<? extends D> input4,
        Producer<? extends E> input5, Producer<? extends F> input6, Producer<? extends G> input7,
        Producer<? extends H> input8, Producer<? extends I> input9, Producer<? extends J> input10) {
      _placeholder1 = Objects.requireNonNull(placeholder1, "Placeholder 1 may not be null");
      _placeholder2 = Objects.requireNonNull(placeholder2, "Placeholder 2 may not be null");
      _placeholder3 = Objects.requireNonNull(placeholder3, "Placeholder 3 may not be null");
      _placeholder4 = Objects.requireNonNull(placeholder4, "Placeholder 4 may not be null");
      _placeholder5 = Objects.requireNonNull(placeholder5, "Placeholder 5 may not be null");
      _placeholder6 = Objects.requireNonNull(placeholder6, "Placeholder 6 may not be null");
      _placeholder7 = Objects.requireNonNull(placeholder7, "Placeholder 7 may not be null");
      _placeholder8 = Objects.requireNonNull(placeholder8, "Placeholder 8 may not be null");
      _placeholder9 = Objects.requireNonNull(placeholder9, "Placeholder 9 may not be null");
      _placeholder10 = Objects.requireNonNull(placeholder10, "Placeholder 10 may not be null");
      _input1 = Objects.requireNonNull(input1, "Input 1 may not be null");
      _input2 = Objects.requireNonNull(input2, "Input 2 may not be null");
      _input3 = Objects.requireNonNull(input3, "Input 3 may not be null");
      _input4 = Objects.requireNonNull(input4, "Input 4 may not be null");
      _input5 = Objects.requireNonNull(input5, "Input 5 may not be null");
      _input6 = Objects.requireNonNull(input6, "Input 6 may not be null");
      _input7 = Objects.requireNonNull(input7, "Input 7 may not be null");
      _input8 = Objects.requireNonNull(input8, "Input 8 may not be null");
      _input9 = Objects.requireNonNull(input9, "Input 9 may not be null");
      _input10 = Objects.requireNonNull(input10, "Input 10 may not be null");
      _shouldRemapInputs = true;
    }

    /**
     * The created DAG will not be reduced if this method if invoked.
     *
     * DAG reduction can greatly speed up execution of a DAG, but can be relatively expensive.  Disabling reduction may
     * be useful for debugging or in corner cases where large DAGs are being very frequently created and applied to
     * small numbers of examples.
     *
     * @return a copy of the partial DAG that will not use reductions
     */
    public S withNoReduction() {
      return clone(c -> c._minimumReducerLevel = null);
    }

    /**
     * The created DAG will execute reductions that meet the minimum level specified.
     *
     * The default reduction level is {@link Reducer.Level#NORMAL}.  It may be possible to speed up DAG reduction by
     * using only the most critical reducers by passing {@link Reducer.Level#ESSENTIAL}; conversely, when reduction
     * speed is unimportant, {@link Reducer.Level#EXPENSIVE} may be used.
     *
     * @param minimumReducerLevel the minimum level of reducers that should be run
     * @return a copy of this partial DAG that will use reducers at or above the given level
     */
    public S withReduction(Reducer.Level minimumReducerLevel) {
      return clone(c -> c._minimumReducerLevel = minimumReducerLevel);
    }
  }

  /**
    * A partial DAG with 1 placeholder.  Partial DAGs are <i>completed</i> to create a usable DAG by specifying
    * the outputs (<i>outputs</i>) of the DAG using the withOutputs(...) methods.
    *
   * @param <A> the type of the first input
    */
  public static class WithPlaceholders1<A> extends AbstractWithPlaceholders1<A, WithPlaceholders1<A>> {
    /**
     * Creates a new partial DAG that will be rooted at the provided placeholders.
     *
     * @param placeholder1 the first placeholder
     */
    WithPlaceholders1(Placeholder<? extends A> placeholder1) {
      super(placeholder1);
    }

    /**
     * Creates a new partial DAG that will be rooted at the provided placeholders, which will replace ("remap") the provided
     * "input" nodes that define a subgraph of the original graph (as defined by the ancestors of the outputs that will
     * be provided when the partial DAG is completed).  The input nodes, and any nodes that were exclusively the
     * ancestors of the input nodes, are truncated from the resulting graph.
     *
     * @param placeholder1 the first placeholder
     * @param input1 the first input
     */
    WithPlaceholders1(Placeholder<? extends A> placeholder1, Producer<? extends A> input1) {
      super(placeholder1, input1);
    }

    /**
     * Creates a completed DAG by supplying this partial DAG with its outputs (outputs).
     *
     * @param output1 the first output (output) of the DAG
     * @param <RA> the type of the first result
     * @return a completed DAG with 1 input (placeholders) and 1 output (outputs).
     */
    public <RA> DAG1x1<A, RA> withOutputs(Producer<? extends RA> output1) {
      Objects.requireNonNull(output1, "Output 1 may not be null");

      if (_shouldRemapInputs) {
        Map<Producer<?>, Producer<?>> inputMapping = DAGUtil.createInputMap(_input1, _placeholder1);
        output1 = DAGUtil.replaceInputs(output1, inputMapping);
      }

      List<Producer<?>> inputs = Arrays.asList(_input1);

      return ((DAG1x1) DAGUtil.createPreparableDAG(Arrays.asList(_placeholder1), Arrays.asList(output1)).internalAPI()
          .withInputsUnsafe(inputs)).withReduction(_minimumReducerLevel);
    }

    /**
     * Creates a completed DAG by supplying this partial DAG with its outputs (outputs).
     *
     * @param output1 the first output (output) of the DAG
     * @param <RA> the type of the first result
     * @return a completed DAG with 1 input (placeholders) and 1 output (outputs).
     */
    public <RA> DAG1x1<A, RA> withOutput(Producer<? extends RA> output1) {
      Objects.requireNonNull(output1, "Output 1 may not be null");

      if (_shouldRemapInputs) {
        Map<Producer<?>, Producer<?>> inputMapping = DAGUtil.createInputMap(_input1, _placeholder1);
        output1 = DAGUtil.replaceInputs(output1, inputMapping);
      }

      List<Producer<?>> inputs = Arrays.asList(_input1);

      return ((DAG1x1) DAGUtil.createPreparableDAG(Arrays.asList(_placeholder1), Arrays.asList(output1)).internalAPI()
          .withInputsUnsafe(inputs)).withReduction(_minimumReducerLevel);
    }

    /**
     * Creates a completed DAG by supplying this partial DAG with its outputs (outputs).
     *
     * @param output1 the first output (output) of the DAG
     * @param output2 the second output (output) of the DAG
     * @param <RA> the type of the first result
     * @param <RB> the type of the second result
     * @return a completed DAG with 1 input (placeholders) and 2 outputs (outputs).
     */
    public <RA, RB> DAG1x2<A, RA, RB> withOutputs(Producer<? extends RA> output1, Producer<? extends RB> output2) {
      Objects.requireNonNull(output1, "Output 1 may not be null");
      Objects.requireNonNull(output2, "Output 2 may not be null");

      if (_shouldRemapInputs) {
        Map<Producer<?>, Producer<?>> inputMapping = DAGUtil.createInputMap(_input1, _placeholder1);
        output1 = DAGUtil.replaceInputs(output1, inputMapping);
        output2 = DAGUtil.replaceInputs(output2, inputMapping);
      }

      List<Producer<?>> inputs = Arrays.asList(_input1);

      return ((DAG1x2) DAGUtil.createPreparableDAG(Arrays.asList(_placeholder1), Arrays.asList(output1, output2))
          .internalAPI().withInputsUnsafe(inputs)).withReduction(_minimumReducerLevel);
    }

    /**
     * Creates a completed DAG by supplying this partial DAG with its outputs (outputs).
     *
     * @param output1 the first output (output) of the DAG
     * @param output2 the second output (output) of the DAG
     * @param output3 the third output (output) of the DAG
     * @param <RA> the type of the first result
     * @param <RB> the type of the second result
     * @param <RC> the type of the third result
     * @return a completed DAG with 1 input (placeholders) and 3 outputs (outputs).
     */
    public <RA, RB, RC> DAG1x3<A, RA, RB, RC> withOutputs(Producer<? extends RA> output1,
        Producer<? extends RB> output2, Producer<? extends RC> output3) {
      Objects.requireNonNull(output1, "Output 1 may not be null");
      Objects.requireNonNull(output2, "Output 2 may not be null");
      Objects.requireNonNull(output3, "Output 3 may not be null");

      if (_shouldRemapInputs) {
        Map<Producer<?>, Producer<?>> inputMapping = DAGUtil.createInputMap(_input1, _placeholder1);
        output1 = DAGUtil.replaceInputs(output1, inputMapping);
        output2 = DAGUtil.replaceInputs(output2, inputMapping);
        output3 = DAGUtil.replaceInputs(output3, inputMapping);
      }

      List<Producer<?>> inputs = Arrays.asList(_input1);

      return ((DAG1x3) DAGUtil
          .createPreparableDAG(Arrays.asList(_placeholder1), Arrays.asList(output1, output2, output3)).internalAPI()
          .withInputsUnsafe(inputs)).withReduction(_minimumReducerLevel);
    }

    /**
     * Creates a completed DAG by supplying this partial DAG with its outputs (outputs).
     *
     * @param output1 the first output (output) of the DAG
     * @param output2 the second output (output) of the DAG
     * @param output3 the third output (output) of the DAG
     * @param output4 the fourth output (output) of the DAG
     * @param <RA> the type of the first result
     * @param <RB> the type of the second result
     * @param <RC> the type of the third result
     * @param <RD> the type of the fourth result
     * @return a completed DAG with 1 input (placeholders) and 4 outputs (outputs).
     */
    public <RA, RB, RC, RD> DAG1x4<A, RA, RB, RC, RD> withOutputs(Producer<? extends RA> output1,
        Producer<? extends RB> output2, Producer<? extends RC> output3, Producer<? extends RD> output4) {
      Objects.requireNonNull(output1, "Output 1 may not be null");
      Objects.requireNonNull(output2, "Output 2 may not be null");
      Objects.requireNonNull(output3, "Output 3 may not be null");
      Objects.requireNonNull(output4, "Output 4 may not be null");

      if (_shouldRemapInputs) {
        Map<Producer<?>, Producer<?>> inputMapping = DAGUtil.createInputMap(_input1, _placeholder1);
        output1 = DAGUtil.replaceInputs(output1, inputMapping);
        output2 = DAGUtil.replaceInputs(output2, inputMapping);
        output3 = DAGUtil.replaceInputs(output3, inputMapping);
        output4 = DAGUtil.replaceInputs(output4, inputMapping);
      }

      List<Producer<?>> inputs = Arrays.asList(_input1);

      return ((DAG1x4) DAGUtil
          .createPreparableDAG(Arrays.asList(_placeholder1), Arrays.asList(output1, output2, output3, output4))
          .internalAPI().withInputsUnsafe(inputs)).withReduction(_minimumReducerLevel);
    }

    /**
     * Creates a completed DAG by supplying this partial DAG with its outputs (outputs).
     *
     * @param output1 the first output (output) of the DAG
     * @param output2 the second output (output) of the DAG
     * @param output3 the third output (output) of the DAG
     * @param output4 the fourth output (output) of the DAG
     * @param output5 the fifth output (output) of the DAG
     * @param <RA> the type of the first result
     * @param <RB> the type of the second result
     * @param <RC> the type of the third result
     * @param <RD> the type of the fourth result
     * @param <RE> the type of the fifth result
     * @return a completed DAG with 1 input (placeholders) and 5 outputs (outputs).
     */
    public <RA, RB, RC, RD, RE> DAG1x5<A, RA, RB, RC, RD, RE> withOutputs(Producer<? extends RA> output1,
        Producer<? extends RB> output2, Producer<? extends RC> output3, Producer<? extends RD> output4,
        Producer<? extends RE> output5) {
      Objects.requireNonNull(output1, "Output 1 may not be null");
      Objects.requireNonNull(output2, "Output 2 may not be null");
      Objects.requireNonNull(output3, "Output 3 may not be null");
      Objects.requireNonNull(output4, "Output 4 may not be null");
      Objects.requireNonNull(output5, "Output 5 may not be null");

      if (_shouldRemapInputs) {
        Map<Producer<?>, Producer<?>> inputMapping = DAGUtil.createInputMap(_input1, _placeholder1);
        output1 = DAGUtil.replaceInputs(output1, inputMapping);
        output2 = DAGUtil.replaceInputs(output2, inputMapping);
        output3 = DAGUtil.replaceInputs(output3, inputMapping);
        output4 = DAGUtil.replaceInputs(output4, inputMapping);
        output5 = DAGUtil.replaceInputs(output5, inputMapping);
      }

      List<Producer<?>> inputs = Arrays.asList(_input1);

      return ((DAG1x5) DAGUtil
          .createPreparableDAG(Arrays.asList(_placeholder1), Arrays.asList(output1, output2, output3, output4, output5))
          .internalAPI().withInputsUnsafe(inputs)).withReduction(_minimumReducerLevel);
    }

    /**
     * Creates a completed DAG by supplying this partial DAG with its outputs (outputs).
     *
     * @param output1 the first output (output) of the DAG
     * @param output2 the second output (output) of the DAG
     * @param output3 the third output (output) of the DAG
     * @param output4 the fourth output (output) of the DAG
     * @param output5 the fifth output (output) of the DAG
     * @param output6 the sixth output (output) of the DAG
     * @param <RA> the type of the first result
     * @param <RB> the type of the second result
     * @param <RC> the type of the third result
     * @param <RD> the type of the fourth result
     * @param <RE> the type of the fifth result
     * @param <RF> the type of the sixth result
     * @return a completed DAG with 1 input (placeholders) and 6 outputs (outputs).
     */
    public <RA, RB, RC, RD, RE, RF> DAG1x6<A, RA, RB, RC, RD, RE, RF> withOutputs(Producer<? extends RA> output1,
        Producer<? extends RB> output2, Producer<? extends RC> output3, Producer<? extends RD> output4,
        Producer<? extends RE> output5, Producer<? extends RF> output6) {
      Objects.requireNonNull(output1, "Output 1 may not be null");
      Objects.requireNonNull(output2, "Output 2 may not be null");
      Objects.requireNonNull(output3, "Output 3 may not be null");
      Objects.requireNonNull(output4, "Output 4 may not be null");
      Objects.requireNonNull(output5, "Output 5 may not be null");
      Objects.requireNonNull(output6, "Output 6 may not be null");

      if (_shouldRemapInputs) {
        Map<Producer<?>, Producer<?>> inputMapping = DAGUtil.createInputMap(_input1, _placeholder1);
        output1 = DAGUtil.replaceInputs(output1, inputMapping);
        output2 = DAGUtil.replaceInputs(output2, inputMapping);
        output3 = DAGUtil.replaceInputs(output3, inputMapping);
        output4 = DAGUtil.replaceInputs(output4, inputMapping);
        output5 = DAGUtil.replaceInputs(output5, inputMapping);
        output6 = DAGUtil.replaceInputs(output6, inputMapping);
      }

      List<Producer<?>> inputs = Arrays.asList(_input1);

      return ((DAG1x6) DAGUtil
          .createPreparableDAG(Arrays.asList(_placeholder1),
              Arrays.asList(output1, output2, output3, output4, output5, output6)).internalAPI()
          .withInputsUnsafe(inputs)).withReduction(_minimumReducerLevel);
    }

    /**
     * Creates a completed DAG by supplying this partial DAG with its outputs (outputs).
     *
     * @param output1 the first output (output) of the DAG
     * @param output2 the second output (output) of the DAG
     * @param output3 the third output (output) of the DAG
     * @param output4 the fourth output (output) of the DAG
     * @param output5 the fifth output (output) of the DAG
     * @param output6 the sixth output (output) of the DAG
     * @param output7 the seventh output (output) of the DAG
     * @param <RA> the type of the first result
     * @param <RB> the type of the second result
     * @param <RC> the type of the third result
     * @param <RD> the type of the fourth result
     * @param <RE> the type of the fifth result
     * @param <RF> the type of the sixth result
     * @param <RG> the type of the seventh result
     * @return a completed DAG with 1 input (placeholders) and 7 outputs (outputs).
     */
    public <RA, RB, RC, RD, RE, RF, RG> DAG1x7<A, RA, RB, RC, RD, RE, RF, RG> withOutputs(
        Producer<? extends RA> output1, Producer<? extends RB> output2, Producer<? extends RC> output3,
        Producer<? extends RD> output4, Producer<? extends RE> output5, Producer<? extends RF> output6,
        Producer<? extends RG> output7) {
      Objects.requireNonNull(output1, "Output 1 may not be null");
      Objects.requireNonNull(output2, "Output 2 may not be null");
      Objects.requireNonNull(output3, "Output 3 may not be null");
      Objects.requireNonNull(output4, "Output 4 may not be null");
      Objects.requireNonNull(output5, "Output 5 may not be null");
      Objects.requireNonNull(output6, "Output 6 may not be null");
      Objects.requireNonNull(output7, "Output 7 may not be null");

      if (_shouldRemapInputs) {
        Map<Producer<?>, Producer<?>> inputMapping = DAGUtil.createInputMap(_input1, _placeholder1);
        output1 = DAGUtil.replaceInputs(output1, inputMapping);
        output2 = DAGUtil.replaceInputs(output2, inputMapping);
        output3 = DAGUtil.replaceInputs(output3, inputMapping);
        output4 = DAGUtil.replaceInputs(output4, inputMapping);
        output5 = DAGUtil.replaceInputs(output5, inputMapping);
        output6 = DAGUtil.replaceInputs(output6, inputMapping);
        output7 = DAGUtil.replaceInputs(output7, inputMapping);
      }

      List<Producer<?>> inputs = Arrays.asList(_input1);

      return ((DAG1x7) DAGUtil
          .createPreparableDAG(Arrays.asList(_placeholder1),
              Arrays.asList(output1, output2, output3, output4, output5, output6, output7)).internalAPI()
          .withInputsUnsafe(inputs)).withReduction(_minimumReducerLevel);
    }

    /**
     * Creates a completed DAG by supplying this partial DAG with its outputs (outputs).
     *
     * @param output1 the first output (output) of the DAG
     * @param output2 the second output (output) of the DAG
     * @param output3 the third output (output) of the DAG
     * @param output4 the fourth output (output) of the DAG
     * @param output5 the fifth output (output) of the DAG
     * @param output6 the sixth output (output) of the DAG
     * @param output7 the seventh output (output) of the DAG
     * @param output8 the eighth output (output) of the DAG
     * @param <RA> the type of the first result
     * @param <RB> the type of the second result
     * @param <RC> the type of the third result
     * @param <RD> the type of the fourth result
     * @param <RE> the type of the fifth result
     * @param <RF> the type of the sixth result
     * @param <RG> the type of the seventh result
     * @param <RH> the type of the eighth result
     * @return a completed DAG with 1 input (placeholders) and 8 outputs (outputs).
     */
    public <RA, RB, RC, RD, RE, RF, RG, RH> DAG1x8<A, RA, RB, RC, RD, RE, RF, RG, RH> withOutputs(
        Producer<? extends RA> output1, Producer<? extends RB> output2, Producer<? extends RC> output3,
        Producer<? extends RD> output4, Producer<? extends RE> output5, Producer<? extends RF> output6,
        Producer<? extends RG> output7, Producer<? extends RH> output8) {
      Objects.requireNonNull(output1, "Output 1 may not be null");
      Objects.requireNonNull(output2, "Output 2 may not be null");
      Objects.requireNonNull(output3, "Output 3 may not be null");
      Objects.requireNonNull(output4, "Output 4 may not be null");
      Objects.requireNonNull(output5, "Output 5 may not be null");
      Objects.requireNonNull(output6, "Output 6 may not be null");
      Objects.requireNonNull(output7, "Output 7 may not be null");
      Objects.requireNonNull(output8, "Output 8 may not be null");

      if (_shouldRemapInputs) {
        Map<Producer<?>, Producer<?>> inputMapping = DAGUtil.createInputMap(_input1, _placeholder1);
        output1 = DAGUtil.replaceInputs(output1, inputMapping);
        output2 = DAGUtil.replaceInputs(output2, inputMapping);
        output3 = DAGUtil.replaceInputs(output3, inputMapping);
        output4 = DAGUtil.replaceInputs(output4, inputMapping);
        output5 = DAGUtil.replaceInputs(output5, inputMapping);
        output6 = DAGUtil.replaceInputs(output6, inputMapping);
        output7 = DAGUtil.replaceInputs(output7, inputMapping);
        output8 = DAGUtil.replaceInputs(output8, inputMapping);
      }

      List<Producer<?>> inputs = Arrays.asList(_input1);

      return ((DAG1x8) DAGUtil
          .createPreparableDAG(Arrays.asList(_placeholder1),
              Arrays.asList(output1, output2, output3, output4, output5, output6, output7, output8)).internalAPI()
          .withInputsUnsafe(inputs)).withReduction(_minimumReducerLevel);
    }

    /**
     * Creates a completed DAG by supplying this partial DAG with its outputs (outputs).
     *
     * @param output1 the first output (output) of the DAG
     * @param output2 the second output (output) of the DAG
     * @param output3 the third output (output) of the DAG
     * @param output4 the fourth output (output) of the DAG
     * @param output5 the fifth output (output) of the DAG
     * @param output6 the sixth output (output) of the DAG
     * @param output7 the seventh output (output) of the DAG
     * @param output8 the eighth output (output) of the DAG
     * @param output9 the ninth output (output) of the DAG
     * @param <RA> the type of the first result
     * @param <RB> the type of the second result
     * @param <RC> the type of the third result
     * @param <RD> the type of the fourth result
     * @param <RE> the type of the fifth result
     * @param <RF> the type of the sixth result
     * @param <RG> the type of the seventh result
     * @param <RH> the type of the eighth result
     * @param <RI> the type of the ninth result
     * @return a completed DAG with 1 input (placeholders) and 9 outputs (outputs).
     */
    public <RA, RB, RC, RD, RE, RF, RG, RH, RI> DAG1x9<A, RA, RB, RC, RD, RE, RF, RG, RH, RI> withOutputs(
        Producer<? extends RA> output1, Producer<? extends RB> output2, Producer<? extends RC> output3,
        Producer<? extends RD> output4, Producer<? extends RE> output5, Producer<? extends RF> output6,
        Producer<? extends RG> output7, Producer<? extends RH> output8, Producer<? extends RI> output9) {
      Objects.requireNonNull(output1, "Output 1 may not be null");
      Objects.requireNonNull(output2, "Output 2 may not be null");
      Objects.requireNonNull(output3, "Output 3 may not be null");
      Objects.requireNonNull(output4, "Output 4 may not be null");
      Objects.requireNonNull(output5, "Output 5 may not be null");
      Objects.requireNonNull(output6, "Output 6 may not be null");
      Objects.requireNonNull(output7, "Output 7 may not be null");
      Objects.requireNonNull(output8, "Output 8 may not be null");
      Objects.requireNonNull(output9, "Output 9 may not be null");

      if (_shouldRemapInputs) {
        Map<Producer<?>, Producer<?>> inputMapping = DAGUtil.createInputMap(_input1, _placeholder1);
        output1 = DAGUtil.replaceInputs(output1, inputMapping);
        output2 = DAGUtil.replaceInputs(output2, inputMapping);
        output3 = DAGUtil.replaceInputs(output3, inputMapping);
        output4 = DAGUtil.replaceInputs(output4, inputMapping);
        output5 = DAGUtil.replaceInputs(output5, inputMapping);
        output6 = DAGUtil.replaceInputs(output6, inputMapping);
        output7 = DAGUtil.replaceInputs(output7, inputMapping);
        output8 = DAGUtil.replaceInputs(output8, inputMapping);
        output9 = DAGUtil.replaceInputs(output9, inputMapping);
      }

      List<Producer<?>> inputs = Arrays.asList(_input1);

      return ((DAG1x9) DAGUtil
          .createPreparableDAG(Arrays.asList(_placeholder1),
              Arrays.asList(output1, output2, output3, output4, output5, output6, output7, output8, output9))
          .internalAPI().withInputsUnsafe(inputs)).withReduction(_minimumReducerLevel);
    }

    /**
     * Creates a completed DAG by supplying this partial DAG with its outputs (outputs).
     *
     * @param output1 the first output (output) of the DAG
     * @param output2 the second output (output) of the DAG
     * @param output3 the third output (output) of the DAG
     * @param output4 the fourth output (output) of the DAG
     * @param output5 the fifth output (output) of the DAG
     * @param output6 the sixth output (output) of the DAG
     * @param output7 the seventh output (output) of the DAG
     * @param output8 the eighth output (output) of the DAG
     * @param output9 the ninth output (output) of the DAG
     * @param output10 the tenth output (output) of the DAG
     * @param <RA> the type of the first result
     * @param <RB> the type of the second result
     * @param <RC> the type of the third result
     * @param <RD> the type of the fourth result
     * @param <RE> the type of the fifth result
     * @param <RF> the type of the sixth result
     * @param <RG> the type of the seventh result
     * @param <RH> the type of the eighth result
     * @param <RI> the type of the ninth result
     * @param <RJ> the type of the tenth result
     * @return a completed DAG with 1 input (placeholders) and 10 outputs (outputs).
     */
    public <RA, RB, RC, RD, RE, RF, RG, RH, RI, RJ> DAG1x10<A, RA, RB, RC, RD, RE, RF, RG, RH, RI, RJ> withOutputs(
        Producer<? extends RA> output1, Producer<? extends RB> output2, Producer<? extends RC> output3,
        Producer<? extends RD> output4, Producer<? extends RE> output5, Producer<? extends RF> output6,
        Producer<? extends RG> output7, Producer<? extends RH> output8, Producer<? extends RI> output9,
        Producer<? extends RJ> output10) {
      Objects.requireNonNull(output1, "Output 1 may not be null");
      Objects.requireNonNull(output2, "Output 2 may not be null");
      Objects.requireNonNull(output3, "Output 3 may not be null");
      Objects.requireNonNull(output4, "Output 4 may not be null");
      Objects.requireNonNull(output5, "Output 5 may not be null");
      Objects.requireNonNull(output6, "Output 6 may not be null");
      Objects.requireNonNull(output7, "Output 7 may not be null");
      Objects.requireNonNull(output8, "Output 8 may not be null");
      Objects.requireNonNull(output9, "Output 9 may not be null");
      Objects.requireNonNull(output10, "Output 10 may not be null");

      if (_shouldRemapInputs) {
        Map<Producer<?>, Producer<?>> inputMapping = DAGUtil.createInputMap(_input1, _placeholder1);
        output1 = DAGUtil.replaceInputs(output1, inputMapping);
        output2 = DAGUtil.replaceInputs(output2, inputMapping);
        output3 = DAGUtil.replaceInputs(output3, inputMapping);
        output4 = DAGUtil.replaceInputs(output4, inputMapping);
        output5 = DAGUtil.replaceInputs(output5, inputMapping);
        output6 = DAGUtil.replaceInputs(output6, inputMapping);
        output7 = DAGUtil.replaceInputs(output7, inputMapping);
        output8 = DAGUtil.replaceInputs(output8, inputMapping);
        output9 = DAGUtil.replaceInputs(output9, inputMapping);
        output10 = DAGUtil.replaceInputs(output10, inputMapping);
      }

      List<Producer<?>> inputs = Arrays.asList(_input1);

      return ((DAG1x10) DAGUtil
          .createPreparableDAG(Arrays.asList(_placeholder1),
              Arrays.asList(output1, output2, output3, output4, output5, output6, output7, output8, output9, output10))
          .internalAPI().withInputsUnsafe(inputs)).withReduction(_minimumReducerLevel);
    }
  }

  /**
    * A partial DAG with 2 placeholder.  Partial DAGs are <i>completed</i> to create a usable DAG by specifying
    * the outputs (<i>outputs</i>) of the DAG using the withOutputs(...) methods.
    *
   * @param <A> the type of the first input
   * @param <B> the type of the second input
    */
  public static class WithPlaceholders2<A, B> extends AbstractWithPlaceholders2<A, B, WithPlaceholders2<A, B>> {
    /**
     * Creates a new partial DAG that will be rooted at the provided placeholders.
     *
     * @param placeholder1 the first placeholder
     * @param placeholder2 the second placeholder
     */
    WithPlaceholders2(Placeholder<? extends A> placeholder1, Placeholder<? extends B> placeholder2) {
      super(placeholder1, placeholder2);
    }

    /**
     * Creates a new partial DAG that will be rooted at the provided placeholders, which will replace ("remap") the provided
     * "input" nodes that define a subgraph of the original graph (as defined by the ancestors of the outputs that will
     * be provided when the partial DAG is completed).  The input nodes, and any nodes that were exclusively the
     * ancestors of the input nodes, are truncated from the resulting graph.
     *
     * @param placeholder1 the first placeholder
     * @param placeholder2 the second placeholder
     * @param input1 the first input
     * @param input2 the second input
     */
    WithPlaceholders2(Placeholder<? extends A> placeholder1, Placeholder<? extends B> placeholder2,
        Producer<? extends A> input1, Producer<? extends B> input2) {
      super(placeholder1, placeholder2, input1, input2);
    }

    /**
     * Creates a completed DAG by supplying this partial DAG with its outputs (outputs).
     *
     * @param output1 the first output (output) of the DAG
     * @param <RA> the type of the first result
     * @return a completed DAG with 2 inputs (placeholders) and 1 output (outputs).
     */
    public <RA> DAG2x1<A, B, RA> withOutputs(Producer<? extends RA> output1) {
      Objects.requireNonNull(output1, "Output 1 may not be null");

      if (_shouldRemapInputs) {
        Map<Producer<?>, Producer<?>> inputMapping =
            DAGUtil.createInputMap(_input1, _placeholder1, _input2, _placeholder2);
        output1 = DAGUtil.replaceInputs(output1, inputMapping);
      }

      List<Producer<?>> inputs = Arrays.asList(_input1, _input2);

      return ((DAG2x1) DAGUtil.createPreparableDAG(Arrays.asList(_placeholder1, _placeholder2), Arrays.asList(output1))
          .internalAPI().withInputsUnsafe(inputs)).withReduction(_minimumReducerLevel);
    }

    /**
     * Creates a completed DAG by supplying this partial DAG with its outputs (outputs).
     *
     * @param output1 the first output (output) of the DAG
     * @param <RA> the type of the first result
     * @return a completed DAG with 2 inputs (placeholders) and 1 output (outputs).
     */
    public <RA> DAG2x1<A, B, RA> withOutput(Producer<? extends RA> output1) {
      Objects.requireNonNull(output1, "Output 1 may not be null");

      if (_shouldRemapInputs) {
        Map<Producer<?>, Producer<?>> inputMapping =
            DAGUtil.createInputMap(_input1, _placeholder1, _input2, _placeholder2);
        output1 = DAGUtil.replaceInputs(output1, inputMapping);
      }

      List<Producer<?>> inputs = Arrays.asList(_input1, _input2);

      return ((DAG2x1) DAGUtil.createPreparableDAG(Arrays.asList(_placeholder1, _placeholder2), Arrays.asList(output1))
          .internalAPI().withInputsUnsafe(inputs)).withReduction(_minimumReducerLevel);
    }

    /**
     * Creates a completed DAG by supplying this partial DAG with its outputs (outputs).
     *
     * @param output1 the first output (output) of the DAG
     * @param output2 the second output (output) of the DAG
     * @param <RA> the type of the first result
     * @param <RB> the type of the second result
     * @return a completed DAG with 2 inputs (placeholders) and 2 outputs (outputs).
     */
    public <RA, RB> DAG2x2<A, B, RA, RB> withOutputs(Producer<? extends RA> output1, Producer<? extends RB> output2) {
      Objects.requireNonNull(output1, "Output 1 may not be null");
      Objects.requireNonNull(output2, "Output 2 may not be null");

      if (_shouldRemapInputs) {
        Map<Producer<?>, Producer<?>> inputMapping =
            DAGUtil.createInputMap(_input1, _placeholder1, _input2, _placeholder2);
        output1 = DAGUtil.replaceInputs(output1, inputMapping);
        output2 = DAGUtil.replaceInputs(output2, inputMapping);
      }

      List<Producer<?>> inputs = Arrays.asList(_input1, _input2);

      return ((DAG2x2) DAGUtil
          .createPreparableDAG(Arrays.asList(_placeholder1, _placeholder2), Arrays.asList(output1, output2))
          .internalAPI().withInputsUnsafe(inputs)).withReduction(_minimumReducerLevel);
    }

    /**
     * Creates a completed DAG by supplying this partial DAG with its outputs (outputs).
     *
     * @param output1 the first output (output) of the DAG
     * @param output2 the second output (output) of the DAG
     * @param output3 the third output (output) of the DAG
     * @param <RA> the type of the first result
     * @param <RB> the type of the second result
     * @param <RC> the type of the third result
     * @return a completed DAG with 2 inputs (placeholders) and 3 outputs (outputs).
     */
    public <RA, RB, RC> DAG2x3<A, B, RA, RB, RC> withOutputs(Producer<? extends RA> output1,
        Producer<? extends RB> output2, Producer<? extends RC> output3) {
      Objects.requireNonNull(output1, "Output 1 may not be null");
      Objects.requireNonNull(output2, "Output 2 may not be null");
      Objects.requireNonNull(output3, "Output 3 may not be null");

      if (_shouldRemapInputs) {
        Map<Producer<?>, Producer<?>> inputMapping =
            DAGUtil.createInputMap(_input1, _placeholder1, _input2, _placeholder2);
        output1 = DAGUtil.replaceInputs(output1, inputMapping);
        output2 = DAGUtil.replaceInputs(output2, inputMapping);
        output3 = DAGUtil.replaceInputs(output3, inputMapping);
      }

      List<Producer<?>> inputs = Arrays.asList(_input1, _input2);

      return ((DAG2x3) DAGUtil
          .createPreparableDAG(Arrays.asList(_placeholder1, _placeholder2), Arrays.asList(output1, output2, output3))
          .internalAPI().withInputsUnsafe(inputs)).withReduction(_minimumReducerLevel);
    }

    /**
     * Creates a completed DAG by supplying this partial DAG with its outputs (outputs).
     *
     * @param output1 the first output (output) of the DAG
     * @param output2 the second output (output) of the DAG
     * @param output3 the third output (output) of the DAG
     * @param output4 the fourth output (output) of the DAG
     * @param <RA> the type of the first result
     * @param <RB> the type of the second result
     * @param <RC> the type of the third result
     * @param <RD> the type of the fourth result
     * @return a completed DAG with 2 inputs (placeholders) and 4 outputs (outputs).
     */
    public <RA, RB, RC, RD> DAG2x4<A, B, RA, RB, RC, RD> withOutputs(Producer<? extends RA> output1,
        Producer<? extends RB> output2, Producer<? extends RC> output3, Producer<? extends RD> output4) {
      Objects.requireNonNull(output1, "Output 1 may not be null");
      Objects.requireNonNull(output2, "Output 2 may not be null");
      Objects.requireNonNull(output3, "Output 3 may not be null");
      Objects.requireNonNull(output4, "Output 4 may not be null");

      if (_shouldRemapInputs) {
        Map<Producer<?>, Producer<?>> inputMapping =
            DAGUtil.createInputMap(_input1, _placeholder1, _input2, _placeholder2);
        output1 = DAGUtil.replaceInputs(output1, inputMapping);
        output2 = DAGUtil.replaceInputs(output2, inputMapping);
        output3 = DAGUtil.replaceInputs(output3, inputMapping);
        output4 = DAGUtil.replaceInputs(output4, inputMapping);
      }

      List<Producer<?>> inputs = Arrays.asList(_input1, _input2);

      return ((DAG2x4) DAGUtil
          .createPreparableDAG(Arrays.asList(_placeholder1, _placeholder2),
              Arrays.asList(output1, output2, output3, output4)).internalAPI().withInputsUnsafe(inputs))
          .withReduction(_minimumReducerLevel);
    }

    /**
     * Creates a completed DAG by supplying this partial DAG with its outputs (outputs).
     *
     * @param output1 the first output (output) of the DAG
     * @param output2 the second output (output) of the DAG
     * @param output3 the third output (output) of the DAG
     * @param output4 the fourth output (output) of the DAG
     * @param output5 the fifth output (output) of the DAG
     * @param <RA> the type of the first result
     * @param <RB> the type of the second result
     * @param <RC> the type of the third result
     * @param <RD> the type of the fourth result
     * @param <RE> the type of the fifth result
     * @return a completed DAG with 2 inputs (placeholders) and 5 outputs (outputs).
     */
    public <RA, RB, RC, RD, RE> DAG2x5<A, B, RA, RB, RC, RD, RE> withOutputs(Producer<? extends RA> output1,
        Producer<? extends RB> output2, Producer<? extends RC> output3, Producer<? extends RD> output4,
        Producer<? extends RE> output5) {
      Objects.requireNonNull(output1, "Output 1 may not be null");
      Objects.requireNonNull(output2, "Output 2 may not be null");
      Objects.requireNonNull(output3, "Output 3 may not be null");
      Objects.requireNonNull(output4, "Output 4 may not be null");
      Objects.requireNonNull(output5, "Output 5 may not be null");

      if (_shouldRemapInputs) {
        Map<Producer<?>, Producer<?>> inputMapping =
            DAGUtil.createInputMap(_input1, _placeholder1, _input2, _placeholder2);
        output1 = DAGUtil.replaceInputs(output1, inputMapping);
        output2 = DAGUtil.replaceInputs(output2, inputMapping);
        output3 = DAGUtil.replaceInputs(output3, inputMapping);
        output4 = DAGUtil.replaceInputs(output4, inputMapping);
        output5 = DAGUtil.replaceInputs(output5, inputMapping);
      }

      List<Producer<?>> inputs = Arrays.asList(_input1, _input2);

      return ((DAG2x5) DAGUtil
          .createPreparableDAG(Arrays.asList(_placeholder1, _placeholder2),
              Arrays.asList(output1, output2, output3, output4, output5)).internalAPI().withInputsUnsafe(inputs))
          .withReduction(_minimumReducerLevel);
    }

    /**
     * Creates a completed DAG by supplying this partial DAG with its outputs (outputs).
     *
     * @param output1 the first output (output) of the DAG
     * @param output2 the second output (output) of the DAG
     * @param output3 the third output (output) of the DAG
     * @param output4 the fourth output (output) of the DAG
     * @param output5 the fifth output (output) of the DAG
     * @param output6 the sixth output (output) of the DAG
     * @param <RA> the type of the first result
     * @param <RB> the type of the second result
     * @param <RC> the type of the third result
     * @param <RD> the type of the fourth result
     * @param <RE> the type of the fifth result
     * @param <RF> the type of the sixth result
     * @return a completed DAG with 2 inputs (placeholders) and 6 outputs (outputs).
     */
    public <RA, RB, RC, RD, RE, RF> DAG2x6<A, B, RA, RB, RC, RD, RE, RF> withOutputs(Producer<? extends RA> output1,
        Producer<? extends RB> output2, Producer<? extends RC> output3, Producer<? extends RD> output4,
        Producer<? extends RE> output5, Producer<? extends RF> output6) {
      Objects.requireNonNull(output1, "Output 1 may not be null");
      Objects.requireNonNull(output2, "Output 2 may not be null");
      Objects.requireNonNull(output3, "Output 3 may not be null");
      Objects.requireNonNull(output4, "Output 4 may not be null");
      Objects.requireNonNull(output5, "Output 5 may not be null");
      Objects.requireNonNull(output6, "Output 6 may not be null");

      if (_shouldRemapInputs) {
        Map<Producer<?>, Producer<?>> inputMapping =
            DAGUtil.createInputMap(_input1, _placeholder1, _input2, _placeholder2);
        output1 = DAGUtil.replaceInputs(output1, inputMapping);
        output2 = DAGUtil.replaceInputs(output2, inputMapping);
        output3 = DAGUtil.replaceInputs(output3, inputMapping);
        output4 = DAGUtil.replaceInputs(output4, inputMapping);
        output5 = DAGUtil.replaceInputs(output5, inputMapping);
        output6 = DAGUtil.replaceInputs(output6, inputMapping);
      }

      List<Producer<?>> inputs = Arrays.asList(_input1, _input2);

      return ((DAG2x6) DAGUtil
          .createPreparableDAG(Arrays.asList(_placeholder1, _placeholder2),
              Arrays.asList(output1, output2, output3, output4, output5, output6)).internalAPI()
          .withInputsUnsafe(inputs)).withReduction(_minimumReducerLevel);
    }

    /**
     * Creates a completed DAG by supplying this partial DAG with its outputs (outputs).
     *
     * @param output1 the first output (output) of the DAG
     * @param output2 the second output (output) of the DAG
     * @param output3 the third output (output) of the DAG
     * @param output4 the fourth output (output) of the DAG
     * @param output5 the fifth output (output) of the DAG
     * @param output6 the sixth output (output) of the DAG
     * @param output7 the seventh output (output) of the DAG
     * @param <RA> the type of the first result
     * @param <RB> the type of the second result
     * @param <RC> the type of the third result
     * @param <RD> the type of the fourth result
     * @param <RE> the type of the fifth result
     * @param <RF> the type of the sixth result
     * @param <RG> the type of the seventh result
     * @return a completed DAG with 2 inputs (placeholders) and 7 outputs (outputs).
     */
    public <RA, RB, RC, RD, RE, RF, RG> DAG2x7<A, B, RA, RB, RC, RD, RE, RF, RG> withOutputs(
        Producer<? extends RA> output1, Producer<? extends RB> output2, Producer<? extends RC> output3,
        Producer<? extends RD> output4, Producer<? extends RE> output5, Producer<? extends RF> output6,
        Producer<? extends RG> output7) {
      Objects.requireNonNull(output1, "Output 1 may not be null");
      Objects.requireNonNull(output2, "Output 2 may not be null");
      Objects.requireNonNull(output3, "Output 3 may not be null");
      Objects.requireNonNull(output4, "Output 4 may not be null");
      Objects.requireNonNull(output5, "Output 5 may not be null");
      Objects.requireNonNull(output6, "Output 6 may not be null");
      Objects.requireNonNull(output7, "Output 7 may not be null");

      if (_shouldRemapInputs) {
        Map<Producer<?>, Producer<?>> inputMapping =
            DAGUtil.createInputMap(_input1, _placeholder1, _input2, _placeholder2);
        output1 = DAGUtil.replaceInputs(output1, inputMapping);
        output2 = DAGUtil.replaceInputs(output2, inputMapping);
        output3 = DAGUtil.replaceInputs(output3, inputMapping);
        output4 = DAGUtil.replaceInputs(output4, inputMapping);
        output5 = DAGUtil.replaceInputs(output5, inputMapping);
        output6 = DAGUtil.replaceInputs(output6, inputMapping);
        output7 = DAGUtil.replaceInputs(output7, inputMapping);
      }

      List<Producer<?>> inputs = Arrays.asList(_input1, _input2);

      return ((DAG2x7) DAGUtil
          .createPreparableDAG(Arrays.asList(_placeholder1, _placeholder2),
              Arrays.asList(output1, output2, output3, output4, output5, output6, output7)).internalAPI()
          .withInputsUnsafe(inputs)).withReduction(_minimumReducerLevel);
    }

    /**
     * Creates a completed DAG by supplying this partial DAG with its outputs (outputs).
     *
     * @param output1 the first output (output) of the DAG
     * @param output2 the second output (output) of the DAG
     * @param output3 the third output (output) of the DAG
     * @param output4 the fourth output (output) of the DAG
     * @param output5 the fifth output (output) of the DAG
     * @param output6 the sixth output (output) of the DAG
     * @param output7 the seventh output (output) of the DAG
     * @param output8 the eighth output (output) of the DAG
     * @param <RA> the type of the first result
     * @param <RB> the type of the second result
     * @param <RC> the type of the third result
     * @param <RD> the type of the fourth result
     * @param <RE> the type of the fifth result
     * @param <RF> the type of the sixth result
     * @param <RG> the type of the seventh result
     * @param <RH> the type of the eighth result
     * @return a completed DAG with 2 inputs (placeholders) and 8 outputs (outputs).
     */
    public <RA, RB, RC, RD, RE, RF, RG, RH> DAG2x8<A, B, RA, RB, RC, RD, RE, RF, RG, RH> withOutputs(
        Producer<? extends RA> output1, Producer<? extends RB> output2, Producer<? extends RC> output3,
        Producer<? extends RD> output4, Producer<? extends RE> output5, Producer<? extends RF> output6,
        Producer<? extends RG> output7, Producer<? extends RH> output8) {
      Objects.requireNonNull(output1, "Output 1 may not be null");
      Objects.requireNonNull(output2, "Output 2 may not be null");
      Objects.requireNonNull(output3, "Output 3 may not be null");
      Objects.requireNonNull(output4, "Output 4 may not be null");
      Objects.requireNonNull(output5, "Output 5 may not be null");
      Objects.requireNonNull(output6, "Output 6 may not be null");
      Objects.requireNonNull(output7, "Output 7 may not be null");
      Objects.requireNonNull(output8, "Output 8 may not be null");

      if (_shouldRemapInputs) {
        Map<Producer<?>, Producer<?>> inputMapping =
            DAGUtil.createInputMap(_input1, _placeholder1, _input2, _placeholder2);
        output1 = DAGUtil.replaceInputs(output1, inputMapping);
        output2 = DAGUtil.replaceInputs(output2, inputMapping);
        output3 = DAGUtil.replaceInputs(output3, inputMapping);
        output4 = DAGUtil.replaceInputs(output4, inputMapping);
        output5 = DAGUtil.replaceInputs(output5, inputMapping);
        output6 = DAGUtil.replaceInputs(output6, inputMapping);
        output7 = DAGUtil.replaceInputs(output7, inputMapping);
        output8 = DAGUtil.replaceInputs(output8, inputMapping);
      }

      List<Producer<?>> inputs = Arrays.asList(_input1, _input2);

      return ((DAG2x8) DAGUtil
          .createPreparableDAG(Arrays.asList(_placeholder1, _placeholder2),
              Arrays.asList(output1, output2, output3, output4, output5, output6, output7, output8)).internalAPI()
          .withInputsUnsafe(inputs)).withReduction(_minimumReducerLevel);
    }

    /**
     * Creates a completed DAG by supplying this partial DAG with its outputs (outputs).
     *
     * @param output1 the first output (output) of the DAG
     * @param output2 the second output (output) of the DAG
     * @param output3 the third output (output) of the DAG
     * @param output4 the fourth output (output) of the DAG
     * @param output5 the fifth output (output) of the DAG
     * @param output6 the sixth output (output) of the DAG
     * @param output7 the seventh output (output) of the DAG
     * @param output8 the eighth output (output) of the DAG
     * @param output9 the ninth output (output) of the DAG
     * @param <RA> the type of the first result
     * @param <RB> the type of the second result
     * @param <RC> the type of the third result
     * @param <RD> the type of the fourth result
     * @param <RE> the type of the fifth result
     * @param <RF> the type of the sixth result
     * @param <RG> the type of the seventh result
     * @param <RH> the type of the eighth result
     * @param <RI> the type of the ninth result
     * @return a completed DAG with 2 inputs (placeholders) and 9 outputs (outputs).
     */
    public <RA, RB, RC, RD, RE, RF, RG, RH, RI> DAG2x9<A, B, RA, RB, RC, RD, RE, RF, RG, RH, RI> withOutputs(
        Producer<? extends RA> output1, Producer<? extends RB> output2, Producer<? extends RC> output3,
        Producer<? extends RD> output4, Producer<? extends RE> output5, Producer<? extends RF> output6,
        Producer<? extends RG> output7, Producer<? extends RH> output8, Producer<? extends RI> output9) {
      Objects.requireNonNull(output1, "Output 1 may not be null");
      Objects.requireNonNull(output2, "Output 2 may not be null");
      Objects.requireNonNull(output3, "Output 3 may not be null");
      Objects.requireNonNull(output4, "Output 4 may not be null");
      Objects.requireNonNull(output5, "Output 5 may not be null");
      Objects.requireNonNull(output6, "Output 6 may not be null");
      Objects.requireNonNull(output7, "Output 7 may not be null");
      Objects.requireNonNull(output8, "Output 8 may not be null");
      Objects.requireNonNull(output9, "Output 9 may not be null");

      if (_shouldRemapInputs) {
        Map<Producer<?>, Producer<?>> inputMapping =
            DAGUtil.createInputMap(_input1, _placeholder1, _input2, _placeholder2);
        output1 = DAGUtil.replaceInputs(output1, inputMapping);
        output2 = DAGUtil.replaceInputs(output2, inputMapping);
        output3 = DAGUtil.replaceInputs(output3, inputMapping);
        output4 = DAGUtil.replaceInputs(output4, inputMapping);
        output5 = DAGUtil.replaceInputs(output5, inputMapping);
        output6 = DAGUtil.replaceInputs(output6, inputMapping);
        output7 = DAGUtil.replaceInputs(output7, inputMapping);
        output8 = DAGUtil.replaceInputs(output8, inputMapping);
        output9 = DAGUtil.replaceInputs(output9, inputMapping);
      }

      List<Producer<?>> inputs = Arrays.asList(_input1, _input2);

      return ((DAG2x9) DAGUtil
          .createPreparableDAG(Arrays.asList(_placeholder1, _placeholder2),
              Arrays.asList(output1, output2, output3, output4, output5, output6, output7, output8, output9))
          .internalAPI().withInputsUnsafe(inputs)).withReduction(_minimumReducerLevel);
    }

    /**
     * Creates a completed DAG by supplying this partial DAG with its outputs (outputs).
     *
     * @param output1 the first output (output) of the DAG
     * @param output2 the second output (output) of the DAG
     * @param output3 the third output (output) of the DAG
     * @param output4 the fourth output (output) of the DAG
     * @param output5 the fifth output (output) of the DAG
     * @param output6 the sixth output (output) of the DAG
     * @param output7 the seventh output (output) of the DAG
     * @param output8 the eighth output (output) of the DAG
     * @param output9 the ninth output (output) of the DAG
     * @param output10 the tenth output (output) of the DAG
     * @param <RA> the type of the first result
     * @param <RB> the type of the second result
     * @param <RC> the type of the third result
     * @param <RD> the type of the fourth result
     * @param <RE> the type of the fifth result
     * @param <RF> the type of the sixth result
     * @param <RG> the type of the seventh result
     * @param <RH> the type of the eighth result
     * @param <RI> the type of the ninth result
     * @param <RJ> the type of the tenth result
     * @return a completed DAG with 2 inputs (placeholders) and 10 outputs (outputs).
     */
    public <RA, RB, RC, RD, RE, RF, RG, RH, RI, RJ> DAG2x10<A, B, RA, RB, RC, RD, RE, RF, RG, RH, RI, RJ> withOutputs(
        Producer<? extends RA> output1, Producer<? extends RB> output2, Producer<? extends RC> output3,
        Producer<? extends RD> output4, Producer<? extends RE> output5, Producer<? extends RF> output6,
        Producer<? extends RG> output7, Producer<? extends RH> output8, Producer<? extends RI> output9,
        Producer<? extends RJ> output10) {
      Objects.requireNonNull(output1, "Output 1 may not be null");
      Objects.requireNonNull(output2, "Output 2 may not be null");
      Objects.requireNonNull(output3, "Output 3 may not be null");
      Objects.requireNonNull(output4, "Output 4 may not be null");
      Objects.requireNonNull(output5, "Output 5 may not be null");
      Objects.requireNonNull(output6, "Output 6 may not be null");
      Objects.requireNonNull(output7, "Output 7 may not be null");
      Objects.requireNonNull(output8, "Output 8 may not be null");
      Objects.requireNonNull(output9, "Output 9 may not be null");
      Objects.requireNonNull(output10, "Output 10 may not be null");

      if (_shouldRemapInputs) {
        Map<Producer<?>, Producer<?>> inputMapping =
            DAGUtil.createInputMap(_input1, _placeholder1, _input2, _placeholder2);
        output1 = DAGUtil.replaceInputs(output1, inputMapping);
        output2 = DAGUtil.replaceInputs(output2, inputMapping);
        output3 = DAGUtil.replaceInputs(output3, inputMapping);
        output4 = DAGUtil.replaceInputs(output4, inputMapping);
        output5 = DAGUtil.replaceInputs(output5, inputMapping);
        output6 = DAGUtil.replaceInputs(output6, inputMapping);
        output7 = DAGUtil.replaceInputs(output7, inputMapping);
        output8 = DAGUtil.replaceInputs(output8, inputMapping);
        output9 = DAGUtil.replaceInputs(output9, inputMapping);
        output10 = DAGUtil.replaceInputs(output10, inputMapping);
      }

      List<Producer<?>> inputs = Arrays.asList(_input1, _input2);

      return ((DAG2x10) DAGUtil
          .createPreparableDAG(Arrays.asList(_placeholder1, _placeholder2),
              Arrays.asList(output1, output2, output3, output4, output5, output6, output7, output8, output9, output10))
          .internalAPI().withInputsUnsafe(inputs)).withReduction(_minimumReducerLevel);
    }
  }

  /**
    * A partial DAG with 3 placeholder.  Partial DAGs are <i>completed</i> to create a usable DAG by specifying
    * the outputs (<i>outputs</i>) of the DAG using the withOutputs(...) methods.
    *
   * @param <A> the type of the first input
   * @param <B> the type of the second input
   * @param <C> the type of the third input
    */
  public static class WithPlaceholders3<A, B, C> extends AbstractWithPlaceholders3<A, B, C, WithPlaceholders3<A, B, C>> {
    /**
     * Creates a new partial DAG that will be rooted at the provided placeholders.
     *
     * @param placeholder1 the first placeholder
     * @param placeholder2 the second placeholder
     * @param placeholder3 the third placeholder
     */
    WithPlaceholders3(Placeholder<? extends A> placeholder1, Placeholder<? extends B> placeholder2,
        Placeholder<? extends C> placeholder3) {
      super(placeholder1, placeholder2, placeholder3);
    }

    /**
     * Creates a new partial DAG that will be rooted at the provided placeholders, which will replace ("remap") the provided
     * "input" nodes that define a subgraph of the original graph (as defined by the ancestors of the outputs that will
     * be provided when the partial DAG is completed).  The input nodes, and any nodes that were exclusively the
     * ancestors of the input nodes, are truncated from the resulting graph.
     *
     * @param placeholder1 the first placeholder
     * @param placeholder2 the second placeholder
     * @param placeholder3 the third placeholder
     * @param input1 the first input
     * @param input2 the second input
     * @param input3 the third input
     */
    WithPlaceholders3(Placeholder<? extends A> placeholder1, Placeholder<? extends B> placeholder2,
        Placeholder<? extends C> placeholder3, Producer<? extends A> input1, Producer<? extends B> input2,
        Producer<? extends C> input3) {
      super(placeholder1, placeholder2, placeholder3, input1, input2, input3);
    }

    /**
     * Creates a completed DAG by supplying this partial DAG with its outputs (outputs).
     *
     * @param output1 the first output (output) of the DAG
     * @param <RA> the type of the first result
     * @return a completed DAG with 3 inputs (placeholders) and 1 output (outputs).
     */
    public <RA> DAG3x1<A, B, C, RA> withOutputs(Producer<? extends RA> output1) {
      Objects.requireNonNull(output1, "Output 1 may not be null");

      if (_shouldRemapInputs) {
        Map<Producer<?>, Producer<?>> inputMapping =
            DAGUtil.createInputMap(_input1, _placeholder1, _input2, _placeholder2, _input3, _placeholder3);
        output1 = DAGUtil.replaceInputs(output1, inputMapping);
      }

      List<Producer<?>> inputs = Arrays.asList(_input1, _input2, _input3);

      return ((DAG3x1) DAGUtil
          .createPreparableDAG(Arrays.asList(_placeholder1, _placeholder2, _placeholder3), Arrays.asList(output1))
          .internalAPI().withInputsUnsafe(inputs)).withReduction(_minimumReducerLevel);
    }

    /**
     * Creates a completed DAG by supplying this partial DAG with its outputs (outputs).
     *
     * @param output1 the first output (output) of the DAG
     * @param <RA> the type of the first result
     * @return a completed DAG with 3 inputs (placeholders) and 1 output (outputs).
     */
    public <RA> DAG3x1<A, B, C, RA> withOutput(Producer<? extends RA> output1) {
      Objects.requireNonNull(output1, "Output 1 may not be null");

      if (_shouldRemapInputs) {
        Map<Producer<?>, Producer<?>> inputMapping =
            DAGUtil.createInputMap(_input1, _placeholder1, _input2, _placeholder2, _input3, _placeholder3);
        output1 = DAGUtil.replaceInputs(output1, inputMapping);
      }

      List<Producer<?>> inputs = Arrays.asList(_input1, _input2, _input3);

      return ((DAG3x1) DAGUtil
          .createPreparableDAG(Arrays.asList(_placeholder1, _placeholder2, _placeholder3), Arrays.asList(output1))
          .internalAPI().withInputsUnsafe(inputs)).withReduction(_minimumReducerLevel);
    }

    /**
     * Creates a completed DAG by supplying this partial DAG with its outputs (outputs).
     *
     * @param output1 the first output (output) of the DAG
     * @param output2 the second output (output) of the DAG
     * @param <RA> the type of the first result
     * @param <RB> the type of the second result
     * @return a completed DAG with 3 inputs (placeholders) and 2 outputs (outputs).
     */
    public <RA, RB> DAG3x2<A, B, C, RA, RB> withOutputs(Producer<? extends RA> output1, Producer<? extends RB> output2) {
      Objects.requireNonNull(output1, "Output 1 may not be null");
      Objects.requireNonNull(output2, "Output 2 may not be null");

      if (_shouldRemapInputs) {
        Map<Producer<?>, Producer<?>> inputMapping =
            DAGUtil.createInputMap(_input1, _placeholder1, _input2, _placeholder2, _input3, _placeholder3);
        output1 = DAGUtil.replaceInputs(output1, inputMapping);
        output2 = DAGUtil.replaceInputs(output2, inputMapping);
      }

      List<Producer<?>> inputs = Arrays.asList(_input1, _input2, _input3);

      return ((DAG3x2) DAGUtil
          .createPreparableDAG(Arrays.asList(_placeholder1, _placeholder2, _placeholder3),
              Arrays.asList(output1, output2)).internalAPI().withInputsUnsafe(inputs))
          .withReduction(_minimumReducerLevel);
    }

    /**
     * Creates a completed DAG by supplying this partial DAG with its outputs (outputs).
     *
     * @param output1 the first output (output) of the DAG
     * @param output2 the second output (output) of the DAG
     * @param output3 the third output (output) of the DAG
     * @param <RA> the type of the first result
     * @param <RB> the type of the second result
     * @param <RC> the type of the third result
     * @return a completed DAG with 3 inputs (placeholders) and 3 outputs (outputs).
     */
    public <RA, RB, RC> DAG3x3<A, B, C, RA, RB, RC> withOutputs(Producer<? extends RA> output1,
        Producer<? extends RB> output2, Producer<? extends RC> output3) {
      Objects.requireNonNull(output1, "Output 1 may not be null");
      Objects.requireNonNull(output2, "Output 2 may not be null");
      Objects.requireNonNull(output3, "Output 3 may not be null");

      if (_shouldRemapInputs) {
        Map<Producer<?>, Producer<?>> inputMapping =
            DAGUtil.createInputMap(_input1, _placeholder1, _input2, _placeholder2, _input3, _placeholder3);
        output1 = DAGUtil.replaceInputs(output1, inputMapping);
        output2 = DAGUtil.replaceInputs(output2, inputMapping);
        output3 = DAGUtil.replaceInputs(output3, inputMapping);
      }

      List<Producer<?>> inputs = Arrays.asList(_input1, _input2, _input3);

      return ((DAG3x3) DAGUtil
          .createPreparableDAG(Arrays.asList(_placeholder1, _placeholder2, _placeholder3),
              Arrays.asList(output1, output2, output3)).internalAPI().withInputsUnsafe(inputs))
          .withReduction(_minimumReducerLevel);
    }

    /**
     * Creates a completed DAG by supplying this partial DAG with its outputs (outputs).
     *
     * @param output1 the first output (output) of the DAG
     * @param output2 the second output (output) of the DAG
     * @param output3 the third output (output) of the DAG
     * @param output4 the fourth output (output) of the DAG
     * @param <RA> the type of the first result
     * @param <RB> the type of the second result
     * @param <RC> the type of the third result
     * @param <RD> the type of the fourth result
     * @return a completed DAG with 3 inputs (placeholders) and 4 outputs (outputs).
     */
    public <RA, RB, RC, RD> DAG3x4<A, B, C, RA, RB, RC, RD> withOutputs(Producer<? extends RA> output1,
        Producer<? extends RB> output2, Producer<? extends RC> output3, Producer<? extends RD> output4) {
      Objects.requireNonNull(output1, "Output 1 may not be null");
      Objects.requireNonNull(output2, "Output 2 may not be null");
      Objects.requireNonNull(output3, "Output 3 may not be null");
      Objects.requireNonNull(output4, "Output 4 may not be null");

      if (_shouldRemapInputs) {
        Map<Producer<?>, Producer<?>> inputMapping =
            DAGUtil.createInputMap(_input1, _placeholder1, _input2, _placeholder2, _input3, _placeholder3);
        output1 = DAGUtil.replaceInputs(output1, inputMapping);
        output2 = DAGUtil.replaceInputs(output2, inputMapping);
        output3 = DAGUtil.replaceInputs(output3, inputMapping);
        output4 = DAGUtil.replaceInputs(output4, inputMapping);
      }

      List<Producer<?>> inputs = Arrays.asList(_input1, _input2, _input3);

      return ((DAG3x4) DAGUtil
          .createPreparableDAG(Arrays.asList(_placeholder1, _placeholder2, _placeholder3),
              Arrays.asList(output1, output2, output3, output4)).internalAPI().withInputsUnsafe(inputs))
          .withReduction(_minimumReducerLevel);
    }

    /**
     * Creates a completed DAG by supplying this partial DAG with its outputs (outputs).
     *
     * @param output1 the first output (output) of the DAG
     * @param output2 the second output (output) of the DAG
     * @param output3 the third output (output) of the DAG
     * @param output4 the fourth output (output) of the DAG
     * @param output5 the fifth output (output) of the DAG
     * @param <RA> the type of the first result
     * @param <RB> the type of the second result
     * @param <RC> the type of the third result
     * @param <RD> the type of the fourth result
     * @param <RE> the type of the fifth result
     * @return a completed DAG with 3 inputs (placeholders) and 5 outputs (outputs).
     */
    public <RA, RB, RC, RD, RE> DAG3x5<A, B, C, RA, RB, RC, RD, RE> withOutputs(Producer<? extends RA> output1,
        Producer<? extends RB> output2, Producer<? extends RC> output3, Producer<? extends RD> output4,
        Producer<? extends RE> output5) {
      Objects.requireNonNull(output1, "Output 1 may not be null");
      Objects.requireNonNull(output2, "Output 2 may not be null");
      Objects.requireNonNull(output3, "Output 3 may not be null");
      Objects.requireNonNull(output4, "Output 4 may not be null");
      Objects.requireNonNull(output5, "Output 5 may not be null");

      if (_shouldRemapInputs) {
        Map<Producer<?>, Producer<?>> inputMapping =
            DAGUtil.createInputMap(_input1, _placeholder1, _input2, _placeholder2, _input3, _placeholder3);
        output1 = DAGUtil.replaceInputs(output1, inputMapping);
        output2 = DAGUtil.replaceInputs(output2, inputMapping);
        output3 = DAGUtil.replaceInputs(output3, inputMapping);
        output4 = DAGUtil.replaceInputs(output4, inputMapping);
        output5 = DAGUtil.replaceInputs(output5, inputMapping);
      }

      List<Producer<?>> inputs = Arrays.asList(_input1, _input2, _input3);

      return ((DAG3x5) DAGUtil
          .createPreparableDAG(Arrays.asList(_placeholder1, _placeholder2, _placeholder3),
              Arrays.asList(output1, output2, output3, output4, output5)).internalAPI().withInputsUnsafe(inputs))
          .withReduction(_minimumReducerLevel);
    }

    /**
     * Creates a completed DAG by supplying this partial DAG with its outputs (outputs).
     *
     * @param output1 the first output (output) of the DAG
     * @param output2 the second output (output) of the DAG
     * @param output3 the third output (output) of the DAG
     * @param output4 the fourth output (output) of the DAG
     * @param output5 the fifth output (output) of the DAG
     * @param output6 the sixth output (output) of the DAG
     * @param <RA> the type of the first result
     * @param <RB> the type of the second result
     * @param <RC> the type of the third result
     * @param <RD> the type of the fourth result
     * @param <RE> the type of the fifth result
     * @param <RF> the type of the sixth result
     * @return a completed DAG with 3 inputs (placeholders) and 6 outputs (outputs).
     */
    public <RA, RB, RC, RD, RE, RF> DAG3x6<A, B, C, RA, RB, RC, RD, RE, RF> withOutputs(Producer<? extends RA> output1,
        Producer<? extends RB> output2, Producer<? extends RC> output3, Producer<? extends RD> output4,
        Producer<? extends RE> output5, Producer<? extends RF> output6) {
      Objects.requireNonNull(output1, "Output 1 may not be null");
      Objects.requireNonNull(output2, "Output 2 may not be null");
      Objects.requireNonNull(output3, "Output 3 may not be null");
      Objects.requireNonNull(output4, "Output 4 may not be null");
      Objects.requireNonNull(output5, "Output 5 may not be null");
      Objects.requireNonNull(output6, "Output 6 may not be null");

      if (_shouldRemapInputs) {
        Map<Producer<?>, Producer<?>> inputMapping =
            DAGUtil.createInputMap(_input1, _placeholder1, _input2, _placeholder2, _input3, _placeholder3);
        output1 = DAGUtil.replaceInputs(output1, inputMapping);
        output2 = DAGUtil.replaceInputs(output2, inputMapping);
        output3 = DAGUtil.replaceInputs(output3, inputMapping);
        output4 = DAGUtil.replaceInputs(output4, inputMapping);
        output5 = DAGUtil.replaceInputs(output5, inputMapping);
        output6 = DAGUtil.replaceInputs(output6, inputMapping);
      }

      List<Producer<?>> inputs = Arrays.asList(_input1, _input2, _input3);

      return ((DAG3x6) DAGUtil
          .createPreparableDAG(Arrays.asList(_placeholder1, _placeholder2, _placeholder3),
              Arrays.asList(output1, output2, output3, output4, output5, output6)).internalAPI()
          .withInputsUnsafe(inputs)).withReduction(_minimumReducerLevel);
    }

    /**
     * Creates a completed DAG by supplying this partial DAG with its outputs (outputs).
     *
     * @param output1 the first output (output) of the DAG
     * @param output2 the second output (output) of the DAG
     * @param output3 the third output (output) of the DAG
     * @param output4 the fourth output (output) of the DAG
     * @param output5 the fifth output (output) of the DAG
     * @param output6 the sixth output (output) of the DAG
     * @param output7 the seventh output (output) of the DAG
     * @param <RA> the type of the first result
     * @param <RB> the type of the second result
     * @param <RC> the type of the third result
     * @param <RD> the type of the fourth result
     * @param <RE> the type of the fifth result
     * @param <RF> the type of the sixth result
     * @param <RG> the type of the seventh result
     * @return a completed DAG with 3 inputs (placeholders) and 7 outputs (outputs).
     */
    public <RA, RB, RC, RD, RE, RF, RG> DAG3x7<A, B, C, RA, RB, RC, RD, RE, RF, RG> withOutputs(
        Producer<? extends RA> output1, Producer<? extends RB> output2, Producer<? extends RC> output3,
        Producer<? extends RD> output4, Producer<? extends RE> output5, Producer<? extends RF> output6,
        Producer<? extends RG> output7) {
      Objects.requireNonNull(output1, "Output 1 may not be null");
      Objects.requireNonNull(output2, "Output 2 may not be null");
      Objects.requireNonNull(output3, "Output 3 may not be null");
      Objects.requireNonNull(output4, "Output 4 may not be null");
      Objects.requireNonNull(output5, "Output 5 may not be null");
      Objects.requireNonNull(output6, "Output 6 may not be null");
      Objects.requireNonNull(output7, "Output 7 may not be null");

      if (_shouldRemapInputs) {
        Map<Producer<?>, Producer<?>> inputMapping =
            DAGUtil.createInputMap(_input1, _placeholder1, _input2, _placeholder2, _input3, _placeholder3);
        output1 = DAGUtil.replaceInputs(output1, inputMapping);
        output2 = DAGUtil.replaceInputs(output2, inputMapping);
        output3 = DAGUtil.replaceInputs(output3, inputMapping);
        output4 = DAGUtil.replaceInputs(output4, inputMapping);
        output5 = DAGUtil.replaceInputs(output5, inputMapping);
        output6 = DAGUtil.replaceInputs(output6, inputMapping);
        output7 = DAGUtil.replaceInputs(output7, inputMapping);
      }

      List<Producer<?>> inputs = Arrays.asList(_input1, _input2, _input3);

      return ((DAG3x7) DAGUtil
          .createPreparableDAG(Arrays.asList(_placeholder1, _placeholder2, _placeholder3),
              Arrays.asList(output1, output2, output3, output4, output5, output6, output7)).internalAPI()
          .withInputsUnsafe(inputs)).withReduction(_minimumReducerLevel);
    }

    /**
     * Creates a completed DAG by supplying this partial DAG with its outputs (outputs).
     *
     * @param output1 the first output (output) of the DAG
     * @param output2 the second output (output) of the DAG
     * @param output3 the third output (output) of the DAG
     * @param output4 the fourth output (output) of the DAG
     * @param output5 the fifth output (output) of the DAG
     * @param output6 the sixth output (output) of the DAG
     * @param output7 the seventh output (output) of the DAG
     * @param output8 the eighth output (output) of the DAG
     * @param <RA> the type of the first result
     * @param <RB> the type of the second result
     * @param <RC> the type of the third result
     * @param <RD> the type of the fourth result
     * @param <RE> the type of the fifth result
     * @param <RF> the type of the sixth result
     * @param <RG> the type of the seventh result
     * @param <RH> the type of the eighth result
     * @return a completed DAG with 3 inputs (placeholders) and 8 outputs (outputs).
     */
    public <RA, RB, RC, RD, RE, RF, RG, RH> DAG3x8<A, B, C, RA, RB, RC, RD, RE, RF, RG, RH> withOutputs(
        Producer<? extends RA> output1, Producer<? extends RB> output2, Producer<? extends RC> output3,
        Producer<? extends RD> output4, Producer<? extends RE> output5, Producer<? extends RF> output6,
        Producer<? extends RG> output7, Producer<? extends RH> output8) {
      Objects.requireNonNull(output1, "Output 1 may not be null");
      Objects.requireNonNull(output2, "Output 2 may not be null");
      Objects.requireNonNull(output3, "Output 3 may not be null");
      Objects.requireNonNull(output4, "Output 4 may not be null");
      Objects.requireNonNull(output5, "Output 5 may not be null");
      Objects.requireNonNull(output6, "Output 6 may not be null");
      Objects.requireNonNull(output7, "Output 7 may not be null");
      Objects.requireNonNull(output8, "Output 8 may not be null");

      if (_shouldRemapInputs) {
        Map<Producer<?>, Producer<?>> inputMapping =
            DAGUtil.createInputMap(_input1, _placeholder1, _input2, _placeholder2, _input3, _placeholder3);
        output1 = DAGUtil.replaceInputs(output1, inputMapping);
        output2 = DAGUtil.replaceInputs(output2, inputMapping);
        output3 = DAGUtil.replaceInputs(output3, inputMapping);
        output4 = DAGUtil.replaceInputs(output4, inputMapping);
        output5 = DAGUtil.replaceInputs(output5, inputMapping);
        output6 = DAGUtil.replaceInputs(output6, inputMapping);
        output7 = DAGUtil.replaceInputs(output7, inputMapping);
        output8 = DAGUtil.replaceInputs(output8, inputMapping);
      }

      List<Producer<?>> inputs = Arrays.asList(_input1, _input2, _input3);

      return ((DAG3x8) DAGUtil
          .createPreparableDAG(Arrays.asList(_placeholder1, _placeholder2, _placeholder3),
              Arrays.asList(output1, output2, output3, output4, output5, output6, output7, output8)).internalAPI()
          .withInputsUnsafe(inputs)).withReduction(_minimumReducerLevel);
    }

    /**
     * Creates a completed DAG by supplying this partial DAG with its outputs (outputs).
     *
     * @param output1 the first output (output) of the DAG
     * @param output2 the second output (output) of the DAG
     * @param output3 the third output (output) of the DAG
     * @param output4 the fourth output (output) of the DAG
     * @param output5 the fifth output (output) of the DAG
     * @param output6 the sixth output (output) of the DAG
     * @param output7 the seventh output (output) of the DAG
     * @param output8 the eighth output (output) of the DAG
     * @param output9 the ninth output (output) of the DAG
     * @param <RA> the type of the first result
     * @param <RB> the type of the second result
     * @param <RC> the type of the third result
     * @param <RD> the type of the fourth result
     * @param <RE> the type of the fifth result
     * @param <RF> the type of the sixth result
     * @param <RG> the type of the seventh result
     * @param <RH> the type of the eighth result
     * @param <RI> the type of the ninth result
     * @return a completed DAG with 3 inputs (placeholders) and 9 outputs (outputs).
     */
    public <RA, RB, RC, RD, RE, RF, RG, RH, RI> DAG3x9<A, B, C, RA, RB, RC, RD, RE, RF, RG, RH, RI> withOutputs(
        Producer<? extends RA> output1, Producer<? extends RB> output2, Producer<? extends RC> output3,
        Producer<? extends RD> output4, Producer<? extends RE> output5, Producer<? extends RF> output6,
        Producer<? extends RG> output7, Producer<? extends RH> output8, Producer<? extends RI> output9) {
      Objects.requireNonNull(output1, "Output 1 may not be null");
      Objects.requireNonNull(output2, "Output 2 may not be null");
      Objects.requireNonNull(output3, "Output 3 may not be null");
      Objects.requireNonNull(output4, "Output 4 may not be null");
      Objects.requireNonNull(output5, "Output 5 may not be null");
      Objects.requireNonNull(output6, "Output 6 may not be null");
      Objects.requireNonNull(output7, "Output 7 may not be null");
      Objects.requireNonNull(output8, "Output 8 may not be null");
      Objects.requireNonNull(output9, "Output 9 may not be null");

      if (_shouldRemapInputs) {
        Map<Producer<?>, Producer<?>> inputMapping =
            DAGUtil.createInputMap(_input1, _placeholder1, _input2, _placeholder2, _input3, _placeholder3);
        output1 = DAGUtil.replaceInputs(output1, inputMapping);
        output2 = DAGUtil.replaceInputs(output2, inputMapping);
        output3 = DAGUtil.replaceInputs(output3, inputMapping);
        output4 = DAGUtil.replaceInputs(output4, inputMapping);
        output5 = DAGUtil.replaceInputs(output5, inputMapping);
        output6 = DAGUtil.replaceInputs(output6, inputMapping);
        output7 = DAGUtil.replaceInputs(output7, inputMapping);
        output8 = DAGUtil.replaceInputs(output8, inputMapping);
        output9 = DAGUtil.replaceInputs(output9, inputMapping);
      }

      List<Producer<?>> inputs = Arrays.asList(_input1, _input2, _input3);

      return ((DAG3x9) DAGUtil
          .createPreparableDAG(Arrays.asList(_placeholder1, _placeholder2, _placeholder3),
              Arrays.asList(output1, output2, output3, output4, output5, output6, output7, output8, output9))
          .internalAPI().withInputsUnsafe(inputs)).withReduction(_minimumReducerLevel);
    }

    /**
     * Creates a completed DAG by supplying this partial DAG with its outputs (outputs).
     *
     * @param output1 the first output (output) of the DAG
     * @param output2 the second output (output) of the DAG
     * @param output3 the third output (output) of the DAG
     * @param output4 the fourth output (output) of the DAG
     * @param output5 the fifth output (output) of the DAG
     * @param output6 the sixth output (output) of the DAG
     * @param output7 the seventh output (output) of the DAG
     * @param output8 the eighth output (output) of the DAG
     * @param output9 the ninth output (output) of the DAG
     * @param output10 the tenth output (output) of the DAG
     * @param <RA> the type of the first result
     * @param <RB> the type of the second result
     * @param <RC> the type of the third result
     * @param <RD> the type of the fourth result
     * @param <RE> the type of the fifth result
     * @param <RF> the type of the sixth result
     * @param <RG> the type of the seventh result
     * @param <RH> the type of the eighth result
     * @param <RI> the type of the ninth result
     * @param <RJ> the type of the tenth result
     * @return a completed DAG with 3 inputs (placeholders) and 10 outputs (outputs).
     */
    public <RA, RB, RC, RD, RE, RF, RG, RH, RI, RJ> DAG3x10<A, B, C, RA, RB, RC, RD, RE, RF, RG, RH, RI, RJ> withOutputs(
        Producer<? extends RA> output1, Producer<? extends RB> output2, Producer<? extends RC> output3,
        Producer<? extends RD> output4, Producer<? extends RE> output5, Producer<? extends RF> output6,
        Producer<? extends RG> output7, Producer<? extends RH> output8, Producer<? extends RI> output9,
        Producer<? extends RJ> output10) {
      Objects.requireNonNull(output1, "Output 1 may not be null");
      Objects.requireNonNull(output2, "Output 2 may not be null");
      Objects.requireNonNull(output3, "Output 3 may not be null");
      Objects.requireNonNull(output4, "Output 4 may not be null");
      Objects.requireNonNull(output5, "Output 5 may not be null");
      Objects.requireNonNull(output6, "Output 6 may not be null");
      Objects.requireNonNull(output7, "Output 7 may not be null");
      Objects.requireNonNull(output8, "Output 8 may not be null");
      Objects.requireNonNull(output9, "Output 9 may not be null");
      Objects.requireNonNull(output10, "Output 10 may not be null");

      if (_shouldRemapInputs) {
        Map<Producer<?>, Producer<?>> inputMapping =
            DAGUtil.createInputMap(_input1, _placeholder1, _input2, _placeholder2, _input3, _placeholder3);
        output1 = DAGUtil.replaceInputs(output1, inputMapping);
        output2 = DAGUtil.replaceInputs(output2, inputMapping);
        output3 = DAGUtil.replaceInputs(output3, inputMapping);
        output4 = DAGUtil.replaceInputs(output4, inputMapping);
        output5 = DAGUtil.replaceInputs(output5, inputMapping);
        output6 = DAGUtil.replaceInputs(output6, inputMapping);
        output7 = DAGUtil.replaceInputs(output7, inputMapping);
        output8 = DAGUtil.replaceInputs(output8, inputMapping);
        output9 = DAGUtil.replaceInputs(output9, inputMapping);
        output10 = DAGUtil.replaceInputs(output10, inputMapping);
      }

      List<Producer<?>> inputs = Arrays.asList(_input1, _input2, _input3);

      return ((DAG3x10) DAGUtil
          .createPreparableDAG(Arrays.asList(_placeholder1, _placeholder2, _placeholder3),
              Arrays.asList(output1, output2, output3, output4, output5, output6, output7, output8, output9, output10))
          .internalAPI().withInputsUnsafe(inputs)).withReduction(_minimumReducerLevel);
    }
  }

  /**
    * A partial DAG with 4 placeholder.  Partial DAGs are <i>completed</i> to create a usable DAG by specifying
    * the outputs (<i>outputs</i>) of the DAG using the withOutputs(...) methods.
    *
   * @param <A> the type of the first input
   * @param <B> the type of the second input
   * @param <C> the type of the third input
   * @param <D> the type of the fourth input
    */
  public static class WithPlaceholders4<A, B, C, D> extends
      AbstractWithPlaceholders4<A, B, C, D, WithPlaceholders4<A, B, C, D>> {
    /**
     * Creates a new partial DAG that will be rooted at the provided placeholders.
     *
     * @param placeholder1 the first placeholder
     * @param placeholder2 the second placeholder
     * @param placeholder3 the third placeholder
     * @param placeholder4 the fourth placeholder
     */
    WithPlaceholders4(Placeholder<? extends A> placeholder1, Placeholder<? extends B> placeholder2,
        Placeholder<? extends C> placeholder3, Placeholder<? extends D> placeholder4) {
      super(placeholder1, placeholder2, placeholder3, placeholder4);
    }

    /**
     * Creates a new partial DAG that will be rooted at the provided placeholders, which will replace ("remap") the provided
     * "input" nodes that define a subgraph of the original graph (as defined by the ancestors of the outputs that will
     * be provided when the partial DAG is completed).  The input nodes, and any nodes that were exclusively the
     * ancestors of the input nodes, are truncated from the resulting graph.
     *
     * @param placeholder1 the first placeholder
     * @param placeholder2 the second placeholder
     * @param placeholder3 the third placeholder
     * @param placeholder4 the fourth placeholder
     * @param input1 the first input
     * @param input2 the second input
     * @param input3 the third input
     * @param input4 the fourth input
     */
    WithPlaceholders4(Placeholder<? extends A> placeholder1, Placeholder<? extends B> placeholder2,
        Placeholder<? extends C> placeholder3, Placeholder<? extends D> placeholder4, Producer<? extends A> input1,
        Producer<? extends B> input2, Producer<? extends C> input3, Producer<? extends D> input4) {
      super(placeholder1, placeholder2, placeholder3, placeholder4, input1, input2, input3, input4);
    }

    /**
     * Creates a completed DAG by supplying this partial DAG with its outputs (outputs).
     *
     * @param output1 the first output (output) of the DAG
     * @param <RA> the type of the first result
     * @return a completed DAG with 4 inputs (placeholders) and 1 output (outputs).
     */
    public <RA> DAG4x1<A, B, C, D, RA> withOutputs(Producer<? extends RA> output1) {
      Objects.requireNonNull(output1, "Output 1 may not be null");

      if (_shouldRemapInputs) {
        Map<Producer<?>, Producer<?>> inputMapping =
            DAGUtil.createInputMap(_input1, _placeholder1, _input2, _placeholder2, _input3, _placeholder3, _input4,
                _placeholder4);
        output1 = DAGUtil.replaceInputs(output1, inputMapping);
      }

      List<Producer<?>> inputs = Arrays.asList(_input1, _input2, _input3, _input4);

      return ((DAG4x1) DAGUtil
          .createPreparableDAG(Arrays.asList(_placeholder1, _placeholder2, _placeholder3, _placeholder4),
              Arrays.asList(output1)).internalAPI().withInputsUnsafe(inputs)).withReduction(_minimumReducerLevel);
    }

    /**
     * Creates a completed DAG by supplying this partial DAG with its outputs (outputs).
     *
     * @param output1 the first output (output) of the DAG
     * @param <RA> the type of the first result
     * @return a completed DAG with 4 inputs (placeholders) and 1 output (outputs).
     */
    public <RA> DAG4x1<A, B, C, D, RA> withOutput(Producer<? extends RA> output1) {
      Objects.requireNonNull(output1, "Output 1 may not be null");

      if (_shouldRemapInputs) {
        Map<Producer<?>, Producer<?>> inputMapping =
            DAGUtil.createInputMap(_input1, _placeholder1, _input2, _placeholder2, _input3, _placeholder3, _input4,
                _placeholder4);
        output1 = DAGUtil.replaceInputs(output1, inputMapping);
      }

      List<Producer<?>> inputs = Arrays.asList(_input1, _input2, _input3, _input4);

      return ((DAG4x1) DAGUtil
          .createPreparableDAG(Arrays.asList(_placeholder1, _placeholder2, _placeholder3, _placeholder4),
              Arrays.asList(output1)).internalAPI().withInputsUnsafe(inputs)).withReduction(_minimumReducerLevel);
    }

    /**
     * Creates a completed DAG by supplying this partial DAG with its outputs (outputs).
     *
     * @param output1 the first output (output) of the DAG
     * @param output2 the second output (output) of the DAG
     * @param <RA> the type of the first result
     * @param <RB> the type of the second result
     * @return a completed DAG with 4 inputs (placeholders) and 2 outputs (outputs).
     */
    public <RA, RB> DAG4x2<A, B, C, D, RA, RB> withOutputs(Producer<? extends RA> output1,
        Producer<? extends RB> output2) {
      Objects.requireNonNull(output1, "Output 1 may not be null");
      Objects.requireNonNull(output2, "Output 2 may not be null");

      if (_shouldRemapInputs) {
        Map<Producer<?>, Producer<?>> inputMapping =
            DAGUtil.createInputMap(_input1, _placeholder1, _input2, _placeholder2, _input3, _placeholder3, _input4,
                _placeholder4);
        output1 = DAGUtil.replaceInputs(output1, inputMapping);
        output2 = DAGUtil.replaceInputs(output2, inputMapping);
      }

      List<Producer<?>> inputs = Arrays.asList(_input1, _input2, _input3, _input4);

      return ((DAG4x2) DAGUtil
          .createPreparableDAG(Arrays.asList(_placeholder1, _placeholder2, _placeholder3, _placeholder4),
              Arrays.asList(output1, output2)).internalAPI().withInputsUnsafe(inputs))
          .withReduction(_minimumReducerLevel);
    }

    /**
     * Creates a completed DAG by supplying this partial DAG with its outputs (outputs).
     *
     * @param output1 the first output (output) of the DAG
     * @param output2 the second output (output) of the DAG
     * @param output3 the third output (output) of the DAG
     * @param <RA> the type of the first result
     * @param <RB> the type of the second result
     * @param <RC> the type of the third result
     * @return a completed DAG with 4 inputs (placeholders) and 3 outputs (outputs).
     */
    public <RA, RB, RC> DAG4x3<A, B, C, D, RA, RB, RC> withOutputs(Producer<? extends RA> output1,
        Producer<? extends RB> output2, Producer<? extends RC> output3) {
      Objects.requireNonNull(output1, "Output 1 may not be null");
      Objects.requireNonNull(output2, "Output 2 may not be null");
      Objects.requireNonNull(output3, "Output 3 may not be null");

      if (_shouldRemapInputs) {
        Map<Producer<?>, Producer<?>> inputMapping =
            DAGUtil.createInputMap(_input1, _placeholder1, _input2, _placeholder2, _input3, _placeholder3, _input4,
                _placeholder4);
        output1 = DAGUtil.replaceInputs(output1, inputMapping);
        output2 = DAGUtil.replaceInputs(output2, inputMapping);
        output3 = DAGUtil.replaceInputs(output3, inputMapping);
      }

      List<Producer<?>> inputs = Arrays.asList(_input1, _input2, _input3, _input4);

      return ((DAG4x3) DAGUtil
          .createPreparableDAG(Arrays.asList(_placeholder1, _placeholder2, _placeholder3, _placeholder4),
              Arrays.asList(output1, output2, output3)).internalAPI().withInputsUnsafe(inputs))
          .withReduction(_minimumReducerLevel);
    }

    /**
     * Creates a completed DAG by supplying this partial DAG with its outputs (outputs).
     *
     * @param output1 the first output (output) of the DAG
     * @param output2 the second output (output) of the DAG
     * @param output3 the third output (output) of the DAG
     * @param output4 the fourth output (output) of the DAG
     * @param <RA> the type of the first result
     * @param <RB> the type of the second result
     * @param <RC> the type of the third result
     * @param <RD> the type of the fourth result
     * @return a completed DAG with 4 inputs (placeholders) and 4 outputs (outputs).
     */
    public <RA, RB, RC, RD> DAG4x4<A, B, C, D, RA, RB, RC, RD> withOutputs(Producer<? extends RA> output1,
        Producer<? extends RB> output2, Producer<? extends RC> output3, Producer<? extends RD> output4) {
      Objects.requireNonNull(output1, "Output 1 may not be null");
      Objects.requireNonNull(output2, "Output 2 may not be null");
      Objects.requireNonNull(output3, "Output 3 may not be null");
      Objects.requireNonNull(output4, "Output 4 may not be null");

      if (_shouldRemapInputs) {
        Map<Producer<?>, Producer<?>> inputMapping =
            DAGUtil.createInputMap(_input1, _placeholder1, _input2, _placeholder2, _input3, _placeholder3, _input4,
                _placeholder4);
        output1 = DAGUtil.replaceInputs(output1, inputMapping);
        output2 = DAGUtil.replaceInputs(output2, inputMapping);
        output3 = DAGUtil.replaceInputs(output3, inputMapping);
        output4 = DAGUtil.replaceInputs(output4, inputMapping);
      }

      List<Producer<?>> inputs = Arrays.asList(_input1, _input2, _input3, _input4);

      return ((DAG4x4) DAGUtil
          .createPreparableDAG(Arrays.asList(_placeholder1, _placeholder2, _placeholder3, _placeholder4),
              Arrays.asList(output1, output2, output3, output4)).internalAPI().withInputsUnsafe(inputs))
          .withReduction(_minimumReducerLevel);
    }

    /**
     * Creates a completed DAG by supplying this partial DAG with its outputs (outputs).
     *
     * @param output1 the first output (output) of the DAG
     * @param output2 the second output (output) of the DAG
     * @param output3 the third output (output) of the DAG
     * @param output4 the fourth output (output) of the DAG
     * @param output5 the fifth output (output) of the DAG
     * @param <RA> the type of the first result
     * @param <RB> the type of the second result
     * @param <RC> the type of the third result
     * @param <RD> the type of the fourth result
     * @param <RE> the type of the fifth result
     * @return a completed DAG with 4 inputs (placeholders) and 5 outputs (outputs).
     */
    public <RA, RB, RC, RD, RE> DAG4x5<A, B, C, D, RA, RB, RC, RD, RE> withOutputs(Producer<? extends RA> output1,
        Producer<? extends RB> output2, Producer<? extends RC> output3, Producer<? extends RD> output4,
        Producer<? extends RE> output5) {
      Objects.requireNonNull(output1, "Output 1 may not be null");
      Objects.requireNonNull(output2, "Output 2 may not be null");
      Objects.requireNonNull(output3, "Output 3 may not be null");
      Objects.requireNonNull(output4, "Output 4 may not be null");
      Objects.requireNonNull(output5, "Output 5 may not be null");

      if (_shouldRemapInputs) {
        Map<Producer<?>, Producer<?>> inputMapping =
            DAGUtil.createInputMap(_input1, _placeholder1, _input2, _placeholder2, _input3, _placeholder3, _input4,
                _placeholder4);
        output1 = DAGUtil.replaceInputs(output1, inputMapping);
        output2 = DAGUtil.replaceInputs(output2, inputMapping);
        output3 = DAGUtil.replaceInputs(output3, inputMapping);
        output4 = DAGUtil.replaceInputs(output4, inputMapping);
        output5 = DAGUtil.replaceInputs(output5, inputMapping);
      }

      List<Producer<?>> inputs = Arrays.asList(_input1, _input2, _input3, _input4);

      return ((DAG4x5) DAGUtil
          .createPreparableDAG(Arrays.asList(_placeholder1, _placeholder2, _placeholder3, _placeholder4),
              Arrays.asList(output1, output2, output3, output4, output5)).internalAPI().withInputsUnsafe(inputs))
          .withReduction(_minimumReducerLevel);
    }

    /**
     * Creates a completed DAG by supplying this partial DAG with its outputs (outputs).
     *
     * @param output1 the first output (output) of the DAG
     * @param output2 the second output (output) of the DAG
     * @param output3 the third output (output) of the DAG
     * @param output4 the fourth output (output) of the DAG
     * @param output5 the fifth output (output) of the DAG
     * @param output6 the sixth output (output) of the DAG
     * @param <RA> the type of the first result
     * @param <RB> the type of the second result
     * @param <RC> the type of the third result
     * @param <RD> the type of the fourth result
     * @param <RE> the type of the fifth result
     * @param <RF> the type of the sixth result
     * @return a completed DAG with 4 inputs (placeholders) and 6 outputs (outputs).
     */
    public <RA, RB, RC, RD, RE, RF> DAG4x6<A, B, C, D, RA, RB, RC, RD, RE, RF> withOutputs(
        Producer<? extends RA> output1, Producer<? extends RB> output2, Producer<? extends RC> output3,
        Producer<? extends RD> output4, Producer<? extends RE> output5, Producer<? extends RF> output6) {
      Objects.requireNonNull(output1, "Output 1 may not be null");
      Objects.requireNonNull(output2, "Output 2 may not be null");
      Objects.requireNonNull(output3, "Output 3 may not be null");
      Objects.requireNonNull(output4, "Output 4 may not be null");
      Objects.requireNonNull(output5, "Output 5 may not be null");
      Objects.requireNonNull(output6, "Output 6 may not be null");

      if (_shouldRemapInputs) {
        Map<Producer<?>, Producer<?>> inputMapping =
            DAGUtil.createInputMap(_input1, _placeholder1, _input2, _placeholder2, _input3, _placeholder3, _input4,
                _placeholder4);
        output1 = DAGUtil.replaceInputs(output1, inputMapping);
        output2 = DAGUtil.replaceInputs(output2, inputMapping);
        output3 = DAGUtil.replaceInputs(output3, inputMapping);
        output4 = DAGUtil.replaceInputs(output4, inputMapping);
        output5 = DAGUtil.replaceInputs(output5, inputMapping);
        output6 = DAGUtil.replaceInputs(output6, inputMapping);
      }

      List<Producer<?>> inputs = Arrays.asList(_input1, _input2, _input3, _input4);

      return ((DAG4x6) DAGUtil
          .createPreparableDAG(Arrays.asList(_placeholder1, _placeholder2, _placeholder3, _placeholder4),
              Arrays.asList(output1, output2, output3, output4, output5, output6)).internalAPI()
          .withInputsUnsafe(inputs)).withReduction(_minimumReducerLevel);
    }

    /**
     * Creates a completed DAG by supplying this partial DAG with its outputs (outputs).
     *
     * @param output1 the first output (output) of the DAG
     * @param output2 the second output (output) of the DAG
     * @param output3 the third output (output) of the DAG
     * @param output4 the fourth output (output) of the DAG
     * @param output5 the fifth output (output) of the DAG
     * @param output6 the sixth output (output) of the DAG
     * @param output7 the seventh output (output) of the DAG
     * @param <RA> the type of the first result
     * @param <RB> the type of the second result
     * @param <RC> the type of the third result
     * @param <RD> the type of the fourth result
     * @param <RE> the type of the fifth result
     * @param <RF> the type of the sixth result
     * @param <RG> the type of the seventh result
     * @return a completed DAG with 4 inputs (placeholders) and 7 outputs (outputs).
     */
    public <RA, RB, RC, RD, RE, RF, RG> DAG4x7<A, B, C, D, RA, RB, RC, RD, RE, RF, RG> withOutputs(
        Producer<? extends RA> output1, Producer<? extends RB> output2, Producer<? extends RC> output3,
        Producer<? extends RD> output4, Producer<? extends RE> output5, Producer<? extends RF> output6,
        Producer<? extends RG> output7) {
      Objects.requireNonNull(output1, "Output 1 may not be null");
      Objects.requireNonNull(output2, "Output 2 may not be null");
      Objects.requireNonNull(output3, "Output 3 may not be null");
      Objects.requireNonNull(output4, "Output 4 may not be null");
      Objects.requireNonNull(output5, "Output 5 may not be null");
      Objects.requireNonNull(output6, "Output 6 may not be null");
      Objects.requireNonNull(output7, "Output 7 may not be null");

      if (_shouldRemapInputs) {
        Map<Producer<?>, Producer<?>> inputMapping =
            DAGUtil.createInputMap(_input1, _placeholder1, _input2, _placeholder2, _input3, _placeholder3, _input4,
                _placeholder4);
        output1 = DAGUtil.replaceInputs(output1, inputMapping);
        output2 = DAGUtil.replaceInputs(output2, inputMapping);
        output3 = DAGUtil.replaceInputs(output3, inputMapping);
        output4 = DAGUtil.replaceInputs(output4, inputMapping);
        output5 = DAGUtil.replaceInputs(output5, inputMapping);
        output6 = DAGUtil.replaceInputs(output6, inputMapping);
        output7 = DAGUtil.replaceInputs(output7, inputMapping);
      }

      List<Producer<?>> inputs = Arrays.asList(_input1, _input2, _input3, _input4);

      return ((DAG4x7) DAGUtil
          .createPreparableDAG(Arrays.asList(_placeholder1, _placeholder2, _placeholder3, _placeholder4),
              Arrays.asList(output1, output2, output3, output4, output5, output6, output7)).internalAPI()
          .withInputsUnsafe(inputs)).withReduction(_minimumReducerLevel);
    }

    /**
     * Creates a completed DAG by supplying this partial DAG with its outputs (outputs).
     *
     * @param output1 the first output (output) of the DAG
     * @param output2 the second output (output) of the DAG
     * @param output3 the third output (output) of the DAG
     * @param output4 the fourth output (output) of the DAG
     * @param output5 the fifth output (output) of the DAG
     * @param output6 the sixth output (output) of the DAG
     * @param output7 the seventh output (output) of the DAG
     * @param output8 the eighth output (output) of the DAG
     * @param <RA> the type of the first result
     * @param <RB> the type of the second result
     * @param <RC> the type of the third result
     * @param <RD> the type of the fourth result
     * @param <RE> the type of the fifth result
     * @param <RF> the type of the sixth result
     * @param <RG> the type of the seventh result
     * @param <RH> the type of the eighth result
     * @return a completed DAG with 4 inputs (placeholders) and 8 outputs (outputs).
     */
    public <RA, RB, RC, RD, RE, RF, RG, RH> DAG4x8<A, B, C, D, RA, RB, RC, RD, RE, RF, RG, RH> withOutputs(
        Producer<? extends RA> output1, Producer<? extends RB> output2, Producer<? extends RC> output3,
        Producer<? extends RD> output4, Producer<? extends RE> output5, Producer<? extends RF> output6,
        Producer<? extends RG> output7, Producer<? extends RH> output8) {
      Objects.requireNonNull(output1, "Output 1 may not be null");
      Objects.requireNonNull(output2, "Output 2 may not be null");
      Objects.requireNonNull(output3, "Output 3 may not be null");
      Objects.requireNonNull(output4, "Output 4 may not be null");
      Objects.requireNonNull(output5, "Output 5 may not be null");
      Objects.requireNonNull(output6, "Output 6 may not be null");
      Objects.requireNonNull(output7, "Output 7 may not be null");
      Objects.requireNonNull(output8, "Output 8 may not be null");

      if (_shouldRemapInputs) {
        Map<Producer<?>, Producer<?>> inputMapping =
            DAGUtil.createInputMap(_input1, _placeholder1, _input2, _placeholder2, _input3, _placeholder3, _input4,
                _placeholder4);
        output1 = DAGUtil.replaceInputs(output1, inputMapping);
        output2 = DAGUtil.replaceInputs(output2, inputMapping);
        output3 = DAGUtil.replaceInputs(output3, inputMapping);
        output4 = DAGUtil.replaceInputs(output4, inputMapping);
        output5 = DAGUtil.replaceInputs(output5, inputMapping);
        output6 = DAGUtil.replaceInputs(output6, inputMapping);
        output7 = DAGUtil.replaceInputs(output7, inputMapping);
        output8 = DAGUtil.replaceInputs(output8, inputMapping);
      }

      List<Producer<?>> inputs = Arrays.asList(_input1, _input2, _input3, _input4);

      return ((DAG4x8) DAGUtil
          .createPreparableDAG(Arrays.asList(_placeholder1, _placeholder2, _placeholder3, _placeholder4),
              Arrays.asList(output1, output2, output3, output4, output5, output6, output7, output8)).internalAPI()
          .withInputsUnsafe(inputs)).withReduction(_minimumReducerLevel);
    }

    /**
     * Creates a completed DAG by supplying this partial DAG with its outputs (outputs).
     *
     * @param output1 the first output (output) of the DAG
     * @param output2 the second output (output) of the DAG
     * @param output3 the third output (output) of the DAG
     * @param output4 the fourth output (output) of the DAG
     * @param output5 the fifth output (output) of the DAG
     * @param output6 the sixth output (output) of the DAG
     * @param output7 the seventh output (output) of the DAG
     * @param output8 the eighth output (output) of the DAG
     * @param output9 the ninth output (output) of the DAG
     * @param <RA> the type of the first result
     * @param <RB> the type of the second result
     * @param <RC> the type of the third result
     * @param <RD> the type of the fourth result
     * @param <RE> the type of the fifth result
     * @param <RF> the type of the sixth result
     * @param <RG> the type of the seventh result
     * @param <RH> the type of the eighth result
     * @param <RI> the type of the ninth result
     * @return a completed DAG with 4 inputs (placeholders) and 9 outputs (outputs).
     */
    public <RA, RB, RC, RD, RE, RF, RG, RH, RI> DAG4x9<A, B, C, D, RA, RB, RC, RD, RE, RF, RG, RH, RI> withOutputs(
        Producer<? extends RA> output1, Producer<? extends RB> output2, Producer<? extends RC> output3,
        Producer<? extends RD> output4, Producer<? extends RE> output5, Producer<? extends RF> output6,
        Producer<? extends RG> output7, Producer<? extends RH> output8, Producer<? extends RI> output9) {
      Objects.requireNonNull(output1, "Output 1 may not be null");
      Objects.requireNonNull(output2, "Output 2 may not be null");
      Objects.requireNonNull(output3, "Output 3 may not be null");
      Objects.requireNonNull(output4, "Output 4 may not be null");
      Objects.requireNonNull(output5, "Output 5 may not be null");
      Objects.requireNonNull(output6, "Output 6 may not be null");
      Objects.requireNonNull(output7, "Output 7 may not be null");
      Objects.requireNonNull(output8, "Output 8 may not be null");
      Objects.requireNonNull(output9, "Output 9 may not be null");

      if (_shouldRemapInputs) {
        Map<Producer<?>, Producer<?>> inputMapping =
            DAGUtil.createInputMap(_input1, _placeholder1, _input2, _placeholder2, _input3, _placeholder3, _input4,
                _placeholder4);
        output1 = DAGUtil.replaceInputs(output1, inputMapping);
        output2 = DAGUtil.replaceInputs(output2, inputMapping);
        output3 = DAGUtil.replaceInputs(output3, inputMapping);
        output4 = DAGUtil.replaceInputs(output4, inputMapping);
        output5 = DAGUtil.replaceInputs(output5, inputMapping);
        output6 = DAGUtil.replaceInputs(output6, inputMapping);
        output7 = DAGUtil.replaceInputs(output7, inputMapping);
        output8 = DAGUtil.replaceInputs(output8, inputMapping);
        output9 = DAGUtil.replaceInputs(output9, inputMapping);
      }

      List<Producer<?>> inputs = Arrays.asList(_input1, _input2, _input3, _input4);

      return ((DAG4x9) DAGUtil
          .createPreparableDAG(Arrays.asList(_placeholder1, _placeholder2, _placeholder3, _placeholder4),
              Arrays.asList(output1, output2, output3, output4, output5, output6, output7, output8, output9))
          .internalAPI().withInputsUnsafe(inputs)).withReduction(_minimumReducerLevel);
    }

    /**
     * Creates a completed DAG by supplying this partial DAG with its outputs (outputs).
     *
     * @param output1 the first output (output) of the DAG
     * @param output2 the second output (output) of the DAG
     * @param output3 the third output (output) of the DAG
     * @param output4 the fourth output (output) of the DAG
     * @param output5 the fifth output (output) of the DAG
     * @param output6 the sixth output (output) of the DAG
     * @param output7 the seventh output (output) of the DAG
     * @param output8 the eighth output (output) of the DAG
     * @param output9 the ninth output (output) of the DAG
     * @param output10 the tenth output (output) of the DAG
     * @param <RA> the type of the first result
     * @param <RB> the type of the second result
     * @param <RC> the type of the third result
     * @param <RD> the type of the fourth result
     * @param <RE> the type of the fifth result
     * @param <RF> the type of the sixth result
     * @param <RG> the type of the seventh result
     * @param <RH> the type of the eighth result
     * @param <RI> the type of the ninth result
     * @param <RJ> the type of the tenth result
     * @return a completed DAG with 4 inputs (placeholders) and 10 outputs (outputs).
     */
    public <RA, RB, RC, RD, RE, RF, RG, RH, RI, RJ> DAG4x10<A, B, C, D, RA, RB, RC, RD, RE, RF, RG, RH, RI, RJ> withOutputs(
        Producer<? extends RA> output1, Producer<? extends RB> output2, Producer<? extends RC> output3,
        Producer<? extends RD> output4, Producer<? extends RE> output5, Producer<? extends RF> output6,
        Producer<? extends RG> output7, Producer<? extends RH> output8, Producer<? extends RI> output9,
        Producer<? extends RJ> output10) {
      Objects.requireNonNull(output1, "Output 1 may not be null");
      Objects.requireNonNull(output2, "Output 2 may not be null");
      Objects.requireNonNull(output3, "Output 3 may not be null");
      Objects.requireNonNull(output4, "Output 4 may not be null");
      Objects.requireNonNull(output5, "Output 5 may not be null");
      Objects.requireNonNull(output6, "Output 6 may not be null");
      Objects.requireNonNull(output7, "Output 7 may not be null");
      Objects.requireNonNull(output8, "Output 8 may not be null");
      Objects.requireNonNull(output9, "Output 9 may not be null");
      Objects.requireNonNull(output10, "Output 10 may not be null");

      if (_shouldRemapInputs) {
        Map<Producer<?>, Producer<?>> inputMapping =
            DAGUtil.createInputMap(_input1, _placeholder1, _input2, _placeholder2, _input3, _placeholder3, _input4,
                _placeholder4);
        output1 = DAGUtil.replaceInputs(output1, inputMapping);
        output2 = DAGUtil.replaceInputs(output2, inputMapping);
        output3 = DAGUtil.replaceInputs(output3, inputMapping);
        output4 = DAGUtil.replaceInputs(output4, inputMapping);
        output5 = DAGUtil.replaceInputs(output5, inputMapping);
        output6 = DAGUtil.replaceInputs(output6, inputMapping);
        output7 = DAGUtil.replaceInputs(output7, inputMapping);
        output8 = DAGUtil.replaceInputs(output8, inputMapping);
        output9 = DAGUtil.replaceInputs(output9, inputMapping);
        output10 = DAGUtil.replaceInputs(output10, inputMapping);
      }

      List<Producer<?>> inputs = Arrays.asList(_input1, _input2, _input3, _input4);

      return ((DAG4x10) DAGUtil
          .createPreparableDAG(Arrays.asList(_placeholder1, _placeholder2, _placeholder3, _placeholder4),
              Arrays.asList(output1, output2, output3, output4, output5, output6, output7, output8, output9, output10))
          .internalAPI().withInputsUnsafe(inputs)).withReduction(_minimumReducerLevel);
    }
  }

  /**
    * A partial DAG with 5 placeholder.  Partial DAGs are <i>completed</i> to create a usable DAG by specifying
    * the outputs (<i>outputs</i>) of the DAG using the withOutputs(...) methods.
    *
   * @param <A> the type of the first input
   * @param <B> the type of the second input
   * @param <C> the type of the third input
   * @param <D> the type of the fourth input
   * @param <E> the type of the fifth input
    */
  public static class WithPlaceholders5<A, B, C, D, E> extends
      AbstractWithPlaceholders5<A, B, C, D, E, WithPlaceholders5<A, B, C, D, E>> {
    /**
     * Creates a new partial DAG that will be rooted at the provided placeholders.
     *
     * @param placeholder1 the first placeholder
     * @param placeholder2 the second placeholder
     * @param placeholder3 the third placeholder
     * @param placeholder4 the fourth placeholder
     * @param placeholder5 the fifth placeholder
     */
    WithPlaceholders5(Placeholder<? extends A> placeholder1, Placeholder<? extends B> placeholder2,
        Placeholder<? extends C> placeholder3, Placeholder<? extends D> placeholder4,
        Placeholder<? extends E> placeholder5) {
      super(placeholder1, placeholder2, placeholder3, placeholder4, placeholder5);
    }

    /**
     * Creates a new partial DAG that will be rooted at the provided placeholders, which will replace ("remap") the provided
     * "input" nodes that define a subgraph of the original graph (as defined by the ancestors of the outputs that will
     * be provided when the partial DAG is completed).  The input nodes, and any nodes that were exclusively the
     * ancestors of the input nodes, are truncated from the resulting graph.
     *
     * @param placeholder1 the first placeholder
     * @param placeholder2 the second placeholder
     * @param placeholder3 the third placeholder
     * @param placeholder4 the fourth placeholder
     * @param placeholder5 the fifth placeholder
     * @param input1 the first input
     * @param input2 the second input
     * @param input3 the third input
     * @param input4 the fourth input
     * @param input5 the fifth input
     */
    WithPlaceholders5(Placeholder<? extends A> placeholder1, Placeholder<? extends B> placeholder2,
        Placeholder<? extends C> placeholder3, Placeholder<? extends D> placeholder4,
        Placeholder<? extends E> placeholder5, Producer<? extends A> input1, Producer<? extends B> input2,
        Producer<? extends C> input3, Producer<? extends D> input4, Producer<? extends E> input5) {
      super(placeholder1, placeholder2, placeholder3, placeholder4, placeholder5, input1, input2, input3, input4,
          input5);
    }

    /**
     * Creates a completed DAG by supplying this partial DAG with its outputs (outputs).
     *
     * @param output1 the first output (output) of the DAG
     * @param <RA> the type of the first result
     * @return a completed DAG with 5 inputs (placeholders) and 1 output (outputs).
     */
    public <RA> DAG5x1<A, B, C, D, E, RA> withOutputs(Producer<? extends RA> output1) {
      Objects.requireNonNull(output1, "Output 1 may not be null");

      if (_shouldRemapInputs) {
        Map<Producer<?>, Producer<?>> inputMapping =
            DAGUtil.createInputMap(_input1, _placeholder1, _input2, _placeholder2, _input3, _placeholder3, _input4,
                _placeholder4, _input5, _placeholder5);
        output1 = DAGUtil.replaceInputs(output1, inputMapping);
      }

      List<Producer<?>> inputs = Arrays.asList(_input1, _input2, _input3, _input4, _input5);

      return ((DAG5x1) DAGUtil
          .createPreparableDAG(
              Arrays.asList(_placeholder1, _placeholder2, _placeholder3, _placeholder4, _placeholder5),
              Arrays.asList(output1)).internalAPI().withInputsUnsafe(inputs)).withReduction(_minimumReducerLevel);
    }

    /**
     * Creates a completed DAG by supplying this partial DAG with its outputs (outputs).
     *
     * @param output1 the first output (output) of the DAG
     * @param <RA> the type of the first result
     * @return a completed DAG with 5 inputs (placeholders) and 1 output (outputs).
     */
    public <RA> DAG5x1<A, B, C, D, E, RA> withOutput(Producer<? extends RA> output1) {
      Objects.requireNonNull(output1, "Output 1 may not be null");

      if (_shouldRemapInputs) {
        Map<Producer<?>, Producer<?>> inputMapping =
            DAGUtil.createInputMap(_input1, _placeholder1, _input2, _placeholder2, _input3, _placeholder3, _input4,
                _placeholder4, _input5, _placeholder5);
        output1 = DAGUtil.replaceInputs(output1, inputMapping);
      }

      List<Producer<?>> inputs = Arrays.asList(_input1, _input2, _input3, _input4, _input5);

      return ((DAG5x1) DAGUtil
          .createPreparableDAG(
              Arrays.asList(_placeholder1, _placeholder2, _placeholder3, _placeholder4, _placeholder5),
              Arrays.asList(output1)).internalAPI().withInputsUnsafe(inputs)).withReduction(_minimumReducerLevel);
    }

    /**
     * Creates a completed DAG by supplying this partial DAG with its outputs (outputs).
     *
     * @param output1 the first output (output) of the DAG
     * @param output2 the second output (output) of the DAG
     * @param <RA> the type of the first result
     * @param <RB> the type of the second result
     * @return a completed DAG with 5 inputs (placeholders) and 2 outputs (outputs).
     */
    public <RA, RB> DAG5x2<A, B, C, D, E, RA, RB> withOutputs(Producer<? extends RA> output1,
        Producer<? extends RB> output2) {
      Objects.requireNonNull(output1, "Output 1 may not be null");
      Objects.requireNonNull(output2, "Output 2 may not be null");

      if (_shouldRemapInputs) {
        Map<Producer<?>, Producer<?>> inputMapping =
            DAGUtil.createInputMap(_input1, _placeholder1, _input2, _placeholder2, _input3, _placeholder3, _input4,
                _placeholder4, _input5, _placeholder5);
        output1 = DAGUtil.replaceInputs(output1, inputMapping);
        output2 = DAGUtil.replaceInputs(output2, inputMapping);
      }

      List<Producer<?>> inputs = Arrays.asList(_input1, _input2, _input3, _input4, _input5);

      return ((DAG5x2) DAGUtil
          .createPreparableDAG(
              Arrays.asList(_placeholder1, _placeholder2, _placeholder3, _placeholder4, _placeholder5),
              Arrays.asList(output1, output2)).internalAPI().withInputsUnsafe(inputs))
          .withReduction(_minimumReducerLevel);
    }

    /**
     * Creates a completed DAG by supplying this partial DAG with its outputs (outputs).
     *
     * @param output1 the first output (output) of the DAG
     * @param output2 the second output (output) of the DAG
     * @param output3 the third output (output) of the DAG
     * @param <RA> the type of the first result
     * @param <RB> the type of the second result
     * @param <RC> the type of the third result
     * @return a completed DAG with 5 inputs (placeholders) and 3 outputs (outputs).
     */
    public <RA, RB, RC> DAG5x3<A, B, C, D, E, RA, RB, RC> withOutputs(Producer<? extends RA> output1,
        Producer<? extends RB> output2, Producer<? extends RC> output3) {
      Objects.requireNonNull(output1, "Output 1 may not be null");
      Objects.requireNonNull(output2, "Output 2 may not be null");
      Objects.requireNonNull(output3, "Output 3 may not be null");

      if (_shouldRemapInputs) {
        Map<Producer<?>, Producer<?>> inputMapping =
            DAGUtil.createInputMap(_input1, _placeholder1, _input2, _placeholder2, _input3, _placeholder3, _input4,
                _placeholder4, _input5, _placeholder5);
        output1 = DAGUtil.replaceInputs(output1, inputMapping);
        output2 = DAGUtil.replaceInputs(output2, inputMapping);
        output3 = DAGUtil.replaceInputs(output3, inputMapping);
      }

      List<Producer<?>> inputs = Arrays.asList(_input1, _input2, _input3, _input4, _input5);

      return ((DAG5x3) DAGUtil
          .createPreparableDAG(
              Arrays.asList(_placeholder1, _placeholder2, _placeholder3, _placeholder4, _placeholder5),
              Arrays.asList(output1, output2, output3)).internalAPI().withInputsUnsafe(inputs))
          .withReduction(_minimumReducerLevel);
    }

    /**
     * Creates a completed DAG by supplying this partial DAG with its outputs (outputs).
     *
     * @param output1 the first output (output) of the DAG
     * @param output2 the second output (output) of the DAG
     * @param output3 the third output (output) of the DAG
     * @param output4 the fourth output (output) of the DAG
     * @param <RA> the type of the first result
     * @param <RB> the type of the second result
     * @param <RC> the type of the third result
     * @param <RD> the type of the fourth result
     * @return a completed DAG with 5 inputs (placeholders) and 4 outputs (outputs).
     */
    public <RA, RB, RC, RD> DAG5x4<A, B, C, D, E, RA, RB, RC, RD> withOutputs(Producer<? extends RA> output1,
        Producer<? extends RB> output2, Producer<? extends RC> output3, Producer<? extends RD> output4) {
      Objects.requireNonNull(output1, "Output 1 may not be null");
      Objects.requireNonNull(output2, "Output 2 may not be null");
      Objects.requireNonNull(output3, "Output 3 may not be null");
      Objects.requireNonNull(output4, "Output 4 may not be null");

      if (_shouldRemapInputs) {
        Map<Producer<?>, Producer<?>> inputMapping =
            DAGUtil.createInputMap(_input1, _placeholder1, _input2, _placeholder2, _input3, _placeholder3, _input4,
                _placeholder4, _input5, _placeholder5);
        output1 = DAGUtil.replaceInputs(output1, inputMapping);
        output2 = DAGUtil.replaceInputs(output2, inputMapping);
        output3 = DAGUtil.replaceInputs(output3, inputMapping);
        output4 = DAGUtil.replaceInputs(output4, inputMapping);
      }

      List<Producer<?>> inputs = Arrays.asList(_input1, _input2, _input3, _input4, _input5);

      return ((DAG5x4) DAGUtil
          .createPreparableDAG(
              Arrays.asList(_placeholder1, _placeholder2, _placeholder3, _placeholder4, _placeholder5),
              Arrays.asList(output1, output2, output3, output4)).internalAPI().withInputsUnsafe(inputs))
          .withReduction(_minimumReducerLevel);
    }

    /**
     * Creates a completed DAG by supplying this partial DAG with its outputs (outputs).
     *
     * @param output1 the first output (output) of the DAG
     * @param output2 the second output (output) of the DAG
     * @param output3 the third output (output) of the DAG
     * @param output4 the fourth output (output) of the DAG
     * @param output5 the fifth output (output) of the DAG
     * @param <RA> the type of the first result
     * @param <RB> the type of the second result
     * @param <RC> the type of the third result
     * @param <RD> the type of the fourth result
     * @param <RE> the type of the fifth result
     * @return a completed DAG with 5 inputs (placeholders) and 5 outputs (outputs).
     */
    public <RA, RB, RC, RD, RE> DAG5x5<A, B, C, D, E, RA, RB, RC, RD, RE> withOutputs(Producer<? extends RA> output1,
        Producer<? extends RB> output2, Producer<? extends RC> output3, Producer<? extends RD> output4,
        Producer<? extends RE> output5) {
      Objects.requireNonNull(output1, "Output 1 may not be null");
      Objects.requireNonNull(output2, "Output 2 may not be null");
      Objects.requireNonNull(output3, "Output 3 may not be null");
      Objects.requireNonNull(output4, "Output 4 may not be null");
      Objects.requireNonNull(output5, "Output 5 may not be null");

      if (_shouldRemapInputs) {
        Map<Producer<?>, Producer<?>> inputMapping =
            DAGUtil.createInputMap(_input1, _placeholder1, _input2, _placeholder2, _input3, _placeholder3, _input4,
                _placeholder4, _input5, _placeholder5);
        output1 = DAGUtil.replaceInputs(output1, inputMapping);
        output2 = DAGUtil.replaceInputs(output2, inputMapping);
        output3 = DAGUtil.replaceInputs(output3, inputMapping);
        output4 = DAGUtil.replaceInputs(output4, inputMapping);
        output5 = DAGUtil.replaceInputs(output5, inputMapping);
      }

      List<Producer<?>> inputs = Arrays.asList(_input1, _input2, _input3, _input4, _input5);

      return ((DAG5x5) DAGUtil
          .createPreparableDAG(
              Arrays.asList(_placeholder1, _placeholder2, _placeholder3, _placeholder4, _placeholder5),
              Arrays.asList(output1, output2, output3, output4, output5)).internalAPI().withInputsUnsafe(inputs))
          .withReduction(_minimumReducerLevel);
    }

    /**
     * Creates a completed DAG by supplying this partial DAG with its outputs (outputs).
     *
     * @param output1 the first output (output) of the DAG
     * @param output2 the second output (output) of the DAG
     * @param output3 the third output (output) of the DAG
     * @param output4 the fourth output (output) of the DAG
     * @param output5 the fifth output (output) of the DAG
     * @param output6 the sixth output (output) of the DAG
     * @param <RA> the type of the first result
     * @param <RB> the type of the second result
     * @param <RC> the type of the third result
     * @param <RD> the type of the fourth result
     * @param <RE> the type of the fifth result
     * @param <RF> the type of the sixth result
     * @return a completed DAG with 5 inputs (placeholders) and 6 outputs (outputs).
     */
    public <RA, RB, RC, RD, RE, RF> DAG5x6<A, B, C, D, E, RA, RB, RC, RD, RE, RF> withOutputs(
        Producer<? extends RA> output1, Producer<? extends RB> output2, Producer<? extends RC> output3,
        Producer<? extends RD> output4, Producer<? extends RE> output5, Producer<? extends RF> output6) {
      Objects.requireNonNull(output1, "Output 1 may not be null");
      Objects.requireNonNull(output2, "Output 2 may not be null");
      Objects.requireNonNull(output3, "Output 3 may not be null");
      Objects.requireNonNull(output4, "Output 4 may not be null");
      Objects.requireNonNull(output5, "Output 5 may not be null");
      Objects.requireNonNull(output6, "Output 6 may not be null");

      if (_shouldRemapInputs) {
        Map<Producer<?>, Producer<?>> inputMapping =
            DAGUtil.createInputMap(_input1, _placeholder1, _input2, _placeholder2, _input3, _placeholder3, _input4,
                _placeholder4, _input5, _placeholder5);
        output1 = DAGUtil.replaceInputs(output1, inputMapping);
        output2 = DAGUtil.replaceInputs(output2, inputMapping);
        output3 = DAGUtil.replaceInputs(output3, inputMapping);
        output4 = DAGUtil.replaceInputs(output4, inputMapping);
        output5 = DAGUtil.replaceInputs(output5, inputMapping);
        output6 = DAGUtil.replaceInputs(output6, inputMapping);
      }

      List<Producer<?>> inputs = Arrays.asList(_input1, _input2, _input3, _input4, _input5);

      return ((DAG5x6) DAGUtil
          .createPreparableDAG(
              Arrays.asList(_placeholder1, _placeholder2, _placeholder3, _placeholder4, _placeholder5),
              Arrays.asList(output1, output2, output3, output4, output5, output6)).internalAPI()
          .withInputsUnsafe(inputs)).withReduction(_minimumReducerLevel);
    }

    /**
     * Creates a completed DAG by supplying this partial DAG with its outputs (outputs).
     *
     * @param output1 the first output (output) of the DAG
     * @param output2 the second output (output) of the DAG
     * @param output3 the third output (output) of the DAG
     * @param output4 the fourth output (output) of the DAG
     * @param output5 the fifth output (output) of the DAG
     * @param output6 the sixth output (output) of the DAG
     * @param output7 the seventh output (output) of the DAG
     * @param <RA> the type of the first result
     * @param <RB> the type of the second result
     * @param <RC> the type of the third result
     * @param <RD> the type of the fourth result
     * @param <RE> the type of the fifth result
     * @param <RF> the type of the sixth result
     * @param <RG> the type of the seventh result
     * @return a completed DAG with 5 inputs (placeholders) and 7 outputs (outputs).
     */
    public <RA, RB, RC, RD, RE, RF, RG> DAG5x7<A, B, C, D, E, RA, RB, RC, RD, RE, RF, RG> withOutputs(
        Producer<? extends RA> output1, Producer<? extends RB> output2, Producer<? extends RC> output3,
        Producer<? extends RD> output4, Producer<? extends RE> output5, Producer<? extends RF> output6,
        Producer<? extends RG> output7) {
      Objects.requireNonNull(output1, "Output 1 may not be null");
      Objects.requireNonNull(output2, "Output 2 may not be null");
      Objects.requireNonNull(output3, "Output 3 may not be null");
      Objects.requireNonNull(output4, "Output 4 may not be null");
      Objects.requireNonNull(output5, "Output 5 may not be null");
      Objects.requireNonNull(output6, "Output 6 may not be null");
      Objects.requireNonNull(output7, "Output 7 may not be null");

      if (_shouldRemapInputs) {
        Map<Producer<?>, Producer<?>> inputMapping =
            DAGUtil.createInputMap(_input1, _placeholder1, _input2, _placeholder2, _input3, _placeholder3, _input4,
                _placeholder4, _input5, _placeholder5);
        output1 = DAGUtil.replaceInputs(output1, inputMapping);
        output2 = DAGUtil.replaceInputs(output2, inputMapping);
        output3 = DAGUtil.replaceInputs(output3, inputMapping);
        output4 = DAGUtil.replaceInputs(output4, inputMapping);
        output5 = DAGUtil.replaceInputs(output5, inputMapping);
        output6 = DAGUtil.replaceInputs(output6, inputMapping);
        output7 = DAGUtil.replaceInputs(output7, inputMapping);
      }

      List<Producer<?>> inputs = Arrays.asList(_input1, _input2, _input3, _input4, _input5);

      return ((DAG5x7) DAGUtil
          .createPreparableDAG(
              Arrays.asList(_placeholder1, _placeholder2, _placeholder3, _placeholder4, _placeholder5),
              Arrays.asList(output1, output2, output3, output4, output5, output6, output7)).internalAPI()
          .withInputsUnsafe(inputs)).withReduction(_minimumReducerLevel);
    }

    /**
     * Creates a completed DAG by supplying this partial DAG with its outputs (outputs).
     *
     * @param output1 the first output (output) of the DAG
     * @param output2 the second output (output) of the DAG
     * @param output3 the third output (output) of the DAG
     * @param output4 the fourth output (output) of the DAG
     * @param output5 the fifth output (output) of the DAG
     * @param output6 the sixth output (output) of the DAG
     * @param output7 the seventh output (output) of the DAG
     * @param output8 the eighth output (output) of the DAG
     * @param <RA> the type of the first result
     * @param <RB> the type of the second result
     * @param <RC> the type of the third result
     * @param <RD> the type of the fourth result
     * @param <RE> the type of the fifth result
     * @param <RF> the type of the sixth result
     * @param <RG> the type of the seventh result
     * @param <RH> the type of the eighth result
     * @return a completed DAG with 5 inputs (placeholders) and 8 outputs (outputs).
     */
    public <RA, RB, RC, RD, RE, RF, RG, RH> DAG5x8<A, B, C, D, E, RA, RB, RC, RD, RE, RF, RG, RH> withOutputs(
        Producer<? extends RA> output1, Producer<? extends RB> output2, Producer<? extends RC> output3,
        Producer<? extends RD> output4, Producer<? extends RE> output5, Producer<? extends RF> output6,
        Producer<? extends RG> output7, Producer<? extends RH> output8) {
      Objects.requireNonNull(output1, "Output 1 may not be null");
      Objects.requireNonNull(output2, "Output 2 may not be null");
      Objects.requireNonNull(output3, "Output 3 may not be null");
      Objects.requireNonNull(output4, "Output 4 may not be null");
      Objects.requireNonNull(output5, "Output 5 may not be null");
      Objects.requireNonNull(output6, "Output 6 may not be null");
      Objects.requireNonNull(output7, "Output 7 may not be null");
      Objects.requireNonNull(output8, "Output 8 may not be null");

      if (_shouldRemapInputs) {
        Map<Producer<?>, Producer<?>> inputMapping =
            DAGUtil.createInputMap(_input1, _placeholder1, _input2, _placeholder2, _input3, _placeholder3, _input4,
                _placeholder4, _input5, _placeholder5);
        output1 = DAGUtil.replaceInputs(output1, inputMapping);
        output2 = DAGUtil.replaceInputs(output2, inputMapping);
        output3 = DAGUtil.replaceInputs(output3, inputMapping);
        output4 = DAGUtil.replaceInputs(output4, inputMapping);
        output5 = DAGUtil.replaceInputs(output5, inputMapping);
        output6 = DAGUtil.replaceInputs(output6, inputMapping);
        output7 = DAGUtil.replaceInputs(output7, inputMapping);
        output8 = DAGUtil.replaceInputs(output8, inputMapping);
      }

      List<Producer<?>> inputs = Arrays.asList(_input1, _input2, _input3, _input4, _input5);

      return ((DAG5x8) DAGUtil
          .createPreparableDAG(
              Arrays.asList(_placeholder1, _placeholder2, _placeholder3, _placeholder4, _placeholder5),
              Arrays.asList(output1, output2, output3, output4, output5, output6, output7, output8)).internalAPI()
          .withInputsUnsafe(inputs)).withReduction(_minimumReducerLevel);
    }

    /**
     * Creates a completed DAG by supplying this partial DAG with its outputs (outputs).
     *
     * @param output1 the first output (output) of the DAG
     * @param output2 the second output (output) of the DAG
     * @param output3 the third output (output) of the DAG
     * @param output4 the fourth output (output) of the DAG
     * @param output5 the fifth output (output) of the DAG
     * @param output6 the sixth output (output) of the DAG
     * @param output7 the seventh output (output) of the DAG
     * @param output8 the eighth output (output) of the DAG
     * @param output9 the ninth output (output) of the DAG
     * @param <RA> the type of the first result
     * @param <RB> the type of the second result
     * @param <RC> the type of the third result
     * @param <RD> the type of the fourth result
     * @param <RE> the type of the fifth result
     * @param <RF> the type of the sixth result
     * @param <RG> the type of the seventh result
     * @param <RH> the type of the eighth result
     * @param <RI> the type of the ninth result
     * @return a completed DAG with 5 inputs (placeholders) and 9 outputs (outputs).
     */
    public <RA, RB, RC, RD, RE, RF, RG, RH, RI> DAG5x9<A, B, C, D, E, RA, RB, RC, RD, RE, RF, RG, RH, RI> withOutputs(
        Producer<? extends RA> output1, Producer<? extends RB> output2, Producer<? extends RC> output3,
        Producer<? extends RD> output4, Producer<? extends RE> output5, Producer<? extends RF> output6,
        Producer<? extends RG> output7, Producer<? extends RH> output8, Producer<? extends RI> output9) {
      Objects.requireNonNull(output1, "Output 1 may not be null");
      Objects.requireNonNull(output2, "Output 2 may not be null");
      Objects.requireNonNull(output3, "Output 3 may not be null");
      Objects.requireNonNull(output4, "Output 4 may not be null");
      Objects.requireNonNull(output5, "Output 5 may not be null");
      Objects.requireNonNull(output6, "Output 6 may not be null");
      Objects.requireNonNull(output7, "Output 7 may not be null");
      Objects.requireNonNull(output8, "Output 8 may not be null");
      Objects.requireNonNull(output9, "Output 9 may not be null");

      if (_shouldRemapInputs) {
        Map<Producer<?>, Producer<?>> inputMapping =
            DAGUtil.createInputMap(_input1, _placeholder1, _input2, _placeholder2, _input3, _placeholder3, _input4,
                _placeholder4, _input5, _placeholder5);
        output1 = DAGUtil.replaceInputs(output1, inputMapping);
        output2 = DAGUtil.replaceInputs(output2, inputMapping);
        output3 = DAGUtil.replaceInputs(output3, inputMapping);
        output4 = DAGUtil.replaceInputs(output4, inputMapping);
        output5 = DAGUtil.replaceInputs(output5, inputMapping);
        output6 = DAGUtil.replaceInputs(output6, inputMapping);
        output7 = DAGUtil.replaceInputs(output7, inputMapping);
        output8 = DAGUtil.replaceInputs(output8, inputMapping);
        output9 = DAGUtil.replaceInputs(output9, inputMapping);
      }

      List<Producer<?>> inputs = Arrays.asList(_input1, _input2, _input3, _input4, _input5);

      return ((DAG5x9) DAGUtil
          .createPreparableDAG(
              Arrays.asList(_placeholder1, _placeholder2, _placeholder3, _placeholder4, _placeholder5),
              Arrays.asList(output1, output2, output3, output4, output5, output6, output7, output8, output9))
          .internalAPI().withInputsUnsafe(inputs)).withReduction(_minimumReducerLevel);
    }

    /**
     * Creates a completed DAG by supplying this partial DAG with its outputs (outputs).
     *
     * @param output1 the first output (output) of the DAG
     * @param output2 the second output (output) of the DAG
     * @param output3 the third output (output) of the DAG
     * @param output4 the fourth output (output) of the DAG
     * @param output5 the fifth output (output) of the DAG
     * @param output6 the sixth output (output) of the DAG
     * @param output7 the seventh output (output) of the DAG
     * @param output8 the eighth output (output) of the DAG
     * @param output9 the ninth output (output) of the DAG
     * @param output10 the tenth output (output) of the DAG
     * @param <RA> the type of the first result
     * @param <RB> the type of the second result
     * @param <RC> the type of the third result
     * @param <RD> the type of the fourth result
     * @param <RE> the type of the fifth result
     * @param <RF> the type of the sixth result
     * @param <RG> the type of the seventh result
     * @param <RH> the type of the eighth result
     * @param <RI> the type of the ninth result
     * @param <RJ> the type of the tenth result
     * @return a completed DAG with 5 inputs (placeholders) and 10 outputs (outputs).
     */
    public <RA, RB, RC, RD, RE, RF, RG, RH, RI, RJ> DAG5x10<A, B, C, D, E, RA, RB, RC, RD, RE, RF, RG, RH, RI, RJ> withOutputs(
        Producer<? extends RA> output1, Producer<? extends RB> output2, Producer<? extends RC> output3,
        Producer<? extends RD> output4, Producer<? extends RE> output5, Producer<? extends RF> output6,
        Producer<? extends RG> output7, Producer<? extends RH> output8, Producer<? extends RI> output9,
        Producer<? extends RJ> output10) {
      Objects.requireNonNull(output1, "Output 1 may not be null");
      Objects.requireNonNull(output2, "Output 2 may not be null");
      Objects.requireNonNull(output3, "Output 3 may not be null");
      Objects.requireNonNull(output4, "Output 4 may not be null");
      Objects.requireNonNull(output5, "Output 5 may not be null");
      Objects.requireNonNull(output6, "Output 6 may not be null");
      Objects.requireNonNull(output7, "Output 7 may not be null");
      Objects.requireNonNull(output8, "Output 8 may not be null");
      Objects.requireNonNull(output9, "Output 9 may not be null");
      Objects.requireNonNull(output10, "Output 10 may not be null");

      if (_shouldRemapInputs) {
        Map<Producer<?>, Producer<?>> inputMapping =
            DAGUtil.createInputMap(_input1, _placeholder1, _input2, _placeholder2, _input3, _placeholder3, _input4,
                _placeholder4, _input5, _placeholder5);
        output1 = DAGUtil.replaceInputs(output1, inputMapping);
        output2 = DAGUtil.replaceInputs(output2, inputMapping);
        output3 = DAGUtil.replaceInputs(output3, inputMapping);
        output4 = DAGUtil.replaceInputs(output4, inputMapping);
        output5 = DAGUtil.replaceInputs(output5, inputMapping);
        output6 = DAGUtil.replaceInputs(output6, inputMapping);
        output7 = DAGUtil.replaceInputs(output7, inputMapping);
        output8 = DAGUtil.replaceInputs(output8, inputMapping);
        output9 = DAGUtil.replaceInputs(output9, inputMapping);
        output10 = DAGUtil.replaceInputs(output10, inputMapping);
      }

      List<Producer<?>> inputs = Arrays.asList(_input1, _input2, _input3, _input4, _input5);

      return ((DAG5x10) DAGUtil
          .createPreparableDAG(
              Arrays.asList(_placeholder1, _placeholder2, _placeholder3, _placeholder4, _placeholder5),
              Arrays.asList(output1, output2, output3, output4, output5, output6, output7, output8, output9, output10))
          .internalAPI().withInputsUnsafe(inputs)).withReduction(_minimumReducerLevel);
    }
  }

  /**
    * A partial DAG with 6 placeholder.  Partial DAGs are <i>completed</i> to create a usable DAG by specifying
    * the outputs (<i>outputs</i>) of the DAG using the withOutputs(...) methods.
    *
   * @param <A> the type of the first input
   * @param <B> the type of the second input
   * @param <C> the type of the third input
   * @param <D> the type of the fourth input
   * @param <E> the type of the fifth input
   * @param <F> the type of the sixth input
    */
  public static class WithPlaceholders6<A, B, C, D, E, F> extends
      AbstractWithPlaceholders6<A, B, C, D, E, F, WithPlaceholders6<A, B, C, D, E, F>> {
    /**
     * Creates a new partial DAG that will be rooted at the provided placeholders.
     *
     * @param placeholder1 the first placeholder
     * @param placeholder2 the second placeholder
     * @param placeholder3 the third placeholder
     * @param placeholder4 the fourth placeholder
     * @param placeholder5 the fifth placeholder
     * @param placeholder6 the sixth placeholder
     */
    WithPlaceholders6(Placeholder<? extends A> placeholder1, Placeholder<? extends B> placeholder2,
        Placeholder<? extends C> placeholder3, Placeholder<? extends D> placeholder4,
        Placeholder<? extends E> placeholder5, Placeholder<? extends F> placeholder6) {
      super(placeholder1, placeholder2, placeholder3, placeholder4, placeholder5, placeholder6);
    }

    /**
     * Creates a new partial DAG that will be rooted at the provided placeholders, which will replace ("remap") the provided
     * "input" nodes that define a subgraph of the original graph (as defined by the ancestors of the outputs that will
     * be provided when the partial DAG is completed).  The input nodes, and any nodes that were exclusively the
     * ancestors of the input nodes, are truncated from the resulting graph.
     *
     * @param placeholder1 the first placeholder
     * @param placeholder2 the second placeholder
     * @param placeholder3 the third placeholder
     * @param placeholder4 the fourth placeholder
     * @param placeholder5 the fifth placeholder
     * @param placeholder6 the sixth placeholder
     * @param input1 the first input
     * @param input2 the second input
     * @param input3 the third input
     * @param input4 the fourth input
     * @param input5 the fifth input
     * @param input6 the sixth input
     */
    WithPlaceholders6(Placeholder<? extends A> placeholder1, Placeholder<? extends B> placeholder2,
        Placeholder<? extends C> placeholder3, Placeholder<? extends D> placeholder4,
        Placeholder<? extends E> placeholder5, Placeholder<? extends F> placeholder6, Producer<? extends A> input1,
        Producer<? extends B> input2, Producer<? extends C> input3, Producer<? extends D> input4,
        Producer<? extends E> input5, Producer<? extends F> input6) {
      super(placeholder1, placeholder2, placeholder3, placeholder4, placeholder5, placeholder6, input1, input2, input3,
          input4, input5, input6);
    }

    /**
     * Creates a completed DAG by supplying this partial DAG with its outputs (outputs).
     *
     * @param output1 the first output (output) of the DAG
     * @param <RA> the type of the first result
     * @return a completed DAG with 6 inputs (placeholders) and 1 output (outputs).
     */
    public <RA> DAG6x1<A, B, C, D, E, F, RA> withOutputs(Producer<? extends RA> output1) {
      Objects.requireNonNull(output1, "Output 1 may not be null");

      if (_shouldRemapInputs) {
        Map<Producer<?>, Producer<?>> inputMapping =
            DAGUtil.createInputMap(_input1, _placeholder1, _input2, _placeholder2, _input3, _placeholder3, _input4,
                _placeholder4, _input5, _placeholder5, _input6, _placeholder6);
        output1 = DAGUtil.replaceInputs(output1, inputMapping);
      }

      List<Producer<?>> inputs = Arrays.asList(_input1, _input2, _input3, _input4, _input5, _input6);

      return ((DAG6x1) DAGUtil
          .createPreparableDAG(
              Arrays.asList(_placeholder1, _placeholder2, _placeholder3, _placeholder4, _placeholder5, _placeholder6),
              Arrays.asList(output1)).internalAPI().withInputsUnsafe(inputs)).withReduction(_minimumReducerLevel);
    }

    /**
     * Creates a completed DAG by supplying this partial DAG with its outputs (outputs).
     *
     * @param output1 the first output (output) of the DAG
     * @param <RA> the type of the first result
     * @return a completed DAG with 6 inputs (placeholders) and 1 output (outputs).
     */
    public <RA> DAG6x1<A, B, C, D, E, F, RA> withOutput(Producer<? extends RA> output1) {
      Objects.requireNonNull(output1, "Output 1 may not be null");

      if (_shouldRemapInputs) {
        Map<Producer<?>, Producer<?>> inputMapping =
            DAGUtil.createInputMap(_input1, _placeholder1, _input2, _placeholder2, _input3, _placeholder3, _input4,
                _placeholder4, _input5, _placeholder5, _input6, _placeholder6);
        output1 = DAGUtil.replaceInputs(output1, inputMapping);
      }

      List<Producer<?>> inputs = Arrays.asList(_input1, _input2, _input3, _input4, _input5, _input6);

      return ((DAG6x1) DAGUtil
          .createPreparableDAG(
              Arrays.asList(_placeholder1, _placeholder2, _placeholder3, _placeholder4, _placeholder5, _placeholder6),
              Arrays.asList(output1)).internalAPI().withInputsUnsafe(inputs)).withReduction(_minimumReducerLevel);
    }

    /**
     * Creates a completed DAG by supplying this partial DAG with its outputs (outputs).
     *
     * @param output1 the first output (output) of the DAG
     * @param output2 the second output (output) of the DAG
     * @param <RA> the type of the first result
     * @param <RB> the type of the second result
     * @return a completed DAG with 6 inputs (placeholders) and 2 outputs (outputs).
     */
    public <RA, RB> DAG6x2<A, B, C, D, E, F, RA, RB> withOutputs(Producer<? extends RA> output1,
        Producer<? extends RB> output2) {
      Objects.requireNonNull(output1, "Output 1 may not be null");
      Objects.requireNonNull(output2, "Output 2 may not be null");

      if (_shouldRemapInputs) {
        Map<Producer<?>, Producer<?>> inputMapping =
            DAGUtil.createInputMap(_input1, _placeholder1, _input2, _placeholder2, _input3, _placeholder3, _input4,
                _placeholder4, _input5, _placeholder5, _input6, _placeholder6);
        output1 = DAGUtil.replaceInputs(output1, inputMapping);
        output2 = DAGUtil.replaceInputs(output2, inputMapping);
      }

      List<Producer<?>> inputs = Arrays.asList(_input1, _input2, _input3, _input4, _input5, _input6);

      return ((DAG6x2) DAGUtil
          .createPreparableDAG(
              Arrays.asList(_placeholder1, _placeholder2, _placeholder3, _placeholder4, _placeholder5, _placeholder6),
              Arrays.asList(output1, output2)).internalAPI().withInputsUnsafe(inputs))
          .withReduction(_minimumReducerLevel);
    }

    /**
     * Creates a completed DAG by supplying this partial DAG with its outputs (outputs).
     *
     * @param output1 the first output (output) of the DAG
     * @param output2 the second output (output) of the DAG
     * @param output3 the third output (output) of the DAG
     * @param <RA> the type of the first result
     * @param <RB> the type of the second result
     * @param <RC> the type of the third result
     * @return a completed DAG with 6 inputs (placeholders) and 3 outputs (outputs).
     */
    public <RA, RB, RC> DAG6x3<A, B, C, D, E, F, RA, RB, RC> withOutputs(Producer<? extends RA> output1,
        Producer<? extends RB> output2, Producer<? extends RC> output3) {
      Objects.requireNonNull(output1, "Output 1 may not be null");
      Objects.requireNonNull(output2, "Output 2 may not be null");
      Objects.requireNonNull(output3, "Output 3 may not be null");

      if (_shouldRemapInputs) {
        Map<Producer<?>, Producer<?>> inputMapping =
            DAGUtil.createInputMap(_input1, _placeholder1, _input2, _placeholder2, _input3, _placeholder3, _input4,
                _placeholder4, _input5, _placeholder5, _input6, _placeholder6);
        output1 = DAGUtil.replaceInputs(output1, inputMapping);
        output2 = DAGUtil.replaceInputs(output2, inputMapping);
        output3 = DAGUtil.replaceInputs(output3, inputMapping);
      }

      List<Producer<?>> inputs = Arrays.asList(_input1, _input2, _input3, _input4, _input5, _input6);

      return ((DAG6x3) DAGUtil
          .createPreparableDAG(
              Arrays.asList(_placeholder1, _placeholder2, _placeholder3, _placeholder4, _placeholder5, _placeholder6),
              Arrays.asList(output1, output2, output3)).internalAPI().withInputsUnsafe(inputs))
          .withReduction(_minimumReducerLevel);
    }

    /**
     * Creates a completed DAG by supplying this partial DAG with its outputs (outputs).
     *
     * @param output1 the first output (output) of the DAG
     * @param output2 the second output (output) of the DAG
     * @param output3 the third output (output) of the DAG
     * @param output4 the fourth output (output) of the DAG
     * @param <RA> the type of the first result
     * @param <RB> the type of the second result
     * @param <RC> the type of the third result
     * @param <RD> the type of the fourth result
     * @return a completed DAG with 6 inputs (placeholders) and 4 outputs (outputs).
     */
    public <RA, RB, RC, RD> DAG6x4<A, B, C, D, E, F, RA, RB, RC, RD> withOutputs(Producer<? extends RA> output1,
        Producer<? extends RB> output2, Producer<? extends RC> output3, Producer<? extends RD> output4) {
      Objects.requireNonNull(output1, "Output 1 may not be null");
      Objects.requireNonNull(output2, "Output 2 may not be null");
      Objects.requireNonNull(output3, "Output 3 may not be null");
      Objects.requireNonNull(output4, "Output 4 may not be null");

      if (_shouldRemapInputs) {
        Map<Producer<?>, Producer<?>> inputMapping =
            DAGUtil.createInputMap(_input1, _placeholder1, _input2, _placeholder2, _input3, _placeholder3, _input4,
                _placeholder4, _input5, _placeholder5, _input6, _placeholder6);
        output1 = DAGUtil.replaceInputs(output1, inputMapping);
        output2 = DAGUtil.replaceInputs(output2, inputMapping);
        output3 = DAGUtil.replaceInputs(output3, inputMapping);
        output4 = DAGUtil.replaceInputs(output4, inputMapping);
      }

      List<Producer<?>> inputs = Arrays.asList(_input1, _input2, _input3, _input4, _input5, _input6);

      return ((DAG6x4) DAGUtil
          .createPreparableDAG(
              Arrays.asList(_placeholder1, _placeholder2, _placeholder3, _placeholder4, _placeholder5, _placeholder6),
              Arrays.asList(output1, output2, output3, output4)).internalAPI().withInputsUnsafe(inputs))
          .withReduction(_minimumReducerLevel);
    }

    /**
     * Creates a completed DAG by supplying this partial DAG with its outputs (outputs).
     *
     * @param output1 the first output (output) of the DAG
     * @param output2 the second output (output) of the DAG
     * @param output3 the third output (output) of the DAG
     * @param output4 the fourth output (output) of the DAG
     * @param output5 the fifth output (output) of the DAG
     * @param <RA> the type of the first result
     * @param <RB> the type of the second result
     * @param <RC> the type of the third result
     * @param <RD> the type of the fourth result
     * @param <RE> the type of the fifth result
     * @return a completed DAG with 6 inputs (placeholders) and 5 outputs (outputs).
     */
    public <RA, RB, RC, RD, RE> DAG6x5<A, B, C, D, E, F, RA, RB, RC, RD, RE> withOutputs(
        Producer<? extends RA> output1, Producer<? extends RB> output2, Producer<? extends RC> output3,
        Producer<? extends RD> output4, Producer<? extends RE> output5) {
      Objects.requireNonNull(output1, "Output 1 may not be null");
      Objects.requireNonNull(output2, "Output 2 may not be null");
      Objects.requireNonNull(output3, "Output 3 may not be null");
      Objects.requireNonNull(output4, "Output 4 may not be null");
      Objects.requireNonNull(output5, "Output 5 may not be null");

      if (_shouldRemapInputs) {
        Map<Producer<?>, Producer<?>> inputMapping =
            DAGUtil.createInputMap(_input1, _placeholder1, _input2, _placeholder2, _input3, _placeholder3, _input4,
                _placeholder4, _input5, _placeholder5, _input6, _placeholder6);
        output1 = DAGUtil.replaceInputs(output1, inputMapping);
        output2 = DAGUtil.replaceInputs(output2, inputMapping);
        output3 = DAGUtil.replaceInputs(output3, inputMapping);
        output4 = DAGUtil.replaceInputs(output4, inputMapping);
        output5 = DAGUtil.replaceInputs(output5, inputMapping);
      }

      List<Producer<?>> inputs = Arrays.asList(_input1, _input2, _input3, _input4, _input5, _input6);

      return ((DAG6x5) DAGUtil
          .createPreparableDAG(
              Arrays.asList(_placeholder1, _placeholder2, _placeholder3, _placeholder4, _placeholder5, _placeholder6),
              Arrays.asList(output1, output2, output3, output4, output5)).internalAPI().withInputsUnsafe(inputs))
          .withReduction(_minimumReducerLevel);
    }

    /**
     * Creates a completed DAG by supplying this partial DAG with its outputs (outputs).
     *
     * @param output1 the first output (output) of the DAG
     * @param output2 the second output (output) of the DAG
     * @param output3 the third output (output) of the DAG
     * @param output4 the fourth output (output) of the DAG
     * @param output5 the fifth output (output) of the DAG
     * @param output6 the sixth output (output) of the DAG
     * @param <RA> the type of the first result
     * @param <RB> the type of the second result
     * @param <RC> the type of the third result
     * @param <RD> the type of the fourth result
     * @param <RE> the type of the fifth result
     * @param <RF> the type of the sixth result
     * @return a completed DAG with 6 inputs (placeholders) and 6 outputs (outputs).
     */
    public <RA, RB, RC, RD, RE, RF> DAG6x6<A, B, C, D, E, F, RA, RB, RC, RD, RE, RF> withOutputs(
        Producer<? extends RA> output1, Producer<? extends RB> output2, Producer<? extends RC> output3,
        Producer<? extends RD> output4, Producer<? extends RE> output5, Producer<? extends RF> output6) {
      Objects.requireNonNull(output1, "Output 1 may not be null");
      Objects.requireNonNull(output2, "Output 2 may not be null");
      Objects.requireNonNull(output3, "Output 3 may not be null");
      Objects.requireNonNull(output4, "Output 4 may not be null");
      Objects.requireNonNull(output5, "Output 5 may not be null");
      Objects.requireNonNull(output6, "Output 6 may not be null");

      if (_shouldRemapInputs) {
        Map<Producer<?>, Producer<?>> inputMapping =
            DAGUtil.createInputMap(_input1, _placeholder1, _input2, _placeholder2, _input3, _placeholder3, _input4,
                _placeholder4, _input5, _placeholder5, _input6, _placeholder6);
        output1 = DAGUtil.replaceInputs(output1, inputMapping);
        output2 = DAGUtil.replaceInputs(output2, inputMapping);
        output3 = DAGUtil.replaceInputs(output3, inputMapping);
        output4 = DAGUtil.replaceInputs(output4, inputMapping);
        output5 = DAGUtil.replaceInputs(output5, inputMapping);
        output6 = DAGUtil.replaceInputs(output6, inputMapping);
      }

      List<Producer<?>> inputs = Arrays.asList(_input1, _input2, _input3, _input4, _input5, _input6);

      return ((DAG6x6) DAGUtil
          .createPreparableDAG(
              Arrays.asList(_placeholder1, _placeholder2, _placeholder3, _placeholder4, _placeholder5, _placeholder6),
              Arrays.asList(output1, output2, output3, output4, output5, output6)).internalAPI()
          .withInputsUnsafe(inputs)).withReduction(_minimumReducerLevel);
    }

    /**
     * Creates a completed DAG by supplying this partial DAG with its outputs (outputs).
     *
     * @param output1 the first output (output) of the DAG
     * @param output2 the second output (output) of the DAG
     * @param output3 the third output (output) of the DAG
     * @param output4 the fourth output (output) of the DAG
     * @param output5 the fifth output (output) of the DAG
     * @param output6 the sixth output (output) of the DAG
     * @param output7 the seventh output (output) of the DAG
     * @param <RA> the type of the first result
     * @param <RB> the type of the second result
     * @param <RC> the type of the third result
     * @param <RD> the type of the fourth result
     * @param <RE> the type of the fifth result
     * @param <RF> the type of the sixth result
     * @param <RG> the type of the seventh result
     * @return a completed DAG with 6 inputs (placeholders) and 7 outputs (outputs).
     */
    public <RA, RB, RC, RD, RE, RF, RG> DAG6x7<A, B, C, D, E, F, RA, RB, RC, RD, RE, RF, RG> withOutputs(
        Producer<? extends RA> output1, Producer<? extends RB> output2, Producer<? extends RC> output3,
        Producer<? extends RD> output4, Producer<? extends RE> output5, Producer<? extends RF> output6,
        Producer<? extends RG> output7) {
      Objects.requireNonNull(output1, "Output 1 may not be null");
      Objects.requireNonNull(output2, "Output 2 may not be null");
      Objects.requireNonNull(output3, "Output 3 may not be null");
      Objects.requireNonNull(output4, "Output 4 may not be null");
      Objects.requireNonNull(output5, "Output 5 may not be null");
      Objects.requireNonNull(output6, "Output 6 may not be null");
      Objects.requireNonNull(output7, "Output 7 may not be null");

      if (_shouldRemapInputs) {
        Map<Producer<?>, Producer<?>> inputMapping =
            DAGUtil.createInputMap(_input1, _placeholder1, _input2, _placeholder2, _input3, _placeholder3, _input4,
                _placeholder4, _input5, _placeholder5, _input6, _placeholder6);
        output1 = DAGUtil.replaceInputs(output1, inputMapping);
        output2 = DAGUtil.replaceInputs(output2, inputMapping);
        output3 = DAGUtil.replaceInputs(output3, inputMapping);
        output4 = DAGUtil.replaceInputs(output4, inputMapping);
        output5 = DAGUtil.replaceInputs(output5, inputMapping);
        output6 = DAGUtil.replaceInputs(output6, inputMapping);
        output7 = DAGUtil.replaceInputs(output7, inputMapping);
      }

      List<Producer<?>> inputs = Arrays.asList(_input1, _input2, _input3, _input4, _input5, _input6);

      return ((DAG6x7) DAGUtil
          .createPreparableDAG(
              Arrays.asList(_placeholder1, _placeholder2, _placeholder3, _placeholder4, _placeholder5, _placeholder6),
              Arrays.asList(output1, output2, output3, output4, output5, output6, output7)).internalAPI()
          .withInputsUnsafe(inputs)).withReduction(_minimumReducerLevel);
    }

    /**
     * Creates a completed DAG by supplying this partial DAG with its outputs (outputs).
     *
     * @param output1 the first output (output) of the DAG
     * @param output2 the second output (output) of the DAG
     * @param output3 the third output (output) of the DAG
     * @param output4 the fourth output (output) of the DAG
     * @param output5 the fifth output (output) of the DAG
     * @param output6 the sixth output (output) of the DAG
     * @param output7 the seventh output (output) of the DAG
     * @param output8 the eighth output (output) of the DAG
     * @param <RA> the type of the first result
     * @param <RB> the type of the second result
     * @param <RC> the type of the third result
     * @param <RD> the type of the fourth result
     * @param <RE> the type of the fifth result
     * @param <RF> the type of the sixth result
     * @param <RG> the type of the seventh result
     * @param <RH> the type of the eighth result
     * @return a completed DAG with 6 inputs (placeholders) and 8 outputs (outputs).
     */
    public <RA, RB, RC, RD, RE, RF, RG, RH> DAG6x8<A, B, C, D, E, F, RA, RB, RC, RD, RE, RF, RG, RH> withOutputs(
        Producer<? extends RA> output1, Producer<? extends RB> output2, Producer<? extends RC> output3,
        Producer<? extends RD> output4, Producer<? extends RE> output5, Producer<? extends RF> output6,
        Producer<? extends RG> output7, Producer<? extends RH> output8) {
      Objects.requireNonNull(output1, "Output 1 may not be null");
      Objects.requireNonNull(output2, "Output 2 may not be null");
      Objects.requireNonNull(output3, "Output 3 may not be null");
      Objects.requireNonNull(output4, "Output 4 may not be null");
      Objects.requireNonNull(output5, "Output 5 may not be null");
      Objects.requireNonNull(output6, "Output 6 may not be null");
      Objects.requireNonNull(output7, "Output 7 may not be null");
      Objects.requireNonNull(output8, "Output 8 may not be null");

      if (_shouldRemapInputs) {
        Map<Producer<?>, Producer<?>> inputMapping =
            DAGUtil.createInputMap(_input1, _placeholder1, _input2, _placeholder2, _input3, _placeholder3, _input4,
                _placeholder4, _input5, _placeholder5, _input6, _placeholder6);
        output1 = DAGUtil.replaceInputs(output1, inputMapping);
        output2 = DAGUtil.replaceInputs(output2, inputMapping);
        output3 = DAGUtil.replaceInputs(output3, inputMapping);
        output4 = DAGUtil.replaceInputs(output4, inputMapping);
        output5 = DAGUtil.replaceInputs(output5, inputMapping);
        output6 = DAGUtil.replaceInputs(output6, inputMapping);
        output7 = DAGUtil.replaceInputs(output7, inputMapping);
        output8 = DAGUtil.replaceInputs(output8, inputMapping);
      }

      List<Producer<?>> inputs = Arrays.asList(_input1, _input2, _input3, _input4, _input5, _input6);

      return ((DAG6x8) DAGUtil
          .createPreparableDAG(
              Arrays.asList(_placeholder1, _placeholder2, _placeholder3, _placeholder4, _placeholder5, _placeholder6),
              Arrays.asList(output1, output2, output3, output4, output5, output6, output7, output8)).internalAPI()
          .withInputsUnsafe(inputs)).withReduction(_minimumReducerLevel);
    }

    /**
     * Creates a completed DAG by supplying this partial DAG with its outputs (outputs).
     *
     * @param output1 the first output (output) of the DAG
     * @param output2 the second output (output) of the DAG
     * @param output3 the third output (output) of the DAG
     * @param output4 the fourth output (output) of the DAG
     * @param output5 the fifth output (output) of the DAG
     * @param output6 the sixth output (output) of the DAG
     * @param output7 the seventh output (output) of the DAG
     * @param output8 the eighth output (output) of the DAG
     * @param output9 the ninth output (output) of the DAG
     * @param <RA> the type of the first result
     * @param <RB> the type of the second result
     * @param <RC> the type of the third result
     * @param <RD> the type of the fourth result
     * @param <RE> the type of the fifth result
     * @param <RF> the type of the sixth result
     * @param <RG> the type of the seventh result
     * @param <RH> the type of the eighth result
     * @param <RI> the type of the ninth result
     * @return a completed DAG with 6 inputs (placeholders) and 9 outputs (outputs).
     */
    public <RA, RB, RC, RD, RE, RF, RG, RH, RI> DAG6x9<A, B, C, D, E, F, RA, RB, RC, RD, RE, RF, RG, RH, RI> withOutputs(
        Producer<? extends RA> output1, Producer<? extends RB> output2, Producer<? extends RC> output3,
        Producer<? extends RD> output4, Producer<? extends RE> output5, Producer<? extends RF> output6,
        Producer<? extends RG> output7, Producer<? extends RH> output8, Producer<? extends RI> output9) {
      Objects.requireNonNull(output1, "Output 1 may not be null");
      Objects.requireNonNull(output2, "Output 2 may not be null");
      Objects.requireNonNull(output3, "Output 3 may not be null");
      Objects.requireNonNull(output4, "Output 4 may not be null");
      Objects.requireNonNull(output5, "Output 5 may not be null");
      Objects.requireNonNull(output6, "Output 6 may not be null");
      Objects.requireNonNull(output7, "Output 7 may not be null");
      Objects.requireNonNull(output8, "Output 8 may not be null");
      Objects.requireNonNull(output9, "Output 9 may not be null");

      if (_shouldRemapInputs) {
        Map<Producer<?>, Producer<?>> inputMapping =
            DAGUtil.createInputMap(_input1, _placeholder1, _input2, _placeholder2, _input3, _placeholder3, _input4,
                _placeholder4, _input5, _placeholder5, _input6, _placeholder6);
        output1 = DAGUtil.replaceInputs(output1, inputMapping);
        output2 = DAGUtil.replaceInputs(output2, inputMapping);
        output3 = DAGUtil.replaceInputs(output3, inputMapping);
        output4 = DAGUtil.replaceInputs(output4, inputMapping);
        output5 = DAGUtil.replaceInputs(output5, inputMapping);
        output6 = DAGUtil.replaceInputs(output6, inputMapping);
        output7 = DAGUtil.replaceInputs(output7, inputMapping);
        output8 = DAGUtil.replaceInputs(output8, inputMapping);
        output9 = DAGUtil.replaceInputs(output9, inputMapping);
      }

      List<Producer<?>> inputs = Arrays.asList(_input1, _input2, _input3, _input4, _input5, _input6);

      return ((DAG6x9) DAGUtil
          .createPreparableDAG(
              Arrays.asList(_placeholder1, _placeholder2, _placeholder3, _placeholder4, _placeholder5, _placeholder6),
              Arrays.asList(output1, output2, output3, output4, output5, output6, output7, output8, output9))
          .internalAPI().withInputsUnsafe(inputs)).withReduction(_minimumReducerLevel);
    }

    /**
     * Creates a completed DAG by supplying this partial DAG with its outputs (outputs).
     *
     * @param output1 the first output (output) of the DAG
     * @param output2 the second output (output) of the DAG
     * @param output3 the third output (output) of the DAG
     * @param output4 the fourth output (output) of the DAG
     * @param output5 the fifth output (output) of the DAG
     * @param output6 the sixth output (output) of the DAG
     * @param output7 the seventh output (output) of the DAG
     * @param output8 the eighth output (output) of the DAG
     * @param output9 the ninth output (output) of the DAG
     * @param output10 the tenth output (output) of the DAG
     * @param <RA> the type of the first result
     * @param <RB> the type of the second result
     * @param <RC> the type of the third result
     * @param <RD> the type of the fourth result
     * @param <RE> the type of the fifth result
     * @param <RF> the type of the sixth result
     * @param <RG> the type of the seventh result
     * @param <RH> the type of the eighth result
     * @param <RI> the type of the ninth result
     * @param <RJ> the type of the tenth result
     * @return a completed DAG with 6 inputs (placeholders) and 10 outputs (outputs).
     */
    public <RA, RB, RC, RD, RE, RF, RG, RH, RI, RJ> DAG6x10<A, B, C, D, E, F, RA, RB, RC, RD, RE, RF, RG, RH, RI, RJ> withOutputs(
        Producer<? extends RA> output1, Producer<? extends RB> output2, Producer<? extends RC> output3,
        Producer<? extends RD> output4, Producer<? extends RE> output5, Producer<? extends RF> output6,
        Producer<? extends RG> output7, Producer<? extends RH> output8, Producer<? extends RI> output9,
        Producer<? extends RJ> output10) {
      Objects.requireNonNull(output1, "Output 1 may not be null");
      Objects.requireNonNull(output2, "Output 2 may not be null");
      Objects.requireNonNull(output3, "Output 3 may not be null");
      Objects.requireNonNull(output4, "Output 4 may not be null");
      Objects.requireNonNull(output5, "Output 5 may not be null");
      Objects.requireNonNull(output6, "Output 6 may not be null");
      Objects.requireNonNull(output7, "Output 7 may not be null");
      Objects.requireNonNull(output8, "Output 8 may not be null");
      Objects.requireNonNull(output9, "Output 9 may not be null");
      Objects.requireNonNull(output10, "Output 10 may not be null");

      if (_shouldRemapInputs) {
        Map<Producer<?>, Producer<?>> inputMapping =
            DAGUtil.createInputMap(_input1, _placeholder1, _input2, _placeholder2, _input3, _placeholder3, _input4,
                _placeholder4, _input5, _placeholder5, _input6, _placeholder6);
        output1 = DAGUtil.replaceInputs(output1, inputMapping);
        output2 = DAGUtil.replaceInputs(output2, inputMapping);
        output3 = DAGUtil.replaceInputs(output3, inputMapping);
        output4 = DAGUtil.replaceInputs(output4, inputMapping);
        output5 = DAGUtil.replaceInputs(output5, inputMapping);
        output6 = DAGUtil.replaceInputs(output6, inputMapping);
        output7 = DAGUtil.replaceInputs(output7, inputMapping);
        output8 = DAGUtil.replaceInputs(output8, inputMapping);
        output9 = DAGUtil.replaceInputs(output9, inputMapping);
        output10 = DAGUtil.replaceInputs(output10, inputMapping);
      }

      List<Producer<?>> inputs = Arrays.asList(_input1, _input2, _input3, _input4, _input5, _input6);

      return ((DAG6x10) DAGUtil
          .createPreparableDAG(
              Arrays.asList(_placeholder1, _placeholder2, _placeholder3, _placeholder4, _placeholder5, _placeholder6),
              Arrays.asList(output1, output2, output3, output4, output5, output6, output7, output8, output9, output10))
          .internalAPI().withInputsUnsafe(inputs)).withReduction(_minimumReducerLevel);
    }
  }

  /**
    * A partial DAG with 7 placeholder.  Partial DAGs are <i>completed</i> to create a usable DAG by specifying
    * the outputs (<i>outputs</i>) of the DAG using the withOutputs(...) methods.
    *
   * @param <A> the type of the first input
   * @param <B> the type of the second input
   * @param <C> the type of the third input
   * @param <D> the type of the fourth input
   * @param <E> the type of the fifth input
   * @param <F> the type of the sixth input
   * @param <G> the type of the seventh input
    */
  public static class WithPlaceholders7<A, B, C, D, E, F, G> extends
      AbstractWithPlaceholders7<A, B, C, D, E, F, G, WithPlaceholders7<A, B, C, D, E, F, G>> {
    /**
     * Creates a new partial DAG that will be rooted at the provided placeholders.
     *
     * @param placeholder1 the first placeholder
     * @param placeholder2 the second placeholder
     * @param placeholder3 the third placeholder
     * @param placeholder4 the fourth placeholder
     * @param placeholder5 the fifth placeholder
     * @param placeholder6 the sixth placeholder
     * @param placeholder7 the seventh placeholder
     */
    WithPlaceholders7(Placeholder<? extends A> placeholder1, Placeholder<? extends B> placeholder2,
        Placeholder<? extends C> placeholder3, Placeholder<? extends D> placeholder4,
        Placeholder<? extends E> placeholder5, Placeholder<? extends F> placeholder6,
        Placeholder<? extends G> placeholder7) {
      super(placeholder1, placeholder2, placeholder3, placeholder4, placeholder5, placeholder6, placeholder7);
    }

    /**
     * Creates a new partial DAG that will be rooted at the provided placeholders, which will replace ("remap") the provided
     * "input" nodes that define a subgraph of the original graph (as defined by the ancestors of the outputs that will
     * be provided when the partial DAG is completed).  The input nodes, and any nodes that were exclusively the
     * ancestors of the input nodes, are truncated from the resulting graph.
     *
     * @param placeholder1 the first placeholder
     * @param placeholder2 the second placeholder
     * @param placeholder3 the third placeholder
     * @param placeholder4 the fourth placeholder
     * @param placeholder5 the fifth placeholder
     * @param placeholder6 the sixth placeholder
     * @param placeholder7 the seventh placeholder
     * @param input1 the first input
     * @param input2 the second input
     * @param input3 the third input
     * @param input4 the fourth input
     * @param input5 the fifth input
     * @param input6 the sixth input
     * @param input7 the seventh input
     */
    WithPlaceholders7(Placeholder<? extends A> placeholder1, Placeholder<? extends B> placeholder2,
        Placeholder<? extends C> placeholder3, Placeholder<? extends D> placeholder4,
        Placeholder<? extends E> placeholder5, Placeholder<? extends F> placeholder6,
        Placeholder<? extends G> placeholder7, Producer<? extends A> input1, Producer<? extends B> input2,
        Producer<? extends C> input3, Producer<? extends D> input4, Producer<? extends E> input5,
        Producer<? extends F> input6, Producer<? extends G> input7) {
      super(placeholder1, placeholder2, placeholder3, placeholder4, placeholder5, placeholder6, placeholder7, input1,
          input2, input3, input4, input5, input6, input7);
    }

    /**
     * Creates a completed DAG by supplying this partial DAG with its outputs (outputs).
     *
     * @param output1 the first output (output) of the DAG
     * @param <RA> the type of the first result
     * @return a completed DAG with 7 inputs (placeholders) and 1 output (outputs).
     */
    public <RA> DAG7x1<A, B, C, D, E, F, G, RA> withOutputs(Producer<? extends RA> output1) {
      Objects.requireNonNull(output1, "Output 1 may not be null");

      if (_shouldRemapInputs) {
        Map<Producer<?>, Producer<?>> inputMapping =
            DAGUtil.createInputMap(_input1, _placeholder1, _input2, _placeholder2, _input3, _placeholder3, _input4,
                _placeholder4, _input5, _placeholder5, _input6, _placeholder6, _input7, _placeholder7);
        output1 = DAGUtil.replaceInputs(output1, inputMapping);
      }

      List<Producer<?>> inputs = Arrays.asList(_input1, _input2, _input3, _input4, _input5, _input6, _input7);

      return ((DAG7x1) DAGUtil
          .createPreparableDAG(
              Arrays.asList(_placeholder1, _placeholder2, _placeholder3, _placeholder4, _placeholder5, _placeholder6,
                  _placeholder7), Arrays.asList(output1)).internalAPI().withInputsUnsafe(inputs))
          .withReduction(_minimumReducerLevel);
    }

    /**
     * Creates a completed DAG by supplying this partial DAG with its outputs (outputs).
     *
     * @param output1 the first output (output) of the DAG
     * @param <RA> the type of the first result
     * @return a completed DAG with 7 inputs (placeholders) and 1 output (outputs).
     */
    public <RA> DAG7x1<A, B, C, D, E, F, G, RA> withOutput(Producer<? extends RA> output1) {
      Objects.requireNonNull(output1, "Output 1 may not be null");

      if (_shouldRemapInputs) {
        Map<Producer<?>, Producer<?>> inputMapping =
            DAGUtil.createInputMap(_input1, _placeholder1, _input2, _placeholder2, _input3, _placeholder3, _input4,
                _placeholder4, _input5, _placeholder5, _input6, _placeholder6, _input7, _placeholder7);
        output1 = DAGUtil.replaceInputs(output1, inputMapping);
      }

      List<Producer<?>> inputs = Arrays.asList(_input1, _input2, _input3, _input4, _input5, _input6, _input7);

      return ((DAG7x1) DAGUtil
          .createPreparableDAG(
              Arrays.asList(_placeholder1, _placeholder2, _placeholder3, _placeholder4, _placeholder5, _placeholder6,
                  _placeholder7), Arrays.asList(output1)).internalAPI().withInputsUnsafe(inputs))
          .withReduction(_minimumReducerLevel);
    }

    /**
     * Creates a completed DAG by supplying this partial DAG with its outputs (outputs).
     *
     * @param output1 the first output (output) of the DAG
     * @param output2 the second output (output) of the DAG
     * @param <RA> the type of the first result
     * @param <RB> the type of the second result
     * @return a completed DAG with 7 inputs (placeholders) and 2 outputs (outputs).
     */
    public <RA, RB> DAG7x2<A, B, C, D, E, F, G, RA, RB> withOutputs(Producer<? extends RA> output1,
        Producer<? extends RB> output2) {
      Objects.requireNonNull(output1, "Output 1 may not be null");
      Objects.requireNonNull(output2, "Output 2 may not be null");

      if (_shouldRemapInputs) {
        Map<Producer<?>, Producer<?>> inputMapping =
            DAGUtil.createInputMap(_input1, _placeholder1, _input2, _placeholder2, _input3, _placeholder3, _input4,
                _placeholder4, _input5, _placeholder5, _input6, _placeholder6, _input7, _placeholder7);
        output1 = DAGUtil.replaceInputs(output1, inputMapping);
        output2 = DAGUtil.replaceInputs(output2, inputMapping);
      }

      List<Producer<?>> inputs = Arrays.asList(_input1, _input2, _input3, _input4, _input5, _input6, _input7);

      return ((DAG7x2) DAGUtil
          .createPreparableDAG(
              Arrays.asList(_placeholder1, _placeholder2, _placeholder3, _placeholder4, _placeholder5, _placeholder6,
                  _placeholder7), Arrays.asList(output1, output2)).internalAPI().withInputsUnsafe(inputs))
          .withReduction(_minimumReducerLevel);
    }

    /**
     * Creates a completed DAG by supplying this partial DAG with its outputs (outputs).
     *
     * @param output1 the first output (output) of the DAG
     * @param output2 the second output (output) of the DAG
     * @param output3 the third output (output) of the DAG
     * @param <RA> the type of the first result
     * @param <RB> the type of the second result
     * @param <RC> the type of the third result
     * @return a completed DAG with 7 inputs (placeholders) and 3 outputs (outputs).
     */
    public <RA, RB, RC> DAG7x3<A, B, C, D, E, F, G, RA, RB, RC> withOutputs(Producer<? extends RA> output1,
        Producer<? extends RB> output2, Producer<? extends RC> output3) {
      Objects.requireNonNull(output1, "Output 1 may not be null");
      Objects.requireNonNull(output2, "Output 2 may not be null");
      Objects.requireNonNull(output3, "Output 3 may not be null");

      if (_shouldRemapInputs) {
        Map<Producer<?>, Producer<?>> inputMapping =
            DAGUtil.createInputMap(_input1, _placeholder1, _input2, _placeholder2, _input3, _placeholder3, _input4,
                _placeholder4, _input5, _placeholder5, _input6, _placeholder6, _input7, _placeholder7);
        output1 = DAGUtil.replaceInputs(output1, inputMapping);
        output2 = DAGUtil.replaceInputs(output2, inputMapping);
        output3 = DAGUtil.replaceInputs(output3, inputMapping);
      }

      List<Producer<?>> inputs = Arrays.asList(_input1, _input2, _input3, _input4, _input5, _input6, _input7);

      return ((DAG7x3) DAGUtil
          .createPreparableDAG(
              Arrays.asList(_placeholder1, _placeholder2, _placeholder3, _placeholder4, _placeholder5, _placeholder6,
                  _placeholder7), Arrays.asList(output1, output2, output3)).internalAPI().withInputsUnsafe(inputs))
          .withReduction(_minimumReducerLevel);
    }

    /**
     * Creates a completed DAG by supplying this partial DAG with its outputs (outputs).
     *
     * @param output1 the first output (output) of the DAG
     * @param output2 the second output (output) of the DAG
     * @param output3 the third output (output) of the DAG
     * @param output4 the fourth output (output) of the DAG
     * @param <RA> the type of the first result
     * @param <RB> the type of the second result
     * @param <RC> the type of the third result
     * @param <RD> the type of the fourth result
     * @return a completed DAG with 7 inputs (placeholders) and 4 outputs (outputs).
     */
    public <RA, RB, RC, RD> DAG7x4<A, B, C, D, E, F, G, RA, RB, RC, RD> withOutputs(Producer<? extends RA> output1,
        Producer<? extends RB> output2, Producer<? extends RC> output3, Producer<? extends RD> output4) {
      Objects.requireNonNull(output1, "Output 1 may not be null");
      Objects.requireNonNull(output2, "Output 2 may not be null");
      Objects.requireNonNull(output3, "Output 3 may not be null");
      Objects.requireNonNull(output4, "Output 4 may not be null");

      if (_shouldRemapInputs) {
        Map<Producer<?>, Producer<?>> inputMapping =
            DAGUtil.createInputMap(_input1, _placeholder1, _input2, _placeholder2, _input3, _placeholder3, _input4,
                _placeholder4, _input5, _placeholder5, _input6, _placeholder6, _input7, _placeholder7);
        output1 = DAGUtil.replaceInputs(output1, inputMapping);
        output2 = DAGUtil.replaceInputs(output2, inputMapping);
        output3 = DAGUtil.replaceInputs(output3, inputMapping);
        output4 = DAGUtil.replaceInputs(output4, inputMapping);
      }

      List<Producer<?>> inputs = Arrays.asList(_input1, _input2, _input3, _input4, _input5, _input6, _input7);

      return ((DAG7x4) DAGUtil
          .createPreparableDAG(
              Arrays.asList(_placeholder1, _placeholder2, _placeholder3, _placeholder4, _placeholder5, _placeholder6,
                  _placeholder7), Arrays.asList(output1, output2, output3, output4)).internalAPI()
          .withInputsUnsafe(inputs)).withReduction(_minimumReducerLevel);
    }

    /**
     * Creates a completed DAG by supplying this partial DAG with its outputs (outputs).
     *
     * @param output1 the first output (output) of the DAG
     * @param output2 the second output (output) of the DAG
     * @param output3 the third output (output) of the DAG
     * @param output4 the fourth output (output) of the DAG
     * @param output5 the fifth output (output) of the DAG
     * @param <RA> the type of the first result
     * @param <RB> the type of the second result
     * @param <RC> the type of the third result
     * @param <RD> the type of the fourth result
     * @param <RE> the type of the fifth result
     * @return a completed DAG with 7 inputs (placeholders) and 5 outputs (outputs).
     */
    public <RA, RB, RC, RD, RE> DAG7x5<A, B, C, D, E, F, G, RA, RB, RC, RD, RE> withOutputs(
        Producer<? extends RA> output1, Producer<? extends RB> output2, Producer<? extends RC> output3,
        Producer<? extends RD> output4, Producer<? extends RE> output5) {
      Objects.requireNonNull(output1, "Output 1 may not be null");
      Objects.requireNonNull(output2, "Output 2 may not be null");
      Objects.requireNonNull(output3, "Output 3 may not be null");
      Objects.requireNonNull(output4, "Output 4 may not be null");
      Objects.requireNonNull(output5, "Output 5 may not be null");

      if (_shouldRemapInputs) {
        Map<Producer<?>, Producer<?>> inputMapping =
            DAGUtil.createInputMap(_input1, _placeholder1, _input2, _placeholder2, _input3, _placeholder3, _input4,
                _placeholder4, _input5, _placeholder5, _input6, _placeholder6, _input7, _placeholder7);
        output1 = DAGUtil.replaceInputs(output1, inputMapping);
        output2 = DAGUtil.replaceInputs(output2, inputMapping);
        output3 = DAGUtil.replaceInputs(output3, inputMapping);
        output4 = DAGUtil.replaceInputs(output4, inputMapping);
        output5 = DAGUtil.replaceInputs(output5, inputMapping);
      }

      List<Producer<?>> inputs = Arrays.asList(_input1, _input2, _input3, _input4, _input5, _input6, _input7);

      return ((DAG7x5) DAGUtil
          .createPreparableDAG(
              Arrays.asList(_placeholder1, _placeholder2, _placeholder3, _placeholder4, _placeholder5, _placeholder6,
                  _placeholder7), Arrays.asList(output1, output2, output3, output4, output5)).internalAPI()
          .withInputsUnsafe(inputs)).withReduction(_minimumReducerLevel);
    }

    /**
     * Creates a completed DAG by supplying this partial DAG with its outputs (outputs).
     *
     * @param output1 the first output (output) of the DAG
     * @param output2 the second output (output) of the DAG
     * @param output3 the third output (output) of the DAG
     * @param output4 the fourth output (output) of the DAG
     * @param output5 the fifth output (output) of the DAG
     * @param output6 the sixth output (output) of the DAG
     * @param <RA> the type of the first result
     * @param <RB> the type of the second result
     * @param <RC> the type of the third result
     * @param <RD> the type of the fourth result
     * @param <RE> the type of the fifth result
     * @param <RF> the type of the sixth result
     * @return a completed DAG with 7 inputs (placeholders) and 6 outputs (outputs).
     */
    public <RA, RB, RC, RD, RE, RF> DAG7x6<A, B, C, D, E, F, G, RA, RB, RC, RD, RE, RF> withOutputs(
        Producer<? extends RA> output1, Producer<? extends RB> output2, Producer<? extends RC> output3,
        Producer<? extends RD> output4, Producer<? extends RE> output5, Producer<? extends RF> output6) {
      Objects.requireNonNull(output1, "Output 1 may not be null");
      Objects.requireNonNull(output2, "Output 2 may not be null");
      Objects.requireNonNull(output3, "Output 3 may not be null");
      Objects.requireNonNull(output4, "Output 4 may not be null");
      Objects.requireNonNull(output5, "Output 5 may not be null");
      Objects.requireNonNull(output6, "Output 6 may not be null");

      if (_shouldRemapInputs) {
        Map<Producer<?>, Producer<?>> inputMapping =
            DAGUtil.createInputMap(_input1, _placeholder1, _input2, _placeholder2, _input3, _placeholder3, _input4,
                _placeholder4, _input5, _placeholder5, _input6, _placeholder6, _input7, _placeholder7);
        output1 = DAGUtil.replaceInputs(output1, inputMapping);
        output2 = DAGUtil.replaceInputs(output2, inputMapping);
        output3 = DAGUtil.replaceInputs(output3, inputMapping);
        output4 = DAGUtil.replaceInputs(output4, inputMapping);
        output5 = DAGUtil.replaceInputs(output5, inputMapping);
        output6 = DAGUtil.replaceInputs(output6, inputMapping);
      }

      List<Producer<?>> inputs = Arrays.asList(_input1, _input2, _input3, _input4, _input5, _input6, _input7);

      return ((DAG7x6) DAGUtil
          .createPreparableDAG(
              Arrays.asList(_placeholder1, _placeholder2, _placeholder3, _placeholder4, _placeholder5, _placeholder6,
                  _placeholder7), Arrays.asList(output1, output2, output3, output4, output5, output6)).internalAPI()
          .withInputsUnsafe(inputs)).withReduction(_minimumReducerLevel);
    }

    /**
     * Creates a completed DAG by supplying this partial DAG with its outputs (outputs).
     *
     * @param output1 the first output (output) of the DAG
     * @param output2 the second output (output) of the DAG
     * @param output3 the third output (output) of the DAG
     * @param output4 the fourth output (output) of the DAG
     * @param output5 the fifth output (output) of the DAG
     * @param output6 the sixth output (output) of the DAG
     * @param output7 the seventh output (output) of the DAG
     * @param <RA> the type of the first result
     * @param <RB> the type of the second result
     * @param <RC> the type of the third result
     * @param <RD> the type of the fourth result
     * @param <RE> the type of the fifth result
     * @param <RF> the type of the sixth result
     * @param <RG> the type of the seventh result
     * @return a completed DAG with 7 inputs (placeholders) and 7 outputs (outputs).
     */
    public <RA, RB, RC, RD, RE, RF, RG> DAG7x7<A, B, C, D, E, F, G, RA, RB, RC, RD, RE, RF, RG> withOutputs(
        Producer<? extends RA> output1, Producer<? extends RB> output2, Producer<? extends RC> output3,
        Producer<? extends RD> output4, Producer<? extends RE> output5, Producer<? extends RF> output6,
        Producer<? extends RG> output7) {
      Objects.requireNonNull(output1, "Output 1 may not be null");
      Objects.requireNonNull(output2, "Output 2 may not be null");
      Objects.requireNonNull(output3, "Output 3 may not be null");
      Objects.requireNonNull(output4, "Output 4 may not be null");
      Objects.requireNonNull(output5, "Output 5 may not be null");
      Objects.requireNonNull(output6, "Output 6 may not be null");
      Objects.requireNonNull(output7, "Output 7 may not be null");

      if (_shouldRemapInputs) {
        Map<Producer<?>, Producer<?>> inputMapping =
            DAGUtil.createInputMap(_input1, _placeholder1, _input2, _placeholder2, _input3, _placeholder3, _input4,
                _placeholder4, _input5, _placeholder5, _input6, _placeholder6, _input7, _placeholder7);
        output1 = DAGUtil.replaceInputs(output1, inputMapping);
        output2 = DAGUtil.replaceInputs(output2, inputMapping);
        output3 = DAGUtil.replaceInputs(output3, inputMapping);
        output4 = DAGUtil.replaceInputs(output4, inputMapping);
        output5 = DAGUtil.replaceInputs(output5, inputMapping);
        output6 = DAGUtil.replaceInputs(output6, inputMapping);
        output7 = DAGUtil.replaceInputs(output7, inputMapping);
      }

      List<Producer<?>> inputs = Arrays.asList(_input1, _input2, _input3, _input4, _input5, _input6, _input7);

      return ((DAG7x7) DAGUtil
          .createPreparableDAG(
              Arrays.asList(_placeholder1, _placeholder2, _placeholder3, _placeholder4, _placeholder5, _placeholder6,
                  _placeholder7), Arrays.asList(output1, output2, output3, output4, output5, output6, output7))
          .internalAPI().withInputsUnsafe(inputs)).withReduction(_minimumReducerLevel);
    }

    /**
     * Creates a completed DAG by supplying this partial DAG with its outputs (outputs).
     *
     * @param output1 the first output (output) of the DAG
     * @param output2 the second output (output) of the DAG
     * @param output3 the third output (output) of the DAG
     * @param output4 the fourth output (output) of the DAG
     * @param output5 the fifth output (output) of the DAG
     * @param output6 the sixth output (output) of the DAG
     * @param output7 the seventh output (output) of the DAG
     * @param output8 the eighth output (output) of the DAG
     * @param <RA> the type of the first result
     * @param <RB> the type of the second result
     * @param <RC> the type of the third result
     * @param <RD> the type of the fourth result
     * @param <RE> the type of the fifth result
     * @param <RF> the type of the sixth result
     * @param <RG> the type of the seventh result
     * @param <RH> the type of the eighth result
     * @return a completed DAG with 7 inputs (placeholders) and 8 outputs (outputs).
     */
    public <RA, RB, RC, RD, RE, RF, RG, RH> DAG7x8<A, B, C, D, E, F, G, RA, RB, RC, RD, RE, RF, RG, RH> withOutputs(
        Producer<? extends RA> output1, Producer<? extends RB> output2, Producer<? extends RC> output3,
        Producer<? extends RD> output4, Producer<? extends RE> output5, Producer<? extends RF> output6,
        Producer<? extends RG> output7, Producer<? extends RH> output8) {
      Objects.requireNonNull(output1, "Output 1 may not be null");
      Objects.requireNonNull(output2, "Output 2 may not be null");
      Objects.requireNonNull(output3, "Output 3 may not be null");
      Objects.requireNonNull(output4, "Output 4 may not be null");
      Objects.requireNonNull(output5, "Output 5 may not be null");
      Objects.requireNonNull(output6, "Output 6 may not be null");
      Objects.requireNonNull(output7, "Output 7 may not be null");
      Objects.requireNonNull(output8, "Output 8 may not be null");

      if (_shouldRemapInputs) {
        Map<Producer<?>, Producer<?>> inputMapping =
            DAGUtil.createInputMap(_input1, _placeholder1, _input2, _placeholder2, _input3, _placeholder3, _input4,
                _placeholder4, _input5, _placeholder5, _input6, _placeholder6, _input7, _placeholder7);
        output1 = DAGUtil.replaceInputs(output1, inputMapping);
        output2 = DAGUtil.replaceInputs(output2, inputMapping);
        output3 = DAGUtil.replaceInputs(output3, inputMapping);
        output4 = DAGUtil.replaceInputs(output4, inputMapping);
        output5 = DAGUtil.replaceInputs(output5, inputMapping);
        output6 = DAGUtil.replaceInputs(output6, inputMapping);
        output7 = DAGUtil.replaceInputs(output7, inputMapping);
        output8 = DAGUtil.replaceInputs(output8, inputMapping);
      }

      List<Producer<?>> inputs = Arrays.asList(_input1, _input2, _input3, _input4, _input5, _input6, _input7);

      return ((DAG7x8) DAGUtil
          .createPreparableDAG(
              Arrays.asList(_placeholder1, _placeholder2, _placeholder3, _placeholder4, _placeholder5, _placeholder6,
                  _placeholder7), Arrays.asList(output1, output2, output3, output4, output5, output6, output7, output8))
          .internalAPI().withInputsUnsafe(inputs)).withReduction(_minimumReducerLevel);
    }

    /**
     * Creates a completed DAG by supplying this partial DAG with its outputs (outputs).
     *
     * @param output1 the first output (output) of the DAG
     * @param output2 the second output (output) of the DAG
     * @param output3 the third output (output) of the DAG
     * @param output4 the fourth output (output) of the DAG
     * @param output5 the fifth output (output) of the DAG
     * @param output6 the sixth output (output) of the DAG
     * @param output7 the seventh output (output) of the DAG
     * @param output8 the eighth output (output) of the DAG
     * @param output9 the ninth output (output) of the DAG
     * @param <RA> the type of the first result
     * @param <RB> the type of the second result
     * @param <RC> the type of the third result
     * @param <RD> the type of the fourth result
     * @param <RE> the type of the fifth result
     * @param <RF> the type of the sixth result
     * @param <RG> the type of the seventh result
     * @param <RH> the type of the eighth result
     * @param <RI> the type of the ninth result
     * @return a completed DAG with 7 inputs (placeholders) and 9 outputs (outputs).
     */
    public <RA, RB, RC, RD, RE, RF, RG, RH, RI> DAG7x9<A, B, C, D, E, F, G, RA, RB, RC, RD, RE, RF, RG, RH, RI> withOutputs(
        Producer<? extends RA> output1, Producer<? extends RB> output2, Producer<? extends RC> output3,
        Producer<? extends RD> output4, Producer<? extends RE> output5, Producer<? extends RF> output6,
        Producer<? extends RG> output7, Producer<? extends RH> output8, Producer<? extends RI> output9) {
      Objects.requireNonNull(output1, "Output 1 may not be null");
      Objects.requireNonNull(output2, "Output 2 may not be null");
      Objects.requireNonNull(output3, "Output 3 may not be null");
      Objects.requireNonNull(output4, "Output 4 may not be null");
      Objects.requireNonNull(output5, "Output 5 may not be null");
      Objects.requireNonNull(output6, "Output 6 may not be null");
      Objects.requireNonNull(output7, "Output 7 may not be null");
      Objects.requireNonNull(output8, "Output 8 may not be null");
      Objects.requireNonNull(output9, "Output 9 may not be null");

      if (_shouldRemapInputs) {
        Map<Producer<?>, Producer<?>> inputMapping =
            DAGUtil.createInputMap(_input1, _placeholder1, _input2, _placeholder2, _input3, _placeholder3, _input4,
                _placeholder4, _input5, _placeholder5, _input6, _placeholder6, _input7, _placeholder7);
        output1 = DAGUtil.replaceInputs(output1, inputMapping);
        output2 = DAGUtil.replaceInputs(output2, inputMapping);
        output3 = DAGUtil.replaceInputs(output3, inputMapping);
        output4 = DAGUtil.replaceInputs(output4, inputMapping);
        output5 = DAGUtil.replaceInputs(output5, inputMapping);
        output6 = DAGUtil.replaceInputs(output6, inputMapping);
        output7 = DAGUtil.replaceInputs(output7, inputMapping);
        output8 = DAGUtil.replaceInputs(output8, inputMapping);
        output9 = DAGUtil.replaceInputs(output9, inputMapping);
      }

      List<Producer<?>> inputs = Arrays.asList(_input1, _input2, _input3, _input4, _input5, _input6, _input7);

      return ((DAG7x9) DAGUtil
          .createPreparableDAG(
              Arrays.asList(_placeholder1, _placeholder2, _placeholder3, _placeholder4, _placeholder5, _placeholder6,
                  _placeholder7),
              Arrays.asList(output1, output2, output3, output4, output5, output6, output7, output8, output9))
          .internalAPI().withInputsUnsafe(inputs)).withReduction(_minimumReducerLevel);
    }

    /**
     * Creates a completed DAG by supplying this partial DAG with its outputs (outputs).
     *
     * @param output1 the first output (output) of the DAG
     * @param output2 the second output (output) of the DAG
     * @param output3 the third output (output) of the DAG
     * @param output4 the fourth output (output) of the DAG
     * @param output5 the fifth output (output) of the DAG
     * @param output6 the sixth output (output) of the DAG
     * @param output7 the seventh output (output) of the DAG
     * @param output8 the eighth output (output) of the DAG
     * @param output9 the ninth output (output) of the DAG
     * @param output10 the tenth output (output) of the DAG
     * @param <RA> the type of the first result
     * @param <RB> the type of the second result
     * @param <RC> the type of the third result
     * @param <RD> the type of the fourth result
     * @param <RE> the type of the fifth result
     * @param <RF> the type of the sixth result
     * @param <RG> the type of the seventh result
     * @param <RH> the type of the eighth result
     * @param <RI> the type of the ninth result
     * @param <RJ> the type of the tenth result
     * @return a completed DAG with 7 inputs (placeholders) and 10 outputs (outputs).
     */
    public <RA, RB, RC, RD, RE, RF, RG, RH, RI, RJ> DAG7x10<A, B, C, D, E, F, G, RA, RB, RC, RD, RE, RF, RG, RH, RI, RJ> withOutputs(
        Producer<? extends RA> output1, Producer<? extends RB> output2, Producer<? extends RC> output3,
        Producer<? extends RD> output4, Producer<? extends RE> output5, Producer<? extends RF> output6,
        Producer<? extends RG> output7, Producer<? extends RH> output8, Producer<? extends RI> output9,
        Producer<? extends RJ> output10) {
      Objects.requireNonNull(output1, "Output 1 may not be null");
      Objects.requireNonNull(output2, "Output 2 may not be null");
      Objects.requireNonNull(output3, "Output 3 may not be null");
      Objects.requireNonNull(output4, "Output 4 may not be null");
      Objects.requireNonNull(output5, "Output 5 may not be null");
      Objects.requireNonNull(output6, "Output 6 may not be null");
      Objects.requireNonNull(output7, "Output 7 may not be null");
      Objects.requireNonNull(output8, "Output 8 may not be null");
      Objects.requireNonNull(output9, "Output 9 may not be null");
      Objects.requireNonNull(output10, "Output 10 may not be null");

      if (_shouldRemapInputs) {
        Map<Producer<?>, Producer<?>> inputMapping =
            DAGUtil.createInputMap(_input1, _placeholder1, _input2, _placeholder2, _input3, _placeholder3, _input4,
                _placeholder4, _input5, _placeholder5, _input6, _placeholder6, _input7, _placeholder7);
        output1 = DAGUtil.replaceInputs(output1, inputMapping);
        output2 = DAGUtil.replaceInputs(output2, inputMapping);
        output3 = DAGUtil.replaceInputs(output3, inputMapping);
        output4 = DAGUtil.replaceInputs(output4, inputMapping);
        output5 = DAGUtil.replaceInputs(output5, inputMapping);
        output6 = DAGUtil.replaceInputs(output6, inputMapping);
        output7 = DAGUtil.replaceInputs(output7, inputMapping);
        output8 = DAGUtil.replaceInputs(output8, inputMapping);
        output9 = DAGUtil.replaceInputs(output9, inputMapping);
        output10 = DAGUtil.replaceInputs(output10, inputMapping);
      }

      List<Producer<?>> inputs = Arrays.asList(_input1, _input2, _input3, _input4, _input5, _input6, _input7);

      return ((DAG7x10) DAGUtil
          .createPreparableDAG(
              Arrays.asList(_placeholder1, _placeholder2, _placeholder3, _placeholder4, _placeholder5, _placeholder6,
                  _placeholder7),
              Arrays.asList(output1, output2, output3, output4, output5, output6, output7, output8, output9, output10))
          .internalAPI().withInputsUnsafe(inputs)).withReduction(_minimumReducerLevel);
    }
  }

  /**
    * A partial DAG with 8 placeholder.  Partial DAGs are <i>completed</i> to create a usable DAG by specifying
    * the outputs (<i>outputs</i>) of the DAG using the withOutputs(...) methods.
    *
   * @param <A> the type of the first input
   * @param <B> the type of the second input
   * @param <C> the type of the third input
   * @param <D> the type of the fourth input
   * @param <E> the type of the fifth input
   * @param <F> the type of the sixth input
   * @param <G> the type of the seventh input
   * @param <H> the type of the eighth input
    */
  public static class WithPlaceholders8<A, B, C, D, E, F, G, H> extends
      AbstractWithPlaceholders8<A, B, C, D, E, F, G, H, WithPlaceholders8<A, B, C, D, E, F, G, H>> {
    /**
     * Creates a new partial DAG that will be rooted at the provided placeholders.
     *
     * @param placeholder1 the first placeholder
     * @param placeholder2 the second placeholder
     * @param placeholder3 the third placeholder
     * @param placeholder4 the fourth placeholder
     * @param placeholder5 the fifth placeholder
     * @param placeholder6 the sixth placeholder
     * @param placeholder7 the seventh placeholder
     * @param placeholder8 the eighth placeholder
     */
    WithPlaceholders8(Placeholder<? extends A> placeholder1, Placeholder<? extends B> placeholder2,
        Placeholder<? extends C> placeholder3, Placeholder<? extends D> placeholder4,
        Placeholder<? extends E> placeholder5, Placeholder<? extends F> placeholder6,
        Placeholder<? extends G> placeholder7, Placeholder<? extends H> placeholder8) {
      super(placeholder1, placeholder2, placeholder3, placeholder4, placeholder5, placeholder6, placeholder7,
          placeholder8);
    }

    /**
     * Creates a new partial DAG that will be rooted at the provided placeholders, which will replace ("remap") the provided
     * "input" nodes that define a subgraph of the original graph (as defined by the ancestors of the outputs that will
     * be provided when the partial DAG is completed).  The input nodes, and any nodes that were exclusively the
     * ancestors of the input nodes, are truncated from the resulting graph.
     *
     * @param placeholder1 the first placeholder
     * @param placeholder2 the second placeholder
     * @param placeholder3 the third placeholder
     * @param placeholder4 the fourth placeholder
     * @param placeholder5 the fifth placeholder
     * @param placeholder6 the sixth placeholder
     * @param placeholder7 the seventh placeholder
     * @param placeholder8 the eighth placeholder
     * @param input1 the first input
     * @param input2 the second input
     * @param input3 the third input
     * @param input4 the fourth input
     * @param input5 the fifth input
     * @param input6 the sixth input
     * @param input7 the seventh input
     * @param input8 the eighth input
     */
    WithPlaceholders8(Placeholder<? extends A> placeholder1, Placeholder<? extends B> placeholder2,
        Placeholder<? extends C> placeholder3, Placeholder<? extends D> placeholder4,
        Placeholder<? extends E> placeholder5, Placeholder<? extends F> placeholder6,
        Placeholder<? extends G> placeholder7, Placeholder<? extends H> placeholder8, Producer<? extends A> input1,
        Producer<? extends B> input2, Producer<? extends C> input3, Producer<? extends D> input4,
        Producer<? extends E> input5, Producer<? extends F> input6, Producer<? extends G> input7,
        Producer<? extends H> input8) {
      super(placeholder1, placeholder2, placeholder3, placeholder4, placeholder5, placeholder6, placeholder7,
          placeholder8, input1, input2, input3, input4, input5, input6, input7, input8);
    }

    /**
     * Creates a completed DAG by supplying this partial DAG with its outputs (outputs).
     *
     * @param output1 the first output (output) of the DAG
     * @param <RA> the type of the first result
     * @return a completed DAG with 8 inputs (placeholders) and 1 output (outputs).
     */
    public <RA> DAG8x1<A, B, C, D, E, F, G, H, RA> withOutputs(Producer<? extends RA> output1) {
      Objects.requireNonNull(output1, "Output 1 may not be null");

      if (_shouldRemapInputs) {
        Map<Producer<?>, Producer<?>> inputMapping =
            DAGUtil.createInputMap(_input1, _placeholder1, _input2, _placeholder2, _input3, _placeholder3, _input4,
                _placeholder4, _input5, _placeholder5, _input6, _placeholder6, _input7, _placeholder7, _input8,
                _placeholder8);
        output1 = DAGUtil.replaceInputs(output1, inputMapping);
      }

      List<Producer<?>> inputs = Arrays.asList(_input1, _input2, _input3, _input4, _input5, _input6, _input7, _input8);

      return ((DAG8x1) DAGUtil
          .createPreparableDAG(
              Arrays.asList(_placeholder1, _placeholder2, _placeholder3, _placeholder4, _placeholder5, _placeholder6,
                  _placeholder7, _placeholder8), Arrays.asList(output1)).internalAPI().withInputsUnsafe(inputs))
          .withReduction(_minimumReducerLevel);
    }

    /**
     * Creates a completed DAG by supplying this partial DAG with its outputs (outputs).
     *
     * @param output1 the first output (output) of the DAG
     * @param <RA> the type of the first result
     * @return a completed DAG with 8 inputs (placeholders) and 1 output (outputs).
     */
    public <RA> DAG8x1<A, B, C, D, E, F, G, H, RA> withOutput(Producer<? extends RA> output1) {
      Objects.requireNonNull(output1, "Output 1 may not be null");

      if (_shouldRemapInputs) {
        Map<Producer<?>, Producer<?>> inputMapping =
            DAGUtil.createInputMap(_input1, _placeholder1, _input2, _placeholder2, _input3, _placeholder3, _input4,
                _placeholder4, _input5, _placeholder5, _input6, _placeholder6, _input7, _placeholder7, _input8,
                _placeholder8);
        output1 = DAGUtil.replaceInputs(output1, inputMapping);
      }

      List<Producer<?>> inputs = Arrays.asList(_input1, _input2, _input3, _input4, _input5, _input6, _input7, _input8);

      return ((DAG8x1) DAGUtil
          .createPreparableDAG(
              Arrays.asList(_placeholder1, _placeholder2, _placeholder3, _placeholder4, _placeholder5, _placeholder6,
                  _placeholder7, _placeholder8), Arrays.asList(output1)).internalAPI().withInputsUnsafe(inputs))
          .withReduction(_minimumReducerLevel);
    }

    /**
     * Creates a completed DAG by supplying this partial DAG with its outputs (outputs).
     *
     * @param output1 the first output (output) of the DAG
     * @param output2 the second output (output) of the DAG
     * @param <RA> the type of the first result
     * @param <RB> the type of the second result
     * @return a completed DAG with 8 inputs (placeholders) and 2 outputs (outputs).
     */
    public <RA, RB> DAG8x2<A, B, C, D, E, F, G, H, RA, RB> withOutputs(Producer<? extends RA> output1,
        Producer<? extends RB> output2) {
      Objects.requireNonNull(output1, "Output 1 may not be null");
      Objects.requireNonNull(output2, "Output 2 may not be null");

      if (_shouldRemapInputs) {
        Map<Producer<?>, Producer<?>> inputMapping =
            DAGUtil.createInputMap(_input1, _placeholder1, _input2, _placeholder2, _input3, _placeholder3, _input4,
                _placeholder4, _input5, _placeholder5, _input6, _placeholder6, _input7, _placeholder7, _input8,
                _placeholder8);
        output1 = DAGUtil.replaceInputs(output1, inputMapping);
        output2 = DAGUtil.replaceInputs(output2, inputMapping);
      }

      List<Producer<?>> inputs = Arrays.asList(_input1, _input2, _input3, _input4, _input5, _input6, _input7, _input8);

      return ((DAG8x2) DAGUtil
          .createPreparableDAG(
              Arrays.asList(_placeholder1, _placeholder2, _placeholder3, _placeholder4, _placeholder5, _placeholder6,
                  _placeholder7, _placeholder8), Arrays.asList(output1, output2)).internalAPI()
          .withInputsUnsafe(inputs)).withReduction(_minimumReducerLevel);
    }

    /**
     * Creates a completed DAG by supplying this partial DAG with its outputs (outputs).
     *
     * @param output1 the first output (output) of the DAG
     * @param output2 the second output (output) of the DAG
     * @param output3 the third output (output) of the DAG
     * @param <RA> the type of the first result
     * @param <RB> the type of the second result
     * @param <RC> the type of the third result
     * @return a completed DAG with 8 inputs (placeholders) and 3 outputs (outputs).
     */
    public <RA, RB, RC> DAG8x3<A, B, C, D, E, F, G, H, RA, RB, RC> withOutputs(Producer<? extends RA> output1,
        Producer<? extends RB> output2, Producer<? extends RC> output3) {
      Objects.requireNonNull(output1, "Output 1 may not be null");
      Objects.requireNonNull(output2, "Output 2 may not be null");
      Objects.requireNonNull(output3, "Output 3 may not be null");

      if (_shouldRemapInputs) {
        Map<Producer<?>, Producer<?>> inputMapping =
            DAGUtil.createInputMap(_input1, _placeholder1, _input2, _placeholder2, _input3, _placeholder3, _input4,
                _placeholder4, _input5, _placeholder5, _input6, _placeholder6, _input7, _placeholder7, _input8,
                _placeholder8);
        output1 = DAGUtil.replaceInputs(output1, inputMapping);
        output2 = DAGUtil.replaceInputs(output2, inputMapping);
        output3 = DAGUtil.replaceInputs(output3, inputMapping);
      }

      List<Producer<?>> inputs = Arrays.asList(_input1, _input2, _input3, _input4, _input5, _input6, _input7, _input8);

      return ((DAG8x3) DAGUtil
          .createPreparableDAG(
              Arrays.asList(_placeholder1, _placeholder2, _placeholder3, _placeholder4, _placeholder5, _placeholder6,
                  _placeholder7, _placeholder8), Arrays.asList(output1, output2, output3)).internalAPI()
          .withInputsUnsafe(inputs)).withReduction(_minimumReducerLevel);
    }

    /**
     * Creates a completed DAG by supplying this partial DAG with its outputs (outputs).
     *
     * @param output1 the first output (output) of the DAG
     * @param output2 the second output (output) of the DAG
     * @param output3 the third output (output) of the DAG
     * @param output4 the fourth output (output) of the DAG
     * @param <RA> the type of the first result
     * @param <RB> the type of the second result
     * @param <RC> the type of the third result
     * @param <RD> the type of the fourth result
     * @return a completed DAG with 8 inputs (placeholders) and 4 outputs (outputs).
     */
    public <RA, RB, RC, RD> DAG8x4<A, B, C, D, E, F, G, H, RA, RB, RC, RD> withOutputs(Producer<? extends RA> output1,
        Producer<? extends RB> output2, Producer<? extends RC> output3, Producer<? extends RD> output4) {
      Objects.requireNonNull(output1, "Output 1 may not be null");
      Objects.requireNonNull(output2, "Output 2 may not be null");
      Objects.requireNonNull(output3, "Output 3 may not be null");
      Objects.requireNonNull(output4, "Output 4 may not be null");

      if (_shouldRemapInputs) {
        Map<Producer<?>, Producer<?>> inputMapping =
            DAGUtil.createInputMap(_input1, _placeholder1, _input2, _placeholder2, _input3, _placeholder3, _input4,
                _placeholder4, _input5, _placeholder5, _input6, _placeholder6, _input7, _placeholder7, _input8,
                _placeholder8);
        output1 = DAGUtil.replaceInputs(output1, inputMapping);
        output2 = DAGUtil.replaceInputs(output2, inputMapping);
        output3 = DAGUtil.replaceInputs(output3, inputMapping);
        output4 = DAGUtil.replaceInputs(output4, inputMapping);
      }

      List<Producer<?>> inputs = Arrays.asList(_input1, _input2, _input3, _input4, _input5, _input6, _input7, _input8);

      return ((DAG8x4) DAGUtil
          .createPreparableDAG(
              Arrays.asList(_placeholder1, _placeholder2, _placeholder3, _placeholder4, _placeholder5, _placeholder6,
                  _placeholder7, _placeholder8), Arrays.asList(output1, output2, output3, output4)).internalAPI()
          .withInputsUnsafe(inputs)).withReduction(_minimumReducerLevel);
    }

    /**
     * Creates a completed DAG by supplying this partial DAG with its outputs (outputs).
     *
     * @param output1 the first output (output) of the DAG
     * @param output2 the second output (output) of the DAG
     * @param output3 the third output (output) of the DAG
     * @param output4 the fourth output (output) of the DAG
     * @param output5 the fifth output (output) of the DAG
     * @param <RA> the type of the first result
     * @param <RB> the type of the second result
     * @param <RC> the type of the third result
     * @param <RD> the type of the fourth result
     * @param <RE> the type of the fifth result
     * @return a completed DAG with 8 inputs (placeholders) and 5 outputs (outputs).
     */
    public <RA, RB, RC, RD, RE> DAG8x5<A, B, C, D, E, F, G, H, RA, RB, RC, RD, RE> withOutputs(
        Producer<? extends RA> output1, Producer<? extends RB> output2, Producer<? extends RC> output3,
        Producer<? extends RD> output4, Producer<? extends RE> output5) {
      Objects.requireNonNull(output1, "Output 1 may not be null");
      Objects.requireNonNull(output2, "Output 2 may not be null");
      Objects.requireNonNull(output3, "Output 3 may not be null");
      Objects.requireNonNull(output4, "Output 4 may not be null");
      Objects.requireNonNull(output5, "Output 5 may not be null");

      if (_shouldRemapInputs) {
        Map<Producer<?>, Producer<?>> inputMapping =
            DAGUtil.createInputMap(_input1, _placeholder1, _input2, _placeholder2, _input3, _placeholder3, _input4,
                _placeholder4, _input5, _placeholder5, _input6, _placeholder6, _input7, _placeholder7, _input8,
                _placeholder8);
        output1 = DAGUtil.replaceInputs(output1, inputMapping);
        output2 = DAGUtil.replaceInputs(output2, inputMapping);
        output3 = DAGUtil.replaceInputs(output3, inputMapping);
        output4 = DAGUtil.replaceInputs(output4, inputMapping);
        output5 = DAGUtil.replaceInputs(output5, inputMapping);
      }

      List<Producer<?>> inputs = Arrays.asList(_input1, _input2, _input3, _input4, _input5, _input6, _input7, _input8);

      return ((DAG8x5) DAGUtil
          .createPreparableDAG(
              Arrays.asList(_placeholder1, _placeholder2, _placeholder3, _placeholder4, _placeholder5, _placeholder6,
                  _placeholder7, _placeholder8), Arrays.asList(output1, output2, output3, output4, output5))
          .internalAPI().withInputsUnsafe(inputs)).withReduction(_minimumReducerLevel);
    }

    /**
     * Creates a completed DAG by supplying this partial DAG with its outputs (outputs).
     *
     * @param output1 the first output (output) of the DAG
     * @param output2 the second output (output) of the DAG
     * @param output3 the third output (output) of the DAG
     * @param output4 the fourth output (output) of the DAG
     * @param output5 the fifth output (output) of the DAG
     * @param output6 the sixth output (output) of the DAG
     * @param <RA> the type of the first result
     * @param <RB> the type of the second result
     * @param <RC> the type of the third result
     * @param <RD> the type of the fourth result
     * @param <RE> the type of the fifth result
     * @param <RF> the type of the sixth result
     * @return a completed DAG with 8 inputs (placeholders) and 6 outputs (outputs).
     */
    public <RA, RB, RC, RD, RE, RF> DAG8x6<A, B, C, D, E, F, G, H, RA, RB, RC, RD, RE, RF> withOutputs(
        Producer<? extends RA> output1, Producer<? extends RB> output2, Producer<? extends RC> output3,
        Producer<? extends RD> output4, Producer<? extends RE> output5, Producer<? extends RF> output6) {
      Objects.requireNonNull(output1, "Output 1 may not be null");
      Objects.requireNonNull(output2, "Output 2 may not be null");
      Objects.requireNonNull(output3, "Output 3 may not be null");
      Objects.requireNonNull(output4, "Output 4 may not be null");
      Objects.requireNonNull(output5, "Output 5 may not be null");
      Objects.requireNonNull(output6, "Output 6 may not be null");

      if (_shouldRemapInputs) {
        Map<Producer<?>, Producer<?>> inputMapping =
            DAGUtil.createInputMap(_input1, _placeholder1, _input2, _placeholder2, _input3, _placeholder3, _input4,
                _placeholder4, _input5, _placeholder5, _input6, _placeholder6, _input7, _placeholder7, _input8,
                _placeholder8);
        output1 = DAGUtil.replaceInputs(output1, inputMapping);
        output2 = DAGUtil.replaceInputs(output2, inputMapping);
        output3 = DAGUtil.replaceInputs(output3, inputMapping);
        output4 = DAGUtil.replaceInputs(output4, inputMapping);
        output5 = DAGUtil.replaceInputs(output5, inputMapping);
        output6 = DAGUtil.replaceInputs(output6, inputMapping);
      }

      List<Producer<?>> inputs = Arrays.asList(_input1, _input2, _input3, _input4, _input5, _input6, _input7, _input8);

      return ((DAG8x6) DAGUtil
          .createPreparableDAG(
              Arrays.asList(_placeholder1, _placeholder2, _placeholder3, _placeholder4, _placeholder5, _placeholder6,
                  _placeholder7, _placeholder8), Arrays.asList(output1, output2, output3, output4, output5, output6))
          .internalAPI().withInputsUnsafe(inputs)).withReduction(_minimumReducerLevel);
    }

    /**
     * Creates a completed DAG by supplying this partial DAG with its outputs (outputs).
     *
     * @param output1 the first output (output) of the DAG
     * @param output2 the second output (output) of the DAG
     * @param output3 the third output (output) of the DAG
     * @param output4 the fourth output (output) of the DAG
     * @param output5 the fifth output (output) of the DAG
     * @param output6 the sixth output (output) of the DAG
     * @param output7 the seventh output (output) of the DAG
     * @param <RA> the type of the first result
     * @param <RB> the type of the second result
     * @param <RC> the type of the third result
     * @param <RD> the type of the fourth result
     * @param <RE> the type of the fifth result
     * @param <RF> the type of the sixth result
     * @param <RG> the type of the seventh result
     * @return a completed DAG with 8 inputs (placeholders) and 7 outputs (outputs).
     */
    public <RA, RB, RC, RD, RE, RF, RG> DAG8x7<A, B, C, D, E, F, G, H, RA, RB, RC, RD, RE, RF, RG> withOutputs(
        Producer<? extends RA> output1, Producer<? extends RB> output2, Producer<? extends RC> output3,
        Producer<? extends RD> output4, Producer<? extends RE> output5, Producer<? extends RF> output6,
        Producer<? extends RG> output7) {
      Objects.requireNonNull(output1, "Output 1 may not be null");
      Objects.requireNonNull(output2, "Output 2 may not be null");
      Objects.requireNonNull(output3, "Output 3 may not be null");
      Objects.requireNonNull(output4, "Output 4 may not be null");
      Objects.requireNonNull(output5, "Output 5 may not be null");
      Objects.requireNonNull(output6, "Output 6 may not be null");
      Objects.requireNonNull(output7, "Output 7 may not be null");

      if (_shouldRemapInputs) {
        Map<Producer<?>, Producer<?>> inputMapping =
            DAGUtil.createInputMap(_input1, _placeholder1, _input2, _placeholder2, _input3, _placeholder3, _input4,
                _placeholder4, _input5, _placeholder5, _input6, _placeholder6, _input7, _placeholder7, _input8,
                _placeholder8);
        output1 = DAGUtil.replaceInputs(output1, inputMapping);
        output2 = DAGUtil.replaceInputs(output2, inputMapping);
        output3 = DAGUtil.replaceInputs(output3, inputMapping);
        output4 = DAGUtil.replaceInputs(output4, inputMapping);
        output5 = DAGUtil.replaceInputs(output5, inputMapping);
        output6 = DAGUtil.replaceInputs(output6, inputMapping);
        output7 = DAGUtil.replaceInputs(output7, inputMapping);
      }

      List<Producer<?>> inputs = Arrays.asList(_input1, _input2, _input3, _input4, _input5, _input6, _input7, _input8);

      return ((DAG8x7) DAGUtil
          .createPreparableDAG(
              Arrays.asList(_placeholder1, _placeholder2, _placeholder3, _placeholder4, _placeholder5, _placeholder6,
                  _placeholder7, _placeholder8),
              Arrays.asList(output1, output2, output3, output4, output5, output6, output7)).internalAPI()
          .withInputsUnsafe(inputs)).withReduction(_minimumReducerLevel);
    }

    /**
     * Creates a completed DAG by supplying this partial DAG with its outputs (outputs).
     *
     * @param output1 the first output (output) of the DAG
     * @param output2 the second output (output) of the DAG
     * @param output3 the third output (output) of the DAG
     * @param output4 the fourth output (output) of the DAG
     * @param output5 the fifth output (output) of the DAG
     * @param output6 the sixth output (output) of the DAG
     * @param output7 the seventh output (output) of the DAG
     * @param output8 the eighth output (output) of the DAG
     * @param <RA> the type of the first result
     * @param <RB> the type of the second result
     * @param <RC> the type of the third result
     * @param <RD> the type of the fourth result
     * @param <RE> the type of the fifth result
     * @param <RF> the type of the sixth result
     * @param <RG> the type of the seventh result
     * @param <RH> the type of the eighth result
     * @return a completed DAG with 8 inputs (placeholders) and 8 outputs (outputs).
     */
    public <RA, RB, RC, RD, RE, RF, RG, RH> DAG8x8<A, B, C, D, E, F, G, H, RA, RB, RC, RD, RE, RF, RG, RH> withOutputs(
        Producer<? extends RA> output1, Producer<? extends RB> output2, Producer<? extends RC> output3,
        Producer<? extends RD> output4, Producer<? extends RE> output5, Producer<? extends RF> output6,
        Producer<? extends RG> output7, Producer<? extends RH> output8) {
      Objects.requireNonNull(output1, "Output 1 may not be null");
      Objects.requireNonNull(output2, "Output 2 may not be null");
      Objects.requireNonNull(output3, "Output 3 may not be null");
      Objects.requireNonNull(output4, "Output 4 may not be null");
      Objects.requireNonNull(output5, "Output 5 may not be null");
      Objects.requireNonNull(output6, "Output 6 may not be null");
      Objects.requireNonNull(output7, "Output 7 may not be null");
      Objects.requireNonNull(output8, "Output 8 may not be null");

      if (_shouldRemapInputs) {
        Map<Producer<?>, Producer<?>> inputMapping =
            DAGUtil.createInputMap(_input1, _placeholder1, _input2, _placeholder2, _input3, _placeholder3, _input4,
                _placeholder4, _input5, _placeholder5, _input6, _placeholder6, _input7, _placeholder7, _input8,
                _placeholder8);
        output1 = DAGUtil.replaceInputs(output1, inputMapping);
        output2 = DAGUtil.replaceInputs(output2, inputMapping);
        output3 = DAGUtil.replaceInputs(output3, inputMapping);
        output4 = DAGUtil.replaceInputs(output4, inputMapping);
        output5 = DAGUtil.replaceInputs(output5, inputMapping);
        output6 = DAGUtil.replaceInputs(output6, inputMapping);
        output7 = DAGUtil.replaceInputs(output7, inputMapping);
        output8 = DAGUtil.replaceInputs(output8, inputMapping);
      }

      List<Producer<?>> inputs = Arrays.asList(_input1, _input2, _input3, _input4, _input5, _input6, _input7, _input8);

      return ((DAG8x8) DAGUtil
          .createPreparableDAG(
              Arrays.asList(_placeholder1, _placeholder2, _placeholder3, _placeholder4, _placeholder5, _placeholder6,
                  _placeholder7, _placeholder8),
              Arrays.asList(output1, output2, output3, output4, output5, output6, output7, output8)).internalAPI()
          .withInputsUnsafe(inputs)).withReduction(_minimumReducerLevel);
    }

    /**
     * Creates a completed DAG by supplying this partial DAG with its outputs (outputs).
     *
     * @param output1 the first output (output) of the DAG
     * @param output2 the second output (output) of the DAG
     * @param output3 the third output (output) of the DAG
     * @param output4 the fourth output (output) of the DAG
     * @param output5 the fifth output (output) of the DAG
     * @param output6 the sixth output (output) of the DAG
     * @param output7 the seventh output (output) of the DAG
     * @param output8 the eighth output (output) of the DAG
     * @param output9 the ninth output (output) of the DAG
     * @param <RA> the type of the first result
     * @param <RB> the type of the second result
     * @param <RC> the type of the third result
     * @param <RD> the type of the fourth result
     * @param <RE> the type of the fifth result
     * @param <RF> the type of the sixth result
     * @param <RG> the type of the seventh result
     * @param <RH> the type of the eighth result
     * @param <RI> the type of the ninth result
     * @return a completed DAG with 8 inputs (placeholders) and 9 outputs (outputs).
     */
    public <RA, RB, RC, RD, RE, RF, RG, RH, RI> DAG8x9<A, B, C, D, E, F, G, H, RA, RB, RC, RD, RE, RF, RG, RH, RI> withOutputs(
        Producer<? extends RA> output1, Producer<? extends RB> output2, Producer<? extends RC> output3,
        Producer<? extends RD> output4, Producer<? extends RE> output5, Producer<? extends RF> output6,
        Producer<? extends RG> output7, Producer<? extends RH> output8, Producer<? extends RI> output9) {
      Objects.requireNonNull(output1, "Output 1 may not be null");
      Objects.requireNonNull(output2, "Output 2 may not be null");
      Objects.requireNonNull(output3, "Output 3 may not be null");
      Objects.requireNonNull(output4, "Output 4 may not be null");
      Objects.requireNonNull(output5, "Output 5 may not be null");
      Objects.requireNonNull(output6, "Output 6 may not be null");
      Objects.requireNonNull(output7, "Output 7 may not be null");
      Objects.requireNonNull(output8, "Output 8 may not be null");
      Objects.requireNonNull(output9, "Output 9 may not be null");

      if (_shouldRemapInputs) {
        Map<Producer<?>, Producer<?>> inputMapping =
            DAGUtil.createInputMap(_input1, _placeholder1, _input2, _placeholder2, _input3, _placeholder3, _input4,
                _placeholder4, _input5, _placeholder5, _input6, _placeholder6, _input7, _placeholder7, _input8,
                _placeholder8);
        output1 = DAGUtil.replaceInputs(output1, inputMapping);
        output2 = DAGUtil.replaceInputs(output2, inputMapping);
        output3 = DAGUtil.replaceInputs(output3, inputMapping);
        output4 = DAGUtil.replaceInputs(output4, inputMapping);
        output5 = DAGUtil.replaceInputs(output5, inputMapping);
        output6 = DAGUtil.replaceInputs(output6, inputMapping);
        output7 = DAGUtil.replaceInputs(output7, inputMapping);
        output8 = DAGUtil.replaceInputs(output8, inputMapping);
        output9 = DAGUtil.replaceInputs(output9, inputMapping);
      }

      List<Producer<?>> inputs = Arrays.asList(_input1, _input2, _input3, _input4, _input5, _input6, _input7, _input8);

      return ((DAG8x9) DAGUtil
          .createPreparableDAG(
              Arrays.asList(_placeholder1, _placeholder2, _placeholder3, _placeholder4, _placeholder5, _placeholder6,
                  _placeholder7, _placeholder8),
              Arrays.asList(output1, output2, output3, output4, output5, output6, output7, output8, output9))
          .internalAPI().withInputsUnsafe(inputs)).withReduction(_minimumReducerLevel);
    }

    /**
     * Creates a completed DAG by supplying this partial DAG with its outputs (outputs).
     *
     * @param output1 the first output (output) of the DAG
     * @param output2 the second output (output) of the DAG
     * @param output3 the third output (output) of the DAG
     * @param output4 the fourth output (output) of the DAG
     * @param output5 the fifth output (output) of the DAG
     * @param output6 the sixth output (output) of the DAG
     * @param output7 the seventh output (output) of the DAG
     * @param output8 the eighth output (output) of the DAG
     * @param output9 the ninth output (output) of the DAG
     * @param output10 the tenth output (output) of the DAG
     * @param <RA> the type of the first result
     * @param <RB> the type of the second result
     * @param <RC> the type of the third result
     * @param <RD> the type of the fourth result
     * @param <RE> the type of the fifth result
     * @param <RF> the type of the sixth result
     * @param <RG> the type of the seventh result
     * @param <RH> the type of the eighth result
     * @param <RI> the type of the ninth result
     * @param <RJ> the type of the tenth result
     * @return a completed DAG with 8 inputs (placeholders) and 10 outputs (outputs).
     */
    public <RA, RB, RC, RD, RE, RF, RG, RH, RI, RJ> DAG8x10<A, B, C, D, E, F, G, H, RA, RB, RC, RD, RE, RF, RG, RH, RI, RJ> withOutputs(
        Producer<? extends RA> output1, Producer<? extends RB> output2, Producer<? extends RC> output3,
        Producer<? extends RD> output4, Producer<? extends RE> output5, Producer<? extends RF> output6,
        Producer<? extends RG> output7, Producer<? extends RH> output8, Producer<? extends RI> output9,
        Producer<? extends RJ> output10) {
      Objects.requireNonNull(output1, "Output 1 may not be null");
      Objects.requireNonNull(output2, "Output 2 may not be null");
      Objects.requireNonNull(output3, "Output 3 may not be null");
      Objects.requireNonNull(output4, "Output 4 may not be null");
      Objects.requireNonNull(output5, "Output 5 may not be null");
      Objects.requireNonNull(output6, "Output 6 may not be null");
      Objects.requireNonNull(output7, "Output 7 may not be null");
      Objects.requireNonNull(output8, "Output 8 may not be null");
      Objects.requireNonNull(output9, "Output 9 may not be null");
      Objects.requireNonNull(output10, "Output 10 may not be null");

      if (_shouldRemapInputs) {
        Map<Producer<?>, Producer<?>> inputMapping =
            DAGUtil.createInputMap(_input1, _placeholder1, _input2, _placeholder2, _input3, _placeholder3, _input4,
                _placeholder4, _input5, _placeholder5, _input6, _placeholder6, _input7, _placeholder7, _input8,
                _placeholder8);
        output1 = DAGUtil.replaceInputs(output1, inputMapping);
        output2 = DAGUtil.replaceInputs(output2, inputMapping);
        output3 = DAGUtil.replaceInputs(output3, inputMapping);
        output4 = DAGUtil.replaceInputs(output4, inputMapping);
        output5 = DAGUtil.replaceInputs(output5, inputMapping);
        output6 = DAGUtil.replaceInputs(output6, inputMapping);
        output7 = DAGUtil.replaceInputs(output7, inputMapping);
        output8 = DAGUtil.replaceInputs(output8, inputMapping);
        output9 = DAGUtil.replaceInputs(output9, inputMapping);
        output10 = DAGUtil.replaceInputs(output10, inputMapping);
      }

      List<Producer<?>> inputs = Arrays.asList(_input1, _input2, _input3, _input4, _input5, _input6, _input7, _input8);

      return ((DAG8x10) DAGUtil
          .createPreparableDAG(
              Arrays.asList(_placeholder1, _placeholder2, _placeholder3, _placeholder4, _placeholder5, _placeholder6,
                  _placeholder7, _placeholder8),
              Arrays.asList(output1, output2, output3, output4, output5, output6, output7, output8, output9, output10))
          .internalAPI().withInputsUnsafe(inputs)).withReduction(_minimumReducerLevel);
    }
  }

  /**
    * A partial DAG with 9 placeholder.  Partial DAGs are <i>completed</i> to create a usable DAG by specifying
    * the outputs (<i>outputs</i>) of the DAG using the withOutputs(...) methods.
    *
   * @param <A> the type of the first input
   * @param <B> the type of the second input
   * @param <C> the type of the third input
   * @param <D> the type of the fourth input
   * @param <E> the type of the fifth input
   * @param <F> the type of the sixth input
   * @param <G> the type of the seventh input
   * @param <H> the type of the eighth input
   * @param <I> the type of the ninth input
    */
  public static class WithPlaceholders9<A, B, C, D, E, F, G, H, I> extends
      AbstractWithPlaceholders9<A, B, C, D, E, F, G, H, I, WithPlaceholders9<A, B, C, D, E, F, G, H, I>> {
    /**
     * Creates a new partial DAG that will be rooted at the provided placeholders.
     *
     * @param placeholder1 the first placeholder
     * @param placeholder2 the second placeholder
     * @param placeholder3 the third placeholder
     * @param placeholder4 the fourth placeholder
     * @param placeholder5 the fifth placeholder
     * @param placeholder6 the sixth placeholder
     * @param placeholder7 the seventh placeholder
     * @param placeholder8 the eighth placeholder
     * @param placeholder9 the ninth placeholder
     */
    WithPlaceholders9(Placeholder<? extends A> placeholder1, Placeholder<? extends B> placeholder2,
        Placeholder<? extends C> placeholder3, Placeholder<? extends D> placeholder4,
        Placeholder<? extends E> placeholder5, Placeholder<? extends F> placeholder6,
        Placeholder<? extends G> placeholder7, Placeholder<? extends H> placeholder8,
        Placeholder<? extends I> placeholder9) {
      super(placeholder1, placeholder2, placeholder3, placeholder4, placeholder5, placeholder6, placeholder7,
          placeholder8, placeholder9);
    }

    /**
     * Creates a new partial DAG that will be rooted at the provided placeholders, which will replace ("remap") the provided
     * "input" nodes that define a subgraph of the original graph (as defined by the ancestors of the outputs that will
     * be provided when the partial DAG is completed).  The input nodes, and any nodes that were exclusively the
     * ancestors of the input nodes, are truncated from the resulting graph.
     *
     * @param placeholder1 the first placeholder
     * @param placeholder2 the second placeholder
     * @param placeholder3 the third placeholder
     * @param placeholder4 the fourth placeholder
     * @param placeholder5 the fifth placeholder
     * @param placeholder6 the sixth placeholder
     * @param placeholder7 the seventh placeholder
     * @param placeholder8 the eighth placeholder
     * @param placeholder9 the ninth placeholder
     * @param input1 the first input
     * @param input2 the second input
     * @param input3 the third input
     * @param input4 the fourth input
     * @param input5 the fifth input
     * @param input6 the sixth input
     * @param input7 the seventh input
     * @param input8 the eighth input
     * @param input9 the ninth input
     */
    WithPlaceholders9(Placeholder<? extends A> placeholder1, Placeholder<? extends B> placeholder2,
        Placeholder<? extends C> placeholder3, Placeholder<? extends D> placeholder4,
        Placeholder<? extends E> placeholder5, Placeholder<? extends F> placeholder6,
        Placeholder<? extends G> placeholder7, Placeholder<? extends H> placeholder8,
        Placeholder<? extends I> placeholder9, Producer<? extends A> input1, Producer<? extends B> input2,
        Producer<? extends C> input3, Producer<? extends D> input4, Producer<? extends E> input5,
        Producer<? extends F> input6, Producer<? extends G> input7, Producer<? extends H> input8,
        Producer<? extends I> input9) {
      super(placeholder1, placeholder2, placeholder3, placeholder4, placeholder5, placeholder6, placeholder7,
          placeholder8, placeholder9, input1, input2, input3, input4, input5, input6, input7, input8, input9);
    }

    /**
     * Creates a completed DAG by supplying this partial DAG with its outputs (outputs).
     *
     * @param output1 the first output (output) of the DAG
     * @param <RA> the type of the first result
     * @return a completed DAG with 9 inputs (placeholders) and 1 output (outputs).
     */
    public <RA> DAG9x1<A, B, C, D, E, F, G, H, I, RA> withOutputs(Producer<? extends RA> output1) {
      Objects.requireNonNull(output1, "Output 1 may not be null");

      if (_shouldRemapInputs) {
        Map<Producer<?>, Producer<?>> inputMapping =
            DAGUtil.createInputMap(_input1, _placeholder1, _input2, _placeholder2, _input3, _placeholder3, _input4,
                _placeholder4, _input5, _placeholder5, _input6, _placeholder6, _input7, _placeholder7, _input8,
                _placeholder8, _input9, _placeholder9);
        output1 = DAGUtil.replaceInputs(output1, inputMapping);
      }

      List<Producer<?>> inputs =
          Arrays.asList(_input1, _input2, _input3, _input4, _input5, _input6, _input7, _input8, _input9);

      return ((DAG9x1) DAGUtil
          .createPreparableDAG(
              Arrays.asList(_placeholder1, _placeholder2, _placeholder3, _placeholder4, _placeholder5, _placeholder6,
                  _placeholder7, _placeholder8, _placeholder9), Arrays.asList(output1)).internalAPI()
          .withInputsUnsafe(inputs)).withReduction(_minimumReducerLevel);
    }

    /**
     * Creates a completed DAG by supplying this partial DAG with its outputs (outputs).
     *
     * @param output1 the first output (output) of the DAG
     * @param <RA> the type of the first result
     * @return a completed DAG with 9 inputs (placeholders) and 1 output (outputs).
     */
    public <RA> DAG9x1<A, B, C, D, E, F, G, H, I, RA> withOutput(Producer<? extends RA> output1) {
      Objects.requireNonNull(output1, "Output 1 may not be null");

      if (_shouldRemapInputs) {
        Map<Producer<?>, Producer<?>> inputMapping =
            DAGUtil.createInputMap(_input1, _placeholder1, _input2, _placeholder2, _input3, _placeholder3, _input4,
                _placeholder4, _input5, _placeholder5, _input6, _placeholder6, _input7, _placeholder7, _input8,
                _placeholder8, _input9, _placeholder9);
        output1 = DAGUtil.replaceInputs(output1, inputMapping);
      }

      List<Producer<?>> inputs =
          Arrays.asList(_input1, _input2, _input3, _input4, _input5, _input6, _input7, _input8, _input9);

      return ((DAG9x1) DAGUtil
          .createPreparableDAG(
              Arrays.asList(_placeholder1, _placeholder2, _placeholder3, _placeholder4, _placeholder5, _placeholder6,
                  _placeholder7, _placeholder8, _placeholder9), Arrays.asList(output1)).internalAPI()
          .withInputsUnsafe(inputs)).withReduction(_minimumReducerLevel);
    }

    /**
     * Creates a completed DAG by supplying this partial DAG with its outputs (outputs).
     *
     * @param output1 the first output (output) of the DAG
     * @param output2 the second output (output) of the DAG
     * @param <RA> the type of the first result
     * @param <RB> the type of the second result
     * @return a completed DAG with 9 inputs (placeholders) and 2 outputs (outputs).
     */
    public <RA, RB> DAG9x2<A, B, C, D, E, F, G, H, I, RA, RB> withOutputs(Producer<? extends RA> output1,
        Producer<? extends RB> output2) {
      Objects.requireNonNull(output1, "Output 1 may not be null");
      Objects.requireNonNull(output2, "Output 2 may not be null");

      if (_shouldRemapInputs) {
        Map<Producer<?>, Producer<?>> inputMapping =
            DAGUtil.createInputMap(_input1, _placeholder1, _input2, _placeholder2, _input3, _placeholder3, _input4,
                _placeholder4, _input5, _placeholder5, _input6, _placeholder6, _input7, _placeholder7, _input8,
                _placeholder8, _input9, _placeholder9);
        output1 = DAGUtil.replaceInputs(output1, inputMapping);
        output2 = DAGUtil.replaceInputs(output2, inputMapping);
      }

      List<Producer<?>> inputs =
          Arrays.asList(_input1, _input2, _input3, _input4, _input5, _input6, _input7, _input8, _input9);

      return ((DAG9x2) DAGUtil
          .createPreparableDAG(
              Arrays.asList(_placeholder1, _placeholder2, _placeholder3, _placeholder4, _placeholder5, _placeholder6,
                  _placeholder7, _placeholder8, _placeholder9), Arrays.asList(output1, output2)).internalAPI()
          .withInputsUnsafe(inputs)).withReduction(_minimumReducerLevel);
    }

    /**
     * Creates a completed DAG by supplying this partial DAG with its outputs (outputs).
     *
     * @param output1 the first output (output) of the DAG
     * @param output2 the second output (output) of the DAG
     * @param output3 the third output (output) of the DAG
     * @param <RA> the type of the first result
     * @param <RB> the type of the second result
     * @param <RC> the type of the third result
     * @return a completed DAG with 9 inputs (placeholders) and 3 outputs (outputs).
     */
    public <RA, RB, RC> DAG9x3<A, B, C, D, E, F, G, H, I, RA, RB, RC> withOutputs(Producer<? extends RA> output1,
        Producer<? extends RB> output2, Producer<? extends RC> output3) {
      Objects.requireNonNull(output1, "Output 1 may not be null");
      Objects.requireNonNull(output2, "Output 2 may not be null");
      Objects.requireNonNull(output3, "Output 3 may not be null");

      if (_shouldRemapInputs) {
        Map<Producer<?>, Producer<?>> inputMapping =
            DAGUtil.createInputMap(_input1, _placeholder1, _input2, _placeholder2, _input3, _placeholder3, _input4,
                _placeholder4, _input5, _placeholder5, _input6, _placeholder6, _input7, _placeholder7, _input8,
                _placeholder8, _input9, _placeholder9);
        output1 = DAGUtil.replaceInputs(output1, inputMapping);
        output2 = DAGUtil.replaceInputs(output2, inputMapping);
        output3 = DAGUtil.replaceInputs(output3, inputMapping);
      }

      List<Producer<?>> inputs =
          Arrays.asList(_input1, _input2, _input3, _input4, _input5, _input6, _input7, _input8, _input9);

      return ((DAG9x3) DAGUtil
          .createPreparableDAG(
              Arrays.asList(_placeholder1, _placeholder2, _placeholder3, _placeholder4, _placeholder5, _placeholder6,
                  _placeholder7, _placeholder8, _placeholder9), Arrays.asList(output1, output2, output3)).internalAPI()
          .withInputsUnsafe(inputs)).withReduction(_minimumReducerLevel);
    }

    /**
     * Creates a completed DAG by supplying this partial DAG with its outputs (outputs).
     *
     * @param output1 the first output (output) of the DAG
     * @param output2 the second output (output) of the DAG
     * @param output3 the third output (output) of the DAG
     * @param output4 the fourth output (output) of the DAG
     * @param <RA> the type of the first result
     * @param <RB> the type of the second result
     * @param <RC> the type of the third result
     * @param <RD> the type of the fourth result
     * @return a completed DAG with 9 inputs (placeholders) and 4 outputs (outputs).
     */
    public <RA, RB, RC, RD> DAG9x4<A, B, C, D, E, F, G, H, I, RA, RB, RC, RD> withOutputs(
        Producer<? extends RA> output1, Producer<? extends RB> output2, Producer<? extends RC> output3,
        Producer<? extends RD> output4) {
      Objects.requireNonNull(output1, "Output 1 may not be null");
      Objects.requireNonNull(output2, "Output 2 may not be null");
      Objects.requireNonNull(output3, "Output 3 may not be null");
      Objects.requireNonNull(output4, "Output 4 may not be null");

      if (_shouldRemapInputs) {
        Map<Producer<?>, Producer<?>> inputMapping =
            DAGUtil.createInputMap(_input1, _placeholder1, _input2, _placeholder2, _input3, _placeholder3, _input4,
                _placeholder4, _input5, _placeholder5, _input6, _placeholder6, _input7, _placeholder7, _input8,
                _placeholder8, _input9, _placeholder9);
        output1 = DAGUtil.replaceInputs(output1, inputMapping);
        output2 = DAGUtil.replaceInputs(output2, inputMapping);
        output3 = DAGUtil.replaceInputs(output3, inputMapping);
        output4 = DAGUtil.replaceInputs(output4, inputMapping);
      }

      List<Producer<?>> inputs =
          Arrays.asList(_input1, _input2, _input3, _input4, _input5, _input6, _input7, _input8, _input9);

      return ((DAG9x4) DAGUtil
          .createPreparableDAG(
              Arrays.asList(_placeholder1, _placeholder2, _placeholder3, _placeholder4, _placeholder5, _placeholder6,
                  _placeholder7, _placeholder8, _placeholder9), Arrays.asList(output1, output2, output3, output4))
          .internalAPI().withInputsUnsafe(inputs)).withReduction(_minimumReducerLevel);
    }

    /**
     * Creates a completed DAG by supplying this partial DAG with its outputs (outputs).
     *
     * @param output1 the first output (output) of the DAG
     * @param output2 the second output (output) of the DAG
     * @param output3 the third output (output) of the DAG
     * @param output4 the fourth output (output) of the DAG
     * @param output5 the fifth output (output) of the DAG
     * @param <RA> the type of the first result
     * @param <RB> the type of the second result
     * @param <RC> the type of the third result
     * @param <RD> the type of the fourth result
     * @param <RE> the type of the fifth result
     * @return a completed DAG with 9 inputs (placeholders) and 5 outputs (outputs).
     */
    public <RA, RB, RC, RD, RE> DAG9x5<A, B, C, D, E, F, G, H, I, RA, RB, RC, RD, RE> withOutputs(
        Producer<? extends RA> output1, Producer<? extends RB> output2, Producer<? extends RC> output3,
        Producer<? extends RD> output4, Producer<? extends RE> output5) {
      Objects.requireNonNull(output1, "Output 1 may not be null");
      Objects.requireNonNull(output2, "Output 2 may not be null");
      Objects.requireNonNull(output3, "Output 3 may not be null");
      Objects.requireNonNull(output4, "Output 4 may not be null");
      Objects.requireNonNull(output5, "Output 5 may not be null");

      if (_shouldRemapInputs) {
        Map<Producer<?>, Producer<?>> inputMapping =
            DAGUtil.createInputMap(_input1, _placeholder1, _input2, _placeholder2, _input3, _placeholder3, _input4,
                _placeholder4, _input5, _placeholder5, _input6, _placeholder6, _input7, _placeholder7, _input8,
                _placeholder8, _input9, _placeholder9);
        output1 = DAGUtil.replaceInputs(output1, inputMapping);
        output2 = DAGUtil.replaceInputs(output2, inputMapping);
        output3 = DAGUtil.replaceInputs(output3, inputMapping);
        output4 = DAGUtil.replaceInputs(output4, inputMapping);
        output5 = DAGUtil.replaceInputs(output5, inputMapping);
      }

      List<Producer<?>> inputs =
          Arrays.asList(_input1, _input2, _input3, _input4, _input5, _input6, _input7, _input8, _input9);

      return ((DAG9x5) DAGUtil
          .createPreparableDAG(
              Arrays.asList(_placeholder1, _placeholder2, _placeholder3, _placeholder4, _placeholder5, _placeholder6,
                  _placeholder7, _placeholder8, _placeholder9),
              Arrays.asList(output1, output2, output3, output4, output5)).internalAPI().withInputsUnsafe(inputs))
          .withReduction(_minimumReducerLevel);
    }

    /**
     * Creates a completed DAG by supplying this partial DAG with its outputs (outputs).
     *
     * @param output1 the first output (output) of the DAG
     * @param output2 the second output (output) of the DAG
     * @param output3 the third output (output) of the DAG
     * @param output4 the fourth output (output) of the DAG
     * @param output5 the fifth output (output) of the DAG
     * @param output6 the sixth output (output) of the DAG
     * @param <RA> the type of the first result
     * @param <RB> the type of the second result
     * @param <RC> the type of the third result
     * @param <RD> the type of the fourth result
     * @param <RE> the type of the fifth result
     * @param <RF> the type of the sixth result
     * @return a completed DAG with 9 inputs (placeholders) and 6 outputs (outputs).
     */
    public <RA, RB, RC, RD, RE, RF> DAG9x6<A, B, C, D, E, F, G, H, I, RA, RB, RC, RD, RE, RF> withOutputs(
        Producer<? extends RA> output1, Producer<? extends RB> output2, Producer<? extends RC> output3,
        Producer<? extends RD> output4, Producer<? extends RE> output5, Producer<? extends RF> output6) {
      Objects.requireNonNull(output1, "Output 1 may not be null");
      Objects.requireNonNull(output2, "Output 2 may not be null");
      Objects.requireNonNull(output3, "Output 3 may not be null");
      Objects.requireNonNull(output4, "Output 4 may not be null");
      Objects.requireNonNull(output5, "Output 5 may not be null");
      Objects.requireNonNull(output6, "Output 6 may not be null");

      if (_shouldRemapInputs) {
        Map<Producer<?>, Producer<?>> inputMapping =
            DAGUtil.createInputMap(_input1, _placeholder1, _input2, _placeholder2, _input3, _placeholder3, _input4,
                _placeholder4, _input5, _placeholder5, _input6, _placeholder6, _input7, _placeholder7, _input8,
                _placeholder8, _input9, _placeholder9);
        output1 = DAGUtil.replaceInputs(output1, inputMapping);
        output2 = DAGUtil.replaceInputs(output2, inputMapping);
        output3 = DAGUtil.replaceInputs(output3, inputMapping);
        output4 = DAGUtil.replaceInputs(output4, inputMapping);
        output5 = DAGUtil.replaceInputs(output5, inputMapping);
        output6 = DAGUtil.replaceInputs(output6, inputMapping);
      }

      List<Producer<?>> inputs =
          Arrays.asList(_input1, _input2, _input3, _input4, _input5, _input6, _input7, _input8, _input9);

      return ((DAG9x6) DAGUtil
          .createPreparableDAG(
              Arrays.asList(_placeholder1, _placeholder2, _placeholder3, _placeholder4, _placeholder5, _placeholder6,
                  _placeholder7, _placeholder8, _placeholder9),
              Arrays.asList(output1, output2, output3, output4, output5, output6)).internalAPI()
          .withInputsUnsafe(inputs)).withReduction(_minimumReducerLevel);
    }

    /**
     * Creates a completed DAG by supplying this partial DAG with its outputs (outputs).
     *
     * @param output1 the first output (output) of the DAG
     * @param output2 the second output (output) of the DAG
     * @param output3 the third output (output) of the DAG
     * @param output4 the fourth output (output) of the DAG
     * @param output5 the fifth output (output) of the DAG
     * @param output6 the sixth output (output) of the DAG
     * @param output7 the seventh output (output) of the DAG
     * @param <RA> the type of the first result
     * @param <RB> the type of the second result
     * @param <RC> the type of the third result
     * @param <RD> the type of the fourth result
     * @param <RE> the type of the fifth result
     * @param <RF> the type of the sixth result
     * @param <RG> the type of the seventh result
     * @return a completed DAG with 9 inputs (placeholders) and 7 outputs (outputs).
     */
    public <RA, RB, RC, RD, RE, RF, RG> DAG9x7<A, B, C, D, E, F, G, H, I, RA, RB, RC, RD, RE, RF, RG> withOutputs(
        Producer<? extends RA> output1, Producer<? extends RB> output2, Producer<? extends RC> output3,
        Producer<? extends RD> output4, Producer<? extends RE> output5, Producer<? extends RF> output6,
        Producer<? extends RG> output7) {
      Objects.requireNonNull(output1, "Output 1 may not be null");
      Objects.requireNonNull(output2, "Output 2 may not be null");
      Objects.requireNonNull(output3, "Output 3 may not be null");
      Objects.requireNonNull(output4, "Output 4 may not be null");
      Objects.requireNonNull(output5, "Output 5 may not be null");
      Objects.requireNonNull(output6, "Output 6 may not be null");
      Objects.requireNonNull(output7, "Output 7 may not be null");

      if (_shouldRemapInputs) {
        Map<Producer<?>, Producer<?>> inputMapping =
            DAGUtil.createInputMap(_input1, _placeholder1, _input2, _placeholder2, _input3, _placeholder3, _input4,
                _placeholder4, _input5, _placeholder5, _input6, _placeholder6, _input7, _placeholder7, _input8,
                _placeholder8, _input9, _placeholder9);
        output1 = DAGUtil.replaceInputs(output1, inputMapping);
        output2 = DAGUtil.replaceInputs(output2, inputMapping);
        output3 = DAGUtil.replaceInputs(output3, inputMapping);
        output4 = DAGUtil.replaceInputs(output4, inputMapping);
        output5 = DAGUtil.replaceInputs(output5, inputMapping);
        output6 = DAGUtil.replaceInputs(output6, inputMapping);
        output7 = DAGUtil.replaceInputs(output7, inputMapping);
      }

      List<Producer<?>> inputs =
          Arrays.asList(_input1, _input2, _input3, _input4, _input5, _input6, _input7, _input8, _input9);

      return ((DAG9x7) DAGUtil
          .createPreparableDAG(
              Arrays.asList(_placeholder1, _placeholder2, _placeholder3, _placeholder4, _placeholder5, _placeholder6,
                  _placeholder7, _placeholder8, _placeholder9),
              Arrays.asList(output1, output2, output3, output4, output5, output6, output7)).internalAPI()
          .withInputsUnsafe(inputs)).withReduction(_minimumReducerLevel);
    }

    /**
     * Creates a completed DAG by supplying this partial DAG with its outputs (outputs).
     *
     * @param output1 the first output (output) of the DAG
     * @param output2 the second output (output) of the DAG
     * @param output3 the third output (output) of the DAG
     * @param output4 the fourth output (output) of the DAG
     * @param output5 the fifth output (output) of the DAG
     * @param output6 the sixth output (output) of the DAG
     * @param output7 the seventh output (output) of the DAG
     * @param output8 the eighth output (output) of the DAG
     * @param <RA> the type of the first result
     * @param <RB> the type of the second result
     * @param <RC> the type of the third result
     * @param <RD> the type of the fourth result
     * @param <RE> the type of the fifth result
     * @param <RF> the type of the sixth result
     * @param <RG> the type of the seventh result
     * @param <RH> the type of the eighth result
     * @return a completed DAG with 9 inputs (placeholders) and 8 outputs (outputs).
     */
    public <RA, RB, RC, RD, RE, RF, RG, RH> DAG9x8<A, B, C, D, E, F, G, H, I, RA, RB, RC, RD, RE, RF, RG, RH> withOutputs(
        Producer<? extends RA> output1, Producer<? extends RB> output2, Producer<? extends RC> output3,
        Producer<? extends RD> output4, Producer<? extends RE> output5, Producer<? extends RF> output6,
        Producer<? extends RG> output7, Producer<? extends RH> output8) {
      Objects.requireNonNull(output1, "Output 1 may not be null");
      Objects.requireNonNull(output2, "Output 2 may not be null");
      Objects.requireNonNull(output3, "Output 3 may not be null");
      Objects.requireNonNull(output4, "Output 4 may not be null");
      Objects.requireNonNull(output5, "Output 5 may not be null");
      Objects.requireNonNull(output6, "Output 6 may not be null");
      Objects.requireNonNull(output7, "Output 7 may not be null");
      Objects.requireNonNull(output8, "Output 8 may not be null");

      if (_shouldRemapInputs) {
        Map<Producer<?>, Producer<?>> inputMapping =
            DAGUtil.createInputMap(_input1, _placeholder1, _input2, _placeholder2, _input3, _placeholder3, _input4,
                _placeholder4, _input5, _placeholder5, _input6, _placeholder6, _input7, _placeholder7, _input8,
                _placeholder8, _input9, _placeholder9);
        output1 = DAGUtil.replaceInputs(output1, inputMapping);
        output2 = DAGUtil.replaceInputs(output2, inputMapping);
        output3 = DAGUtil.replaceInputs(output3, inputMapping);
        output4 = DAGUtil.replaceInputs(output4, inputMapping);
        output5 = DAGUtil.replaceInputs(output5, inputMapping);
        output6 = DAGUtil.replaceInputs(output6, inputMapping);
        output7 = DAGUtil.replaceInputs(output7, inputMapping);
        output8 = DAGUtil.replaceInputs(output8, inputMapping);
      }

      List<Producer<?>> inputs =
          Arrays.asList(_input1, _input2, _input3, _input4, _input5, _input6, _input7, _input8, _input9);

      return ((DAG9x8) DAGUtil
          .createPreparableDAG(
              Arrays.asList(_placeholder1, _placeholder2, _placeholder3, _placeholder4, _placeholder5, _placeholder6,
                  _placeholder7, _placeholder8, _placeholder9),
              Arrays.asList(output1, output2, output3, output4, output5, output6, output7, output8)).internalAPI()
          .withInputsUnsafe(inputs)).withReduction(_minimumReducerLevel);
    }

    /**
     * Creates a completed DAG by supplying this partial DAG with its outputs (outputs).
     *
     * @param output1 the first output (output) of the DAG
     * @param output2 the second output (output) of the DAG
     * @param output3 the third output (output) of the DAG
     * @param output4 the fourth output (output) of the DAG
     * @param output5 the fifth output (output) of the DAG
     * @param output6 the sixth output (output) of the DAG
     * @param output7 the seventh output (output) of the DAG
     * @param output8 the eighth output (output) of the DAG
     * @param output9 the ninth output (output) of the DAG
     * @param <RA> the type of the first result
     * @param <RB> the type of the second result
     * @param <RC> the type of the third result
     * @param <RD> the type of the fourth result
     * @param <RE> the type of the fifth result
     * @param <RF> the type of the sixth result
     * @param <RG> the type of the seventh result
     * @param <RH> the type of the eighth result
     * @param <RI> the type of the ninth result
     * @return a completed DAG with 9 inputs (placeholders) and 9 outputs (outputs).
     */
    public <RA, RB, RC, RD, RE, RF, RG, RH, RI> DAG9x9<A, B, C, D, E, F, G, H, I, RA, RB, RC, RD, RE, RF, RG, RH, RI> withOutputs(
        Producer<? extends RA> output1, Producer<? extends RB> output2, Producer<? extends RC> output3,
        Producer<? extends RD> output4, Producer<? extends RE> output5, Producer<? extends RF> output6,
        Producer<? extends RG> output7, Producer<? extends RH> output8, Producer<? extends RI> output9) {
      Objects.requireNonNull(output1, "Output 1 may not be null");
      Objects.requireNonNull(output2, "Output 2 may not be null");
      Objects.requireNonNull(output3, "Output 3 may not be null");
      Objects.requireNonNull(output4, "Output 4 may not be null");
      Objects.requireNonNull(output5, "Output 5 may not be null");
      Objects.requireNonNull(output6, "Output 6 may not be null");
      Objects.requireNonNull(output7, "Output 7 may not be null");
      Objects.requireNonNull(output8, "Output 8 may not be null");
      Objects.requireNonNull(output9, "Output 9 may not be null");

      if (_shouldRemapInputs) {
        Map<Producer<?>, Producer<?>> inputMapping =
            DAGUtil.createInputMap(_input1, _placeholder1, _input2, _placeholder2, _input3, _placeholder3, _input4,
                _placeholder4, _input5, _placeholder5, _input6, _placeholder6, _input7, _placeholder7, _input8,
                _placeholder8, _input9, _placeholder9);
        output1 = DAGUtil.replaceInputs(output1, inputMapping);
        output2 = DAGUtil.replaceInputs(output2, inputMapping);
        output3 = DAGUtil.replaceInputs(output3, inputMapping);
        output4 = DAGUtil.replaceInputs(output4, inputMapping);
        output5 = DAGUtil.replaceInputs(output5, inputMapping);
        output6 = DAGUtil.replaceInputs(output6, inputMapping);
        output7 = DAGUtil.replaceInputs(output7, inputMapping);
        output8 = DAGUtil.replaceInputs(output8, inputMapping);
        output9 = DAGUtil.replaceInputs(output9, inputMapping);
      }

      List<Producer<?>> inputs =
          Arrays.asList(_input1, _input2, _input3, _input4, _input5, _input6, _input7, _input8, _input9);

      return ((DAG9x9) DAGUtil
          .createPreparableDAG(
              Arrays.asList(_placeholder1, _placeholder2, _placeholder3, _placeholder4, _placeholder5, _placeholder6,
                  _placeholder7, _placeholder8, _placeholder9),
              Arrays.asList(output1, output2, output3, output4, output5, output6, output7, output8, output9))
          .internalAPI().withInputsUnsafe(inputs)).withReduction(_minimumReducerLevel);
    }

    /**
     * Creates a completed DAG by supplying this partial DAG with its outputs (outputs).
     *
     * @param output1 the first output (output) of the DAG
     * @param output2 the second output (output) of the DAG
     * @param output3 the third output (output) of the DAG
     * @param output4 the fourth output (output) of the DAG
     * @param output5 the fifth output (output) of the DAG
     * @param output6 the sixth output (output) of the DAG
     * @param output7 the seventh output (output) of the DAG
     * @param output8 the eighth output (output) of the DAG
     * @param output9 the ninth output (output) of the DAG
     * @param output10 the tenth output (output) of the DAG
     * @param <RA> the type of the first result
     * @param <RB> the type of the second result
     * @param <RC> the type of the third result
     * @param <RD> the type of the fourth result
     * @param <RE> the type of the fifth result
     * @param <RF> the type of the sixth result
     * @param <RG> the type of the seventh result
     * @param <RH> the type of the eighth result
     * @param <RI> the type of the ninth result
     * @param <RJ> the type of the tenth result
     * @return a completed DAG with 9 inputs (placeholders) and 10 outputs (outputs).
     */
    public <RA, RB, RC, RD, RE, RF, RG, RH, RI, RJ> DAG9x10<A, B, C, D, E, F, G, H, I, RA, RB, RC, RD, RE, RF, RG, RH, RI, RJ> withOutputs(
        Producer<? extends RA> output1, Producer<? extends RB> output2, Producer<? extends RC> output3,
        Producer<? extends RD> output4, Producer<? extends RE> output5, Producer<? extends RF> output6,
        Producer<? extends RG> output7, Producer<? extends RH> output8, Producer<? extends RI> output9,
        Producer<? extends RJ> output10) {
      Objects.requireNonNull(output1, "Output 1 may not be null");
      Objects.requireNonNull(output2, "Output 2 may not be null");
      Objects.requireNonNull(output3, "Output 3 may not be null");
      Objects.requireNonNull(output4, "Output 4 may not be null");
      Objects.requireNonNull(output5, "Output 5 may not be null");
      Objects.requireNonNull(output6, "Output 6 may not be null");
      Objects.requireNonNull(output7, "Output 7 may not be null");
      Objects.requireNonNull(output8, "Output 8 may not be null");
      Objects.requireNonNull(output9, "Output 9 may not be null");
      Objects.requireNonNull(output10, "Output 10 may not be null");

      if (_shouldRemapInputs) {
        Map<Producer<?>, Producer<?>> inputMapping =
            DAGUtil.createInputMap(_input1, _placeholder1, _input2, _placeholder2, _input3, _placeholder3, _input4,
                _placeholder4, _input5, _placeholder5, _input6, _placeholder6, _input7, _placeholder7, _input8,
                _placeholder8, _input9, _placeholder9);
        output1 = DAGUtil.replaceInputs(output1, inputMapping);
        output2 = DAGUtil.replaceInputs(output2, inputMapping);
        output3 = DAGUtil.replaceInputs(output3, inputMapping);
        output4 = DAGUtil.replaceInputs(output4, inputMapping);
        output5 = DAGUtil.replaceInputs(output5, inputMapping);
        output6 = DAGUtil.replaceInputs(output6, inputMapping);
        output7 = DAGUtil.replaceInputs(output7, inputMapping);
        output8 = DAGUtil.replaceInputs(output8, inputMapping);
        output9 = DAGUtil.replaceInputs(output9, inputMapping);
        output10 = DAGUtil.replaceInputs(output10, inputMapping);
      }

      List<Producer<?>> inputs =
          Arrays.asList(_input1, _input2, _input3, _input4, _input5, _input6, _input7, _input8, _input9);

      return ((DAG9x10) DAGUtil
          .createPreparableDAG(
              Arrays.asList(_placeholder1, _placeholder2, _placeholder3, _placeholder4, _placeholder5, _placeholder6,
                  _placeholder7, _placeholder8, _placeholder9),
              Arrays.asList(output1, output2, output3, output4, output5, output6, output7, output8, output9, output10))
          .internalAPI().withInputsUnsafe(inputs)).withReduction(_minimumReducerLevel);
    }
  }

  /**
    * A partial DAG with 10 placeholder.  Partial DAGs are <i>completed</i> to create a usable DAG by specifying
    * the outputs (<i>outputs</i>) of the DAG using the withOutputs(...) methods.
    *
   * @param <A> the type of the first input
   * @param <B> the type of the second input
   * @param <C> the type of the third input
   * @param <D> the type of the fourth input
   * @param <E> the type of the fifth input
   * @param <F> the type of the sixth input
   * @param <G> the type of the seventh input
   * @param <H> the type of the eighth input
   * @param <I> the type of the ninth input
   * @param <J> the type of the tenth input
    */
  public static class WithPlaceholders10<A, B, C, D, E, F, G, H, I, J> extends
      AbstractWithPlaceholders10<A, B, C, D, E, F, G, H, I, J, WithPlaceholders10<A, B, C, D, E, F, G, H, I, J>> {
    /**
     * Creates a new partial DAG that will be rooted at the provided placeholders.
     *
     * @param placeholder1 the first placeholder
     * @param placeholder2 the second placeholder
     * @param placeholder3 the third placeholder
     * @param placeholder4 the fourth placeholder
     * @param placeholder5 the fifth placeholder
     * @param placeholder6 the sixth placeholder
     * @param placeholder7 the seventh placeholder
     * @param placeholder8 the eighth placeholder
     * @param placeholder9 the ninth placeholder
     * @param placeholder10 the tenth placeholder
     */
    WithPlaceholders10(Placeholder<? extends A> placeholder1, Placeholder<? extends B> placeholder2,
        Placeholder<? extends C> placeholder3, Placeholder<? extends D> placeholder4,
        Placeholder<? extends E> placeholder5, Placeholder<? extends F> placeholder6,
        Placeholder<? extends G> placeholder7, Placeholder<? extends H> placeholder8,
        Placeholder<? extends I> placeholder9, Placeholder<? extends J> placeholder10) {
      super(placeholder1, placeholder2, placeholder3, placeholder4, placeholder5, placeholder6, placeholder7,
          placeholder8, placeholder9, placeholder10);
    }

    /**
     * Creates a new partial DAG that will be rooted at the provided placeholders, which will replace ("remap") the provided
     * "input" nodes that define a subgraph of the original graph (as defined by the ancestors of the outputs that will
     * be provided when the partial DAG is completed).  The input nodes, and any nodes that were exclusively the
     * ancestors of the input nodes, are truncated from the resulting graph.
     *
     * @param placeholder1 the first placeholder
     * @param placeholder2 the second placeholder
     * @param placeholder3 the third placeholder
     * @param placeholder4 the fourth placeholder
     * @param placeholder5 the fifth placeholder
     * @param placeholder6 the sixth placeholder
     * @param placeholder7 the seventh placeholder
     * @param placeholder8 the eighth placeholder
     * @param placeholder9 the ninth placeholder
     * @param placeholder10 the tenth placeholder
     * @param input1 the first input
     * @param input2 the second input
     * @param input3 the third input
     * @param input4 the fourth input
     * @param input5 the fifth input
     * @param input6 the sixth input
     * @param input7 the seventh input
     * @param input8 the eighth input
     * @param input9 the ninth input
     * @param input10 the tenth input
     */
    WithPlaceholders10(Placeholder<? extends A> placeholder1, Placeholder<? extends B> placeholder2,
        Placeholder<? extends C> placeholder3, Placeholder<? extends D> placeholder4,
        Placeholder<? extends E> placeholder5, Placeholder<? extends F> placeholder6,
        Placeholder<? extends G> placeholder7, Placeholder<? extends H> placeholder8,
        Placeholder<? extends I> placeholder9, Placeholder<? extends J> placeholder10, Producer<? extends A> input1,
        Producer<? extends B> input2, Producer<? extends C> input3, Producer<? extends D> input4,
        Producer<? extends E> input5, Producer<? extends F> input6, Producer<? extends G> input7,
        Producer<? extends H> input8, Producer<? extends I> input9, Producer<? extends J> input10) {
      super(placeholder1, placeholder2, placeholder3, placeholder4, placeholder5, placeholder6, placeholder7,
          placeholder8, placeholder9, placeholder10, input1, input2, input3, input4, input5, input6, input7, input8,
          input9, input10);
    }

    /**
     * Creates a completed DAG by supplying this partial DAG with its outputs (outputs).
     *
     * @param output1 the first output (output) of the DAG
     * @param <RA> the type of the first result
     * @return a completed DAG with 10 inputs (placeholders) and 1 output (outputs).
     */
    public <RA> DAG10x1<A, B, C, D, E, F, G, H, I, J, RA> withOutputs(Producer<? extends RA> output1) {
      Objects.requireNonNull(output1, "Output 1 may not be null");

      if (_shouldRemapInputs) {
        Map<Producer<?>, Producer<?>> inputMapping =
            DAGUtil.createInputMap(_input1, _placeholder1, _input2, _placeholder2, _input3, _placeholder3, _input4,
                _placeholder4, _input5, _placeholder5, _input6, _placeholder6, _input7, _placeholder7, _input8,
                _placeholder8, _input9, _placeholder9, _input10, _placeholder10);
        output1 = DAGUtil.replaceInputs(output1, inputMapping);
      }

      List<Producer<?>> inputs =
          Arrays.asList(_input1, _input2, _input3, _input4, _input5, _input6, _input7, _input8, _input9, _input10);

      return ((DAG10x1) DAGUtil
          .createPreparableDAG(
              Arrays.asList(_placeholder1, _placeholder2, _placeholder3, _placeholder4, _placeholder5, _placeholder6,
                  _placeholder7, _placeholder8, _placeholder9, _placeholder10), Arrays.asList(output1)).internalAPI()
          .withInputsUnsafe(inputs)).withReduction(_minimumReducerLevel);
    }

    /**
     * Creates a completed DAG by supplying this partial DAG with its outputs (outputs).
     *
     * @param output1 the first output (output) of the DAG
     * @param <RA> the type of the first result
     * @return a completed DAG with 10 inputs (placeholders) and 1 output (outputs).
     */
    public <RA> DAG10x1<A, B, C, D, E, F, G, H, I, J, RA> withOutput(Producer<? extends RA> output1) {
      Objects.requireNonNull(output1, "Output 1 may not be null");

      if (_shouldRemapInputs) {
        Map<Producer<?>, Producer<?>> inputMapping =
            DAGUtil.createInputMap(_input1, _placeholder1, _input2, _placeholder2, _input3, _placeholder3, _input4,
                _placeholder4, _input5, _placeholder5, _input6, _placeholder6, _input7, _placeholder7, _input8,
                _placeholder8, _input9, _placeholder9, _input10, _placeholder10);
        output1 = DAGUtil.replaceInputs(output1, inputMapping);
      }

      List<Producer<?>> inputs =
          Arrays.asList(_input1, _input2, _input3, _input4, _input5, _input6, _input7, _input8, _input9, _input10);

      return ((DAG10x1) DAGUtil
          .createPreparableDAG(
              Arrays.asList(_placeholder1, _placeholder2, _placeholder3, _placeholder4, _placeholder5, _placeholder6,
                  _placeholder7, _placeholder8, _placeholder9, _placeholder10), Arrays.asList(output1)).internalAPI()
          .withInputsUnsafe(inputs)).withReduction(_minimumReducerLevel);
    }

    /**
     * Creates a completed DAG by supplying this partial DAG with its outputs (outputs).
     *
     * @param output1 the first output (output) of the DAG
     * @param output2 the second output (output) of the DAG
     * @param <RA> the type of the first result
     * @param <RB> the type of the second result
     * @return a completed DAG with 10 inputs (placeholders) and 2 outputs (outputs).
     */
    public <RA, RB> DAG10x2<A, B, C, D, E, F, G, H, I, J, RA, RB> withOutputs(Producer<? extends RA> output1,
        Producer<? extends RB> output2) {
      Objects.requireNonNull(output1, "Output 1 may not be null");
      Objects.requireNonNull(output2, "Output 2 may not be null");

      if (_shouldRemapInputs) {
        Map<Producer<?>, Producer<?>> inputMapping =
            DAGUtil.createInputMap(_input1, _placeholder1, _input2, _placeholder2, _input3, _placeholder3, _input4,
                _placeholder4, _input5, _placeholder5, _input6, _placeholder6, _input7, _placeholder7, _input8,
                _placeholder8, _input9, _placeholder9, _input10, _placeholder10);
        output1 = DAGUtil.replaceInputs(output1, inputMapping);
        output2 = DAGUtil.replaceInputs(output2, inputMapping);
      }

      List<Producer<?>> inputs =
          Arrays.asList(_input1, _input2, _input3, _input4, _input5, _input6, _input7, _input8, _input9, _input10);

      return ((DAG10x2) DAGUtil
          .createPreparableDAG(
              Arrays.asList(_placeholder1, _placeholder2, _placeholder3, _placeholder4, _placeholder5, _placeholder6,
                  _placeholder7, _placeholder8, _placeholder9, _placeholder10), Arrays.asList(output1, output2))
          .internalAPI().withInputsUnsafe(inputs)).withReduction(_minimumReducerLevel);
    }

    /**
     * Creates a completed DAG by supplying this partial DAG with its outputs (outputs).
     *
     * @param output1 the first output (output) of the DAG
     * @param output2 the second output (output) of the DAG
     * @param output3 the third output (output) of the DAG
     * @param <RA> the type of the first result
     * @param <RB> the type of the second result
     * @param <RC> the type of the third result
     * @return a completed DAG with 10 inputs (placeholders) and 3 outputs (outputs).
     */
    public <RA, RB, RC> DAG10x3<A, B, C, D, E, F, G, H, I, J, RA, RB, RC> withOutputs(Producer<? extends RA> output1,
        Producer<? extends RB> output2, Producer<? extends RC> output3) {
      Objects.requireNonNull(output1, "Output 1 may not be null");
      Objects.requireNonNull(output2, "Output 2 may not be null");
      Objects.requireNonNull(output3, "Output 3 may not be null");

      if (_shouldRemapInputs) {
        Map<Producer<?>, Producer<?>> inputMapping =
            DAGUtil.createInputMap(_input1, _placeholder1, _input2, _placeholder2, _input3, _placeholder3, _input4,
                _placeholder4, _input5, _placeholder5, _input6, _placeholder6, _input7, _placeholder7, _input8,
                _placeholder8, _input9, _placeholder9, _input10, _placeholder10);
        output1 = DAGUtil.replaceInputs(output1, inputMapping);
        output2 = DAGUtil.replaceInputs(output2, inputMapping);
        output3 = DAGUtil.replaceInputs(output3, inputMapping);
      }

      List<Producer<?>> inputs =
          Arrays.asList(_input1, _input2, _input3, _input4, _input5, _input6, _input7, _input8, _input9, _input10);

      return ((DAG10x3) DAGUtil
          .createPreparableDAG(
              Arrays.asList(_placeholder1, _placeholder2, _placeholder3, _placeholder4, _placeholder5, _placeholder6,
                  _placeholder7, _placeholder8, _placeholder9, _placeholder10),
              Arrays.asList(output1, output2, output3)).internalAPI().withInputsUnsafe(inputs))
          .withReduction(_minimumReducerLevel);
    }

    /**
     * Creates a completed DAG by supplying this partial DAG with its outputs (outputs).
     *
     * @param output1 the first output (output) of the DAG
     * @param output2 the second output (output) of the DAG
     * @param output3 the third output (output) of the DAG
     * @param output4 the fourth output (output) of the DAG
     * @param <RA> the type of the first result
     * @param <RB> the type of the second result
     * @param <RC> the type of the third result
     * @param <RD> the type of the fourth result
     * @return a completed DAG with 10 inputs (placeholders) and 4 outputs (outputs).
     */
    public <RA, RB, RC, RD> DAG10x4<A, B, C, D, E, F, G, H, I, J, RA, RB, RC, RD> withOutputs(
        Producer<? extends RA> output1, Producer<? extends RB> output2, Producer<? extends RC> output3,
        Producer<? extends RD> output4) {
      Objects.requireNonNull(output1, "Output 1 may not be null");
      Objects.requireNonNull(output2, "Output 2 may not be null");
      Objects.requireNonNull(output3, "Output 3 may not be null");
      Objects.requireNonNull(output4, "Output 4 may not be null");

      if (_shouldRemapInputs) {
        Map<Producer<?>, Producer<?>> inputMapping =
            DAGUtil.createInputMap(_input1, _placeholder1, _input2, _placeholder2, _input3, _placeholder3, _input4,
                _placeholder4, _input5, _placeholder5, _input6, _placeholder6, _input7, _placeholder7, _input8,
                _placeholder8, _input9, _placeholder9, _input10, _placeholder10);
        output1 = DAGUtil.replaceInputs(output1, inputMapping);
        output2 = DAGUtil.replaceInputs(output2, inputMapping);
        output3 = DAGUtil.replaceInputs(output3, inputMapping);
        output4 = DAGUtil.replaceInputs(output4, inputMapping);
      }

      List<Producer<?>> inputs =
          Arrays.asList(_input1, _input2, _input3, _input4, _input5, _input6, _input7, _input8, _input9, _input10);

      return ((DAG10x4) DAGUtil
          .createPreparableDAG(
              Arrays.asList(_placeholder1, _placeholder2, _placeholder3, _placeholder4, _placeholder5, _placeholder6,
                  _placeholder7, _placeholder8, _placeholder9, _placeholder10),
              Arrays.asList(output1, output2, output3, output4)).internalAPI().withInputsUnsafe(inputs))
          .withReduction(_minimumReducerLevel);
    }

    /**
     * Creates a completed DAG by supplying this partial DAG with its outputs (outputs).
     *
     * @param output1 the first output (output) of the DAG
     * @param output2 the second output (output) of the DAG
     * @param output3 the third output (output) of the DAG
     * @param output4 the fourth output (output) of the DAG
     * @param output5 the fifth output (output) of the DAG
     * @param <RA> the type of the first result
     * @param <RB> the type of the second result
     * @param <RC> the type of the third result
     * @param <RD> the type of the fourth result
     * @param <RE> the type of the fifth result
     * @return a completed DAG with 10 inputs (placeholders) and 5 outputs (outputs).
     */
    public <RA, RB, RC, RD, RE> DAG10x5<A, B, C, D, E, F, G, H, I, J, RA, RB, RC, RD, RE> withOutputs(
        Producer<? extends RA> output1, Producer<? extends RB> output2, Producer<? extends RC> output3,
        Producer<? extends RD> output4, Producer<? extends RE> output5) {
      Objects.requireNonNull(output1, "Output 1 may not be null");
      Objects.requireNonNull(output2, "Output 2 may not be null");
      Objects.requireNonNull(output3, "Output 3 may not be null");
      Objects.requireNonNull(output4, "Output 4 may not be null");
      Objects.requireNonNull(output5, "Output 5 may not be null");

      if (_shouldRemapInputs) {
        Map<Producer<?>, Producer<?>> inputMapping =
            DAGUtil.createInputMap(_input1, _placeholder1, _input2, _placeholder2, _input3, _placeholder3, _input4,
                _placeholder4, _input5, _placeholder5, _input6, _placeholder6, _input7, _placeholder7, _input8,
                _placeholder8, _input9, _placeholder9, _input10, _placeholder10);
        output1 = DAGUtil.replaceInputs(output1, inputMapping);
        output2 = DAGUtil.replaceInputs(output2, inputMapping);
        output3 = DAGUtil.replaceInputs(output3, inputMapping);
        output4 = DAGUtil.replaceInputs(output4, inputMapping);
        output5 = DAGUtil.replaceInputs(output5, inputMapping);
      }

      List<Producer<?>> inputs =
          Arrays.asList(_input1, _input2, _input3, _input4, _input5, _input6, _input7, _input8, _input9, _input10);

      return ((DAG10x5) DAGUtil
          .createPreparableDAG(
              Arrays.asList(_placeholder1, _placeholder2, _placeholder3, _placeholder4, _placeholder5, _placeholder6,
                  _placeholder7, _placeholder8, _placeholder9, _placeholder10),
              Arrays.asList(output1, output2, output3, output4, output5)).internalAPI().withInputsUnsafe(inputs))
          .withReduction(_minimumReducerLevel);
    }

    /**
     * Creates a completed DAG by supplying this partial DAG with its outputs (outputs).
     *
     * @param output1 the first output (output) of the DAG
     * @param output2 the second output (output) of the DAG
     * @param output3 the third output (output) of the DAG
     * @param output4 the fourth output (output) of the DAG
     * @param output5 the fifth output (output) of the DAG
     * @param output6 the sixth output (output) of the DAG
     * @param <RA> the type of the first result
     * @param <RB> the type of the second result
     * @param <RC> the type of the third result
     * @param <RD> the type of the fourth result
     * @param <RE> the type of the fifth result
     * @param <RF> the type of the sixth result
     * @return a completed DAG with 10 inputs (placeholders) and 6 outputs (outputs).
     */
    public <RA, RB, RC, RD, RE, RF> DAG10x6<A, B, C, D, E, F, G, H, I, J, RA, RB, RC, RD, RE, RF> withOutputs(
        Producer<? extends RA> output1, Producer<? extends RB> output2, Producer<? extends RC> output3,
        Producer<? extends RD> output4, Producer<? extends RE> output5, Producer<? extends RF> output6) {
      Objects.requireNonNull(output1, "Output 1 may not be null");
      Objects.requireNonNull(output2, "Output 2 may not be null");
      Objects.requireNonNull(output3, "Output 3 may not be null");
      Objects.requireNonNull(output4, "Output 4 may not be null");
      Objects.requireNonNull(output5, "Output 5 may not be null");
      Objects.requireNonNull(output6, "Output 6 may not be null");

      if (_shouldRemapInputs) {
        Map<Producer<?>, Producer<?>> inputMapping =
            DAGUtil.createInputMap(_input1, _placeholder1, _input2, _placeholder2, _input3, _placeholder3, _input4,
                _placeholder4, _input5, _placeholder5, _input6, _placeholder6, _input7, _placeholder7, _input8,
                _placeholder8, _input9, _placeholder9, _input10, _placeholder10);
        output1 = DAGUtil.replaceInputs(output1, inputMapping);
        output2 = DAGUtil.replaceInputs(output2, inputMapping);
        output3 = DAGUtil.replaceInputs(output3, inputMapping);
        output4 = DAGUtil.replaceInputs(output4, inputMapping);
        output5 = DAGUtil.replaceInputs(output5, inputMapping);
        output6 = DAGUtil.replaceInputs(output6, inputMapping);
      }

      List<Producer<?>> inputs =
          Arrays.asList(_input1, _input2, _input3, _input4, _input5, _input6, _input7, _input8, _input9, _input10);

      return ((DAG10x6) DAGUtil
          .createPreparableDAG(
              Arrays.asList(_placeholder1, _placeholder2, _placeholder3, _placeholder4, _placeholder5, _placeholder6,
                  _placeholder7, _placeholder8, _placeholder9, _placeholder10),
              Arrays.asList(output1, output2, output3, output4, output5, output6)).internalAPI()
          .withInputsUnsafe(inputs)).withReduction(_minimumReducerLevel);
    }

    /**
     * Creates a completed DAG by supplying this partial DAG with its outputs (outputs).
     *
     * @param output1 the first output (output) of the DAG
     * @param output2 the second output (output) of the DAG
     * @param output3 the third output (output) of the DAG
     * @param output4 the fourth output (output) of the DAG
     * @param output5 the fifth output (output) of the DAG
     * @param output6 the sixth output (output) of the DAG
     * @param output7 the seventh output (output) of the DAG
     * @param <RA> the type of the first result
     * @param <RB> the type of the second result
     * @param <RC> the type of the third result
     * @param <RD> the type of the fourth result
     * @param <RE> the type of the fifth result
     * @param <RF> the type of the sixth result
     * @param <RG> the type of the seventh result
     * @return a completed DAG with 10 inputs (placeholders) and 7 outputs (outputs).
     */
    public <RA, RB, RC, RD, RE, RF, RG> DAG10x7<A, B, C, D, E, F, G, H, I, J, RA, RB, RC, RD, RE, RF, RG> withOutputs(
        Producer<? extends RA> output1, Producer<? extends RB> output2, Producer<? extends RC> output3,
        Producer<? extends RD> output4, Producer<? extends RE> output5, Producer<? extends RF> output6,
        Producer<? extends RG> output7) {
      Objects.requireNonNull(output1, "Output 1 may not be null");
      Objects.requireNonNull(output2, "Output 2 may not be null");
      Objects.requireNonNull(output3, "Output 3 may not be null");
      Objects.requireNonNull(output4, "Output 4 may not be null");
      Objects.requireNonNull(output5, "Output 5 may not be null");
      Objects.requireNonNull(output6, "Output 6 may not be null");
      Objects.requireNonNull(output7, "Output 7 may not be null");

      if (_shouldRemapInputs) {
        Map<Producer<?>, Producer<?>> inputMapping =
            DAGUtil.createInputMap(_input1, _placeholder1, _input2, _placeholder2, _input3, _placeholder3, _input4,
                _placeholder4, _input5, _placeholder5, _input6, _placeholder6, _input7, _placeholder7, _input8,
                _placeholder8, _input9, _placeholder9, _input10, _placeholder10);
        output1 = DAGUtil.replaceInputs(output1, inputMapping);
        output2 = DAGUtil.replaceInputs(output2, inputMapping);
        output3 = DAGUtil.replaceInputs(output3, inputMapping);
        output4 = DAGUtil.replaceInputs(output4, inputMapping);
        output5 = DAGUtil.replaceInputs(output5, inputMapping);
        output6 = DAGUtil.replaceInputs(output6, inputMapping);
        output7 = DAGUtil.replaceInputs(output7, inputMapping);
      }

      List<Producer<?>> inputs =
          Arrays.asList(_input1, _input2, _input3, _input4, _input5, _input6, _input7, _input8, _input9, _input10);

      return ((DAG10x7) DAGUtil
          .createPreparableDAG(
              Arrays.asList(_placeholder1, _placeholder2, _placeholder3, _placeholder4, _placeholder5, _placeholder6,
                  _placeholder7, _placeholder8, _placeholder9, _placeholder10),
              Arrays.asList(output1, output2, output3, output4, output5, output6, output7)).internalAPI()
          .withInputsUnsafe(inputs)).withReduction(_minimumReducerLevel);
    }

    /**
     * Creates a completed DAG by supplying this partial DAG with its outputs (outputs).
     *
     * @param output1 the first output (output) of the DAG
     * @param output2 the second output (output) of the DAG
     * @param output3 the third output (output) of the DAG
     * @param output4 the fourth output (output) of the DAG
     * @param output5 the fifth output (output) of the DAG
     * @param output6 the sixth output (output) of the DAG
     * @param output7 the seventh output (output) of the DAG
     * @param output8 the eighth output (output) of the DAG
     * @param <RA> the type of the first result
     * @param <RB> the type of the second result
     * @param <RC> the type of the third result
     * @param <RD> the type of the fourth result
     * @param <RE> the type of the fifth result
     * @param <RF> the type of the sixth result
     * @param <RG> the type of the seventh result
     * @param <RH> the type of the eighth result
     * @return a completed DAG with 10 inputs (placeholders) and 8 outputs (outputs).
     */
    public <RA, RB, RC, RD, RE, RF, RG, RH> DAG10x8<A, B, C, D, E, F, G, H, I, J, RA, RB, RC, RD, RE, RF, RG, RH> withOutputs(
        Producer<? extends RA> output1, Producer<? extends RB> output2, Producer<? extends RC> output3,
        Producer<? extends RD> output4, Producer<? extends RE> output5, Producer<? extends RF> output6,
        Producer<? extends RG> output7, Producer<? extends RH> output8) {
      Objects.requireNonNull(output1, "Output 1 may not be null");
      Objects.requireNonNull(output2, "Output 2 may not be null");
      Objects.requireNonNull(output3, "Output 3 may not be null");
      Objects.requireNonNull(output4, "Output 4 may not be null");
      Objects.requireNonNull(output5, "Output 5 may not be null");
      Objects.requireNonNull(output6, "Output 6 may not be null");
      Objects.requireNonNull(output7, "Output 7 may not be null");
      Objects.requireNonNull(output8, "Output 8 may not be null");

      if (_shouldRemapInputs) {
        Map<Producer<?>, Producer<?>> inputMapping =
            DAGUtil.createInputMap(_input1, _placeholder1, _input2, _placeholder2, _input3, _placeholder3, _input4,
                _placeholder4, _input5, _placeholder5, _input6, _placeholder6, _input7, _placeholder7, _input8,
                _placeholder8, _input9, _placeholder9, _input10, _placeholder10);
        output1 = DAGUtil.replaceInputs(output1, inputMapping);
        output2 = DAGUtil.replaceInputs(output2, inputMapping);
        output3 = DAGUtil.replaceInputs(output3, inputMapping);
        output4 = DAGUtil.replaceInputs(output4, inputMapping);
        output5 = DAGUtil.replaceInputs(output5, inputMapping);
        output6 = DAGUtil.replaceInputs(output6, inputMapping);
        output7 = DAGUtil.replaceInputs(output7, inputMapping);
        output8 = DAGUtil.replaceInputs(output8, inputMapping);
      }

      List<Producer<?>> inputs =
          Arrays.asList(_input1, _input2, _input3, _input4, _input5, _input6, _input7, _input8, _input9, _input10);

      return ((DAG10x8) DAGUtil
          .createPreparableDAG(
              Arrays.asList(_placeholder1, _placeholder2, _placeholder3, _placeholder4, _placeholder5, _placeholder6,
                  _placeholder7, _placeholder8, _placeholder9, _placeholder10),
              Arrays.asList(output1, output2, output3, output4, output5, output6, output7, output8)).internalAPI()
          .withInputsUnsafe(inputs)).withReduction(_minimumReducerLevel);
    }

    /**
     * Creates a completed DAG by supplying this partial DAG with its outputs (outputs).
     *
     * @param output1 the first output (output) of the DAG
     * @param output2 the second output (output) of the DAG
     * @param output3 the third output (output) of the DAG
     * @param output4 the fourth output (output) of the DAG
     * @param output5 the fifth output (output) of the DAG
     * @param output6 the sixth output (output) of the DAG
     * @param output7 the seventh output (output) of the DAG
     * @param output8 the eighth output (output) of the DAG
     * @param output9 the ninth output (output) of the DAG
     * @param <RA> the type of the first result
     * @param <RB> the type of the second result
     * @param <RC> the type of the third result
     * @param <RD> the type of the fourth result
     * @param <RE> the type of the fifth result
     * @param <RF> the type of the sixth result
     * @param <RG> the type of the seventh result
     * @param <RH> the type of the eighth result
     * @param <RI> the type of the ninth result
     * @return a completed DAG with 10 inputs (placeholders) and 9 outputs (outputs).
     */
    public <RA, RB, RC, RD, RE, RF, RG, RH, RI> DAG10x9<A, B, C, D, E, F, G, H, I, J, RA, RB, RC, RD, RE, RF, RG, RH, RI> withOutputs(
        Producer<? extends RA> output1, Producer<? extends RB> output2, Producer<? extends RC> output3,
        Producer<? extends RD> output4, Producer<? extends RE> output5, Producer<? extends RF> output6,
        Producer<? extends RG> output7, Producer<? extends RH> output8, Producer<? extends RI> output9) {
      Objects.requireNonNull(output1, "Output 1 may not be null");
      Objects.requireNonNull(output2, "Output 2 may not be null");
      Objects.requireNonNull(output3, "Output 3 may not be null");
      Objects.requireNonNull(output4, "Output 4 may not be null");
      Objects.requireNonNull(output5, "Output 5 may not be null");
      Objects.requireNonNull(output6, "Output 6 may not be null");
      Objects.requireNonNull(output7, "Output 7 may not be null");
      Objects.requireNonNull(output8, "Output 8 may not be null");
      Objects.requireNonNull(output9, "Output 9 may not be null");

      if (_shouldRemapInputs) {
        Map<Producer<?>, Producer<?>> inputMapping =
            DAGUtil.createInputMap(_input1, _placeholder1, _input2, _placeholder2, _input3, _placeholder3, _input4,
                _placeholder4, _input5, _placeholder5, _input6, _placeholder6, _input7, _placeholder7, _input8,
                _placeholder8, _input9, _placeholder9, _input10, _placeholder10);
        output1 = DAGUtil.replaceInputs(output1, inputMapping);
        output2 = DAGUtil.replaceInputs(output2, inputMapping);
        output3 = DAGUtil.replaceInputs(output3, inputMapping);
        output4 = DAGUtil.replaceInputs(output4, inputMapping);
        output5 = DAGUtil.replaceInputs(output5, inputMapping);
        output6 = DAGUtil.replaceInputs(output6, inputMapping);
        output7 = DAGUtil.replaceInputs(output7, inputMapping);
        output8 = DAGUtil.replaceInputs(output8, inputMapping);
        output9 = DAGUtil.replaceInputs(output9, inputMapping);
      }

      List<Producer<?>> inputs =
          Arrays.asList(_input1, _input2, _input3, _input4, _input5, _input6, _input7, _input8, _input9, _input10);

      return ((DAG10x9) DAGUtil
          .createPreparableDAG(
              Arrays.asList(_placeholder1, _placeholder2, _placeholder3, _placeholder4, _placeholder5, _placeholder6,
                  _placeholder7, _placeholder8, _placeholder9, _placeholder10),
              Arrays.asList(output1, output2, output3, output4, output5, output6, output7, output8, output9))
          .internalAPI().withInputsUnsafe(inputs)).withReduction(_minimumReducerLevel);
    }

    /**
     * Creates a completed DAG by supplying this partial DAG with its outputs (outputs).
     *
     * @param output1 the first output (output) of the DAG
     * @param output2 the second output (output) of the DAG
     * @param output3 the third output (output) of the DAG
     * @param output4 the fourth output (output) of the DAG
     * @param output5 the fifth output (output) of the DAG
     * @param output6 the sixth output (output) of the DAG
     * @param output7 the seventh output (output) of the DAG
     * @param output8 the eighth output (output) of the DAG
     * @param output9 the ninth output (output) of the DAG
     * @param output10 the tenth output (output) of the DAG
     * @param <RA> the type of the first result
     * @param <RB> the type of the second result
     * @param <RC> the type of the third result
     * @param <RD> the type of the fourth result
     * @param <RE> the type of the fifth result
     * @param <RF> the type of the sixth result
     * @param <RG> the type of the seventh result
     * @param <RH> the type of the eighth result
     * @param <RI> the type of the ninth result
     * @param <RJ> the type of the tenth result
     * @return a completed DAG with 10 inputs (placeholders) and 10 outputs (outputs).
     */
    public <RA, RB, RC, RD, RE, RF, RG, RH, RI, RJ> DAG10x10<A, B, C, D, E, F, G, H, I, J, RA, RB, RC, RD, RE, RF, RG, RH, RI, RJ> withOutputs(
        Producer<? extends RA> output1, Producer<? extends RB> output2, Producer<? extends RC> output3,
        Producer<? extends RD> output4, Producer<? extends RE> output5, Producer<? extends RF> output6,
        Producer<? extends RG> output7, Producer<? extends RH> output8, Producer<? extends RI> output9,
        Producer<? extends RJ> output10) {
      Objects.requireNonNull(output1, "Output 1 may not be null");
      Objects.requireNonNull(output2, "Output 2 may not be null");
      Objects.requireNonNull(output3, "Output 3 may not be null");
      Objects.requireNonNull(output4, "Output 4 may not be null");
      Objects.requireNonNull(output5, "Output 5 may not be null");
      Objects.requireNonNull(output6, "Output 6 may not be null");
      Objects.requireNonNull(output7, "Output 7 may not be null");
      Objects.requireNonNull(output8, "Output 8 may not be null");
      Objects.requireNonNull(output9, "Output 9 may not be null");
      Objects.requireNonNull(output10, "Output 10 may not be null");

      if (_shouldRemapInputs) {
        Map<Producer<?>, Producer<?>> inputMapping =
            DAGUtil.createInputMap(_input1, _placeholder1, _input2, _placeholder2, _input3, _placeholder3, _input4,
                _placeholder4, _input5, _placeholder5, _input6, _placeholder6, _input7, _placeholder7, _input8,
                _placeholder8, _input9, _placeholder9, _input10, _placeholder10);
        output1 = DAGUtil.replaceInputs(output1, inputMapping);
        output2 = DAGUtil.replaceInputs(output2, inputMapping);
        output3 = DAGUtil.replaceInputs(output3, inputMapping);
        output4 = DAGUtil.replaceInputs(output4, inputMapping);
        output5 = DAGUtil.replaceInputs(output5, inputMapping);
        output6 = DAGUtil.replaceInputs(output6, inputMapping);
        output7 = DAGUtil.replaceInputs(output7, inputMapping);
        output8 = DAGUtil.replaceInputs(output8, inputMapping);
        output9 = DAGUtil.replaceInputs(output9, inputMapping);
        output10 = DAGUtil.replaceInputs(output10, inputMapping);
      }

      List<Producer<?>> inputs =
          Arrays.asList(_input1, _input2, _input3, _input4, _input5, _input6, _input7, _input8, _input9, _input10);

      return ((DAG10x10) DAGUtil
          .createPreparableDAG(
              Arrays.asList(_placeholder1, _placeholder2, _placeholder3, _placeholder4, _placeholder5, _placeholder6,
                  _placeholder7, _placeholder8, _placeholder9, _placeholder10),
              Arrays.asList(output1, output2, output3, output4, output5, output6, output7, output8, output9, output10))
          .internalAPI().withInputsUnsafe(inputs)).withReduction(_minimumReducerLevel);
    }
  }

  /**
   * The {@link Prepared} class hosts internal classes (mirroring those in the parent {@link PartialDAG} class) used to
   * build DAGs.
   */
  public static class Prepared {
    private Prepared() {
    }

    /**
      * A partial DAG with 1 placeholder.  Partial DAGs are <i>completed</i> to create a usable DAG by specifying
      * the outputs (<i>outputs</i>) of the DAG using the withOutputs(...) methods.
      *
     * @param <A> the type of the first input
      */
    public static class WithPlaceholders1<A> extends AbstractWithPlaceholders1<A, WithPlaceholders1<A>> {
      /**
       * Creates a new partial DAG that will be rooted at the provided placeholders.
       *
       * @param placeholder1 the first placeholder
       */
      WithPlaceholders1(Placeholder<? extends A> placeholder1) {
        super(placeholder1);
      }

      /**
       * Creates a new partial DAG that will be rooted at the provided placeholders, which will replace ("remap") the provided
       * "input" nodes that define a subgraph of the original graph (as defined by the ancestors of the outputs that will
       * be provided when the partial DAG is completed).  The input nodes, and any nodes that were exclusively the
       * ancestors of the input nodes, are truncated from the resulting graph.
       *
       * @param placeholder1 the first placeholder
       * @param input1 the first input
       */
      WithPlaceholders1(Placeholder<? extends A> placeholder1, Producer<? extends A> input1) {
        super(placeholder1, input1);
      }

      /**
       * Creates a completed DAG by supplying this partial DAG with its outputs (outputs).
       *
       * @param output1 the first output (output) of the DAG
       * @param <RA> the type of the first result
       * @return a completed DAG with 1 input (placeholders) and 1 output (outputs).
       */
      public <RA> DAG1x1.Prepared<A, RA> withOutputs(Producer<? extends RA> output1) {
        Objects.requireNonNull(output1, "Output 1 may not be null");

        if (_shouldRemapInputs) {
          Map<Producer<?>, Producer<?>> inputMapping = DAGUtil.createInputMap(_input1, _placeholder1);
          output1 = DAGUtil.replaceInputs(output1, inputMapping);
        }

        List<Producer<?>> inputs = Arrays.asList(_input1);

        return ((DAG1x1.Prepared) DAGUtil.createPreparedDAG(Arrays.asList(_placeholder1), Arrays.asList(output1))
            .internalAPI().withInputsUnsafe(inputs)).withReduction(_minimumReducerLevel);
      }

      /**
       * Creates a completed DAG by supplying this partial DAG with its outputs (outputs).
       *
       * @param output1 the first output (output) of the DAG
       * @param <RA> the type of the first result
       * @return a completed DAG with 1 input (placeholders) and 1 output (outputs).
       */
      public <RA> DAG1x1.Prepared<A, RA> withOutput(Producer<? extends RA> output1) {
        Objects.requireNonNull(output1, "Output 1 may not be null");

        if (_shouldRemapInputs) {
          Map<Producer<?>, Producer<?>> inputMapping = DAGUtil.createInputMap(_input1, _placeholder1);
          output1 = DAGUtil.replaceInputs(output1, inputMapping);
        }

        List<Producer<?>> inputs = Arrays.asList(_input1);

        return ((DAG1x1.Prepared) DAGUtil.createPreparedDAG(Arrays.asList(_placeholder1), Arrays.asList(output1))
            .internalAPI().withInputsUnsafe(inputs)).withReduction(_minimumReducerLevel);
      }

      /**
       * Creates a completed DAG by supplying this partial DAG with its outputs (outputs).
       *
       * @param output1 the first output (output) of the DAG
       * @param output2 the second output (output) of the DAG
       * @param <RA> the type of the first result
       * @param <RB> the type of the second result
       * @return a completed DAG with 1 input (placeholders) and 2 outputs (outputs).
       */
      public <RA, RB> DAG1x2.Prepared<A, RA, RB> withOutputs(Producer<? extends RA> output1,
          Producer<? extends RB> output2) {
        Objects.requireNonNull(output1, "Output 1 may not be null");
        Objects.requireNonNull(output2, "Output 2 may not be null");

        if (_shouldRemapInputs) {
          Map<Producer<?>, Producer<?>> inputMapping = DAGUtil.createInputMap(_input1, _placeholder1);
          output1 = DAGUtil.replaceInputs(output1, inputMapping);
          output2 = DAGUtil.replaceInputs(output2, inputMapping);
        }

        List<Producer<?>> inputs = Arrays.asList(_input1);

        return ((DAG1x2.Prepared) DAGUtil
            .createPreparedDAG(Arrays.asList(_placeholder1), Arrays.asList(output1, output2)).internalAPI()
            .withInputsUnsafe(inputs)).withReduction(_minimumReducerLevel);
      }

      /**
       * Creates a completed DAG by supplying this partial DAG with its outputs (outputs).
       *
       * @param output1 the first output (output) of the DAG
       * @param output2 the second output (output) of the DAG
       * @param output3 the third output (output) of the DAG
       * @param <RA> the type of the first result
       * @param <RB> the type of the second result
       * @param <RC> the type of the third result
       * @return a completed DAG with 1 input (placeholders) and 3 outputs (outputs).
       */
      public <RA, RB, RC> DAG1x3.Prepared<A, RA, RB, RC> withOutputs(Producer<? extends RA> output1,
          Producer<? extends RB> output2, Producer<? extends RC> output3) {
        Objects.requireNonNull(output1, "Output 1 may not be null");
        Objects.requireNonNull(output2, "Output 2 may not be null");
        Objects.requireNonNull(output3, "Output 3 may not be null");

        if (_shouldRemapInputs) {
          Map<Producer<?>, Producer<?>> inputMapping = DAGUtil.createInputMap(_input1, _placeholder1);
          output1 = DAGUtil.replaceInputs(output1, inputMapping);
          output2 = DAGUtil.replaceInputs(output2, inputMapping);
          output3 = DAGUtil.replaceInputs(output3, inputMapping);
        }

        List<Producer<?>> inputs = Arrays.asList(_input1);

        return ((DAG1x3.Prepared) DAGUtil
            .createPreparedDAG(Arrays.asList(_placeholder1), Arrays.asList(output1, output2, output3)).internalAPI()
            .withInputsUnsafe(inputs)).withReduction(_minimumReducerLevel);
      }

      /**
       * Creates a completed DAG by supplying this partial DAG with its outputs (outputs).
       *
       * @param output1 the first output (output) of the DAG
       * @param output2 the second output (output) of the DAG
       * @param output3 the third output (output) of the DAG
       * @param output4 the fourth output (output) of the DAG
       * @param <RA> the type of the first result
       * @param <RB> the type of the second result
       * @param <RC> the type of the third result
       * @param <RD> the type of the fourth result
       * @return a completed DAG with 1 input (placeholders) and 4 outputs (outputs).
       */
      public <RA, RB, RC, RD> DAG1x4.Prepared<A, RA, RB, RC, RD> withOutputs(Producer<? extends RA> output1,
          Producer<? extends RB> output2, Producer<? extends RC> output3, Producer<? extends RD> output4) {
        Objects.requireNonNull(output1, "Output 1 may not be null");
        Objects.requireNonNull(output2, "Output 2 may not be null");
        Objects.requireNonNull(output3, "Output 3 may not be null");
        Objects.requireNonNull(output4, "Output 4 may not be null");

        if (_shouldRemapInputs) {
          Map<Producer<?>, Producer<?>> inputMapping = DAGUtil.createInputMap(_input1, _placeholder1);
          output1 = DAGUtil.replaceInputs(output1, inputMapping);
          output2 = DAGUtil.replaceInputs(output2, inputMapping);
          output3 = DAGUtil.replaceInputs(output3, inputMapping);
          output4 = DAGUtil.replaceInputs(output4, inputMapping);
        }

        List<Producer<?>> inputs = Arrays.asList(_input1);

        return ((DAG1x4.Prepared) DAGUtil
            .createPreparedDAG(Arrays.asList(_placeholder1), Arrays.asList(output1, output2, output3, output4))
            .internalAPI().withInputsUnsafe(inputs)).withReduction(_minimumReducerLevel);
      }

      /**
       * Creates a completed DAG by supplying this partial DAG with its outputs (outputs).
       *
       * @param output1 the first output (output) of the DAG
       * @param output2 the second output (output) of the DAG
       * @param output3 the third output (output) of the DAG
       * @param output4 the fourth output (output) of the DAG
       * @param output5 the fifth output (output) of the DAG
       * @param <RA> the type of the first result
       * @param <RB> the type of the second result
       * @param <RC> the type of the third result
       * @param <RD> the type of the fourth result
       * @param <RE> the type of the fifth result
       * @return a completed DAG with 1 input (placeholders) and 5 outputs (outputs).
       */
      public <RA, RB, RC, RD, RE> DAG1x5.Prepared<A, RA, RB, RC, RD, RE> withOutputs(Producer<? extends RA> output1,
          Producer<? extends RB> output2, Producer<? extends RC> output3, Producer<? extends RD> output4,
          Producer<? extends RE> output5) {
        Objects.requireNonNull(output1, "Output 1 may not be null");
        Objects.requireNonNull(output2, "Output 2 may not be null");
        Objects.requireNonNull(output3, "Output 3 may not be null");
        Objects.requireNonNull(output4, "Output 4 may not be null");
        Objects.requireNonNull(output5, "Output 5 may not be null");

        if (_shouldRemapInputs) {
          Map<Producer<?>, Producer<?>> inputMapping = DAGUtil.createInputMap(_input1, _placeholder1);
          output1 = DAGUtil.replaceInputs(output1, inputMapping);
          output2 = DAGUtil.replaceInputs(output2, inputMapping);
          output3 = DAGUtil.replaceInputs(output3, inputMapping);
          output4 = DAGUtil.replaceInputs(output4, inputMapping);
          output5 = DAGUtil.replaceInputs(output5, inputMapping);
        }

        List<Producer<?>> inputs = Arrays.asList(_input1);

        return ((DAG1x5.Prepared) DAGUtil
            .createPreparedDAG(Arrays.asList(_placeholder1), Arrays.asList(output1, output2, output3, output4, output5))
            .internalAPI().withInputsUnsafe(inputs)).withReduction(_minimumReducerLevel);
      }

      /**
       * Creates a completed DAG by supplying this partial DAG with its outputs (outputs).
       *
       * @param output1 the first output (output) of the DAG
       * @param output2 the second output (output) of the DAG
       * @param output3 the third output (output) of the DAG
       * @param output4 the fourth output (output) of the DAG
       * @param output5 the fifth output (output) of the DAG
       * @param output6 the sixth output (output) of the DAG
       * @param <RA> the type of the first result
       * @param <RB> the type of the second result
       * @param <RC> the type of the third result
       * @param <RD> the type of the fourth result
       * @param <RE> the type of the fifth result
       * @param <RF> the type of the sixth result
       * @return a completed DAG with 1 input (placeholders) and 6 outputs (outputs).
       */
      public <RA, RB, RC, RD, RE, RF> DAG1x6.Prepared<A, RA, RB, RC, RD, RE, RF> withOutputs(
          Producer<? extends RA> output1, Producer<? extends RB> output2, Producer<? extends RC> output3,
          Producer<? extends RD> output4, Producer<? extends RE> output5, Producer<? extends RF> output6) {
        Objects.requireNonNull(output1, "Output 1 may not be null");
        Objects.requireNonNull(output2, "Output 2 may not be null");
        Objects.requireNonNull(output3, "Output 3 may not be null");
        Objects.requireNonNull(output4, "Output 4 may not be null");
        Objects.requireNonNull(output5, "Output 5 may not be null");
        Objects.requireNonNull(output6, "Output 6 may not be null");

        if (_shouldRemapInputs) {
          Map<Producer<?>, Producer<?>> inputMapping = DAGUtil.createInputMap(_input1, _placeholder1);
          output1 = DAGUtil.replaceInputs(output1, inputMapping);
          output2 = DAGUtil.replaceInputs(output2, inputMapping);
          output3 = DAGUtil.replaceInputs(output3, inputMapping);
          output4 = DAGUtil.replaceInputs(output4, inputMapping);
          output5 = DAGUtil.replaceInputs(output5, inputMapping);
          output6 = DAGUtil.replaceInputs(output6, inputMapping);
        }

        List<Producer<?>> inputs = Arrays.asList(_input1);

        return ((DAG1x6.Prepared) DAGUtil
            .createPreparedDAG(Arrays.asList(_placeholder1),
                Arrays.asList(output1, output2, output3, output4, output5, output6)).internalAPI()
            .withInputsUnsafe(inputs)).withReduction(_minimumReducerLevel);
      }

      /**
       * Creates a completed DAG by supplying this partial DAG with its outputs (outputs).
       *
       * @param output1 the first output (output) of the DAG
       * @param output2 the second output (output) of the DAG
       * @param output3 the third output (output) of the DAG
       * @param output4 the fourth output (output) of the DAG
       * @param output5 the fifth output (output) of the DAG
       * @param output6 the sixth output (output) of the DAG
       * @param output7 the seventh output (output) of the DAG
       * @param <RA> the type of the first result
       * @param <RB> the type of the second result
       * @param <RC> the type of the third result
       * @param <RD> the type of the fourth result
       * @param <RE> the type of the fifth result
       * @param <RF> the type of the sixth result
       * @param <RG> the type of the seventh result
       * @return a completed DAG with 1 input (placeholders) and 7 outputs (outputs).
       */
      public <RA, RB, RC, RD, RE, RF, RG> DAG1x7.Prepared<A, RA, RB, RC, RD, RE, RF, RG> withOutputs(
          Producer<? extends RA> output1, Producer<? extends RB> output2, Producer<? extends RC> output3,
          Producer<? extends RD> output4, Producer<? extends RE> output5, Producer<? extends RF> output6,
          Producer<? extends RG> output7) {
        Objects.requireNonNull(output1, "Output 1 may not be null");
        Objects.requireNonNull(output2, "Output 2 may not be null");
        Objects.requireNonNull(output3, "Output 3 may not be null");
        Objects.requireNonNull(output4, "Output 4 may not be null");
        Objects.requireNonNull(output5, "Output 5 may not be null");
        Objects.requireNonNull(output6, "Output 6 may not be null");
        Objects.requireNonNull(output7, "Output 7 may not be null");

        if (_shouldRemapInputs) {
          Map<Producer<?>, Producer<?>> inputMapping = DAGUtil.createInputMap(_input1, _placeholder1);
          output1 = DAGUtil.replaceInputs(output1, inputMapping);
          output2 = DAGUtil.replaceInputs(output2, inputMapping);
          output3 = DAGUtil.replaceInputs(output3, inputMapping);
          output4 = DAGUtil.replaceInputs(output4, inputMapping);
          output5 = DAGUtil.replaceInputs(output5, inputMapping);
          output6 = DAGUtil.replaceInputs(output6, inputMapping);
          output7 = DAGUtil.replaceInputs(output7, inputMapping);
        }

        List<Producer<?>> inputs = Arrays.asList(_input1);

        return ((DAG1x7.Prepared) DAGUtil
            .createPreparedDAG(Arrays.asList(_placeholder1),
                Arrays.asList(output1, output2, output3, output4, output5, output6, output7)).internalAPI()
            .withInputsUnsafe(inputs)).withReduction(_minimumReducerLevel);
      }

      /**
       * Creates a completed DAG by supplying this partial DAG with its outputs (outputs).
       *
       * @param output1 the first output (output) of the DAG
       * @param output2 the second output (output) of the DAG
       * @param output3 the third output (output) of the DAG
       * @param output4 the fourth output (output) of the DAG
       * @param output5 the fifth output (output) of the DAG
       * @param output6 the sixth output (output) of the DAG
       * @param output7 the seventh output (output) of the DAG
       * @param output8 the eighth output (output) of the DAG
       * @param <RA> the type of the first result
       * @param <RB> the type of the second result
       * @param <RC> the type of the third result
       * @param <RD> the type of the fourth result
       * @param <RE> the type of the fifth result
       * @param <RF> the type of the sixth result
       * @param <RG> the type of the seventh result
       * @param <RH> the type of the eighth result
       * @return a completed DAG with 1 input (placeholders) and 8 outputs (outputs).
       */
      public <RA, RB, RC, RD, RE, RF, RG, RH> DAG1x8.Prepared<A, RA, RB, RC, RD, RE, RF, RG, RH> withOutputs(
          Producer<? extends RA> output1, Producer<? extends RB> output2, Producer<? extends RC> output3,
          Producer<? extends RD> output4, Producer<? extends RE> output5, Producer<? extends RF> output6,
          Producer<? extends RG> output7, Producer<? extends RH> output8) {
        Objects.requireNonNull(output1, "Output 1 may not be null");
        Objects.requireNonNull(output2, "Output 2 may not be null");
        Objects.requireNonNull(output3, "Output 3 may not be null");
        Objects.requireNonNull(output4, "Output 4 may not be null");
        Objects.requireNonNull(output5, "Output 5 may not be null");
        Objects.requireNonNull(output6, "Output 6 may not be null");
        Objects.requireNonNull(output7, "Output 7 may not be null");
        Objects.requireNonNull(output8, "Output 8 may not be null");

        if (_shouldRemapInputs) {
          Map<Producer<?>, Producer<?>> inputMapping = DAGUtil.createInputMap(_input1, _placeholder1);
          output1 = DAGUtil.replaceInputs(output1, inputMapping);
          output2 = DAGUtil.replaceInputs(output2, inputMapping);
          output3 = DAGUtil.replaceInputs(output3, inputMapping);
          output4 = DAGUtil.replaceInputs(output4, inputMapping);
          output5 = DAGUtil.replaceInputs(output5, inputMapping);
          output6 = DAGUtil.replaceInputs(output6, inputMapping);
          output7 = DAGUtil.replaceInputs(output7, inputMapping);
          output8 = DAGUtil.replaceInputs(output8, inputMapping);
        }

        List<Producer<?>> inputs = Arrays.asList(_input1);

        return ((DAG1x8.Prepared) DAGUtil
            .createPreparedDAG(Arrays.asList(_placeholder1),
                Arrays.asList(output1, output2, output3, output4, output5, output6, output7, output8)).internalAPI()
            .withInputsUnsafe(inputs)).withReduction(_minimumReducerLevel);
      }

      /**
       * Creates a completed DAG by supplying this partial DAG with its outputs (outputs).
       *
       * @param output1 the first output (output) of the DAG
       * @param output2 the second output (output) of the DAG
       * @param output3 the third output (output) of the DAG
       * @param output4 the fourth output (output) of the DAG
       * @param output5 the fifth output (output) of the DAG
       * @param output6 the sixth output (output) of the DAG
       * @param output7 the seventh output (output) of the DAG
       * @param output8 the eighth output (output) of the DAG
       * @param output9 the ninth output (output) of the DAG
       * @param <RA> the type of the first result
       * @param <RB> the type of the second result
       * @param <RC> the type of the third result
       * @param <RD> the type of the fourth result
       * @param <RE> the type of the fifth result
       * @param <RF> the type of the sixth result
       * @param <RG> the type of the seventh result
       * @param <RH> the type of the eighth result
       * @param <RI> the type of the ninth result
       * @return a completed DAG with 1 input (placeholders) and 9 outputs (outputs).
       */
      public <RA, RB, RC, RD, RE, RF, RG, RH, RI> DAG1x9.Prepared<A, RA, RB, RC, RD, RE, RF, RG, RH, RI> withOutputs(
          Producer<? extends RA> output1, Producer<? extends RB> output2, Producer<? extends RC> output3,
          Producer<? extends RD> output4, Producer<? extends RE> output5, Producer<? extends RF> output6,
          Producer<? extends RG> output7, Producer<? extends RH> output8, Producer<? extends RI> output9) {
        Objects.requireNonNull(output1, "Output 1 may not be null");
        Objects.requireNonNull(output2, "Output 2 may not be null");
        Objects.requireNonNull(output3, "Output 3 may not be null");
        Objects.requireNonNull(output4, "Output 4 may not be null");
        Objects.requireNonNull(output5, "Output 5 may not be null");
        Objects.requireNonNull(output6, "Output 6 may not be null");
        Objects.requireNonNull(output7, "Output 7 may not be null");
        Objects.requireNonNull(output8, "Output 8 may not be null");
        Objects.requireNonNull(output9, "Output 9 may not be null");

        if (_shouldRemapInputs) {
          Map<Producer<?>, Producer<?>> inputMapping = DAGUtil.createInputMap(_input1, _placeholder1);
          output1 = DAGUtil.replaceInputs(output1, inputMapping);
          output2 = DAGUtil.replaceInputs(output2, inputMapping);
          output3 = DAGUtil.replaceInputs(output3, inputMapping);
          output4 = DAGUtil.replaceInputs(output4, inputMapping);
          output5 = DAGUtil.replaceInputs(output5, inputMapping);
          output6 = DAGUtil.replaceInputs(output6, inputMapping);
          output7 = DAGUtil.replaceInputs(output7, inputMapping);
          output8 = DAGUtil.replaceInputs(output8, inputMapping);
          output9 = DAGUtil.replaceInputs(output9, inputMapping);
        }

        List<Producer<?>> inputs = Arrays.asList(_input1);

        return ((DAG1x9.Prepared) DAGUtil
            .createPreparedDAG(Arrays.asList(_placeholder1),
                Arrays.asList(output1, output2, output3, output4, output5, output6, output7, output8, output9))
            .internalAPI().withInputsUnsafe(inputs)).withReduction(_minimumReducerLevel);
      }

      /**
       * Creates a completed DAG by supplying this partial DAG with its outputs (outputs).
       *
       * @param output1 the first output (output) of the DAG
       * @param output2 the second output (output) of the DAG
       * @param output3 the third output (output) of the DAG
       * @param output4 the fourth output (output) of the DAG
       * @param output5 the fifth output (output) of the DAG
       * @param output6 the sixth output (output) of the DAG
       * @param output7 the seventh output (output) of the DAG
       * @param output8 the eighth output (output) of the DAG
       * @param output9 the ninth output (output) of the DAG
       * @param output10 the tenth output (output) of the DAG
       * @param <RA> the type of the first result
       * @param <RB> the type of the second result
       * @param <RC> the type of the third result
       * @param <RD> the type of the fourth result
       * @param <RE> the type of the fifth result
       * @param <RF> the type of the sixth result
       * @param <RG> the type of the seventh result
       * @param <RH> the type of the eighth result
       * @param <RI> the type of the ninth result
       * @param <RJ> the type of the tenth result
       * @return a completed DAG with 1 input (placeholders) and 10 outputs (outputs).
       */
      public <RA, RB, RC, RD, RE, RF, RG, RH, RI, RJ> DAG1x10.Prepared<A, RA, RB, RC, RD, RE, RF, RG, RH, RI, RJ> withOutputs(
          Producer<? extends RA> output1, Producer<? extends RB> output2, Producer<? extends RC> output3,
          Producer<? extends RD> output4, Producer<? extends RE> output5, Producer<? extends RF> output6,
          Producer<? extends RG> output7, Producer<? extends RH> output8, Producer<? extends RI> output9,
          Producer<? extends RJ> output10) {
        Objects.requireNonNull(output1, "Output 1 may not be null");
        Objects.requireNonNull(output2, "Output 2 may not be null");
        Objects.requireNonNull(output3, "Output 3 may not be null");
        Objects.requireNonNull(output4, "Output 4 may not be null");
        Objects.requireNonNull(output5, "Output 5 may not be null");
        Objects.requireNonNull(output6, "Output 6 may not be null");
        Objects.requireNonNull(output7, "Output 7 may not be null");
        Objects.requireNonNull(output8, "Output 8 may not be null");
        Objects.requireNonNull(output9, "Output 9 may not be null");
        Objects.requireNonNull(output10, "Output 10 may not be null");

        if (_shouldRemapInputs) {
          Map<Producer<?>, Producer<?>> inputMapping = DAGUtil.createInputMap(_input1, _placeholder1);
          output1 = DAGUtil.replaceInputs(output1, inputMapping);
          output2 = DAGUtil.replaceInputs(output2, inputMapping);
          output3 = DAGUtil.replaceInputs(output3, inputMapping);
          output4 = DAGUtil.replaceInputs(output4, inputMapping);
          output5 = DAGUtil.replaceInputs(output5, inputMapping);
          output6 = DAGUtil.replaceInputs(output6, inputMapping);
          output7 = DAGUtil.replaceInputs(output7, inputMapping);
          output8 = DAGUtil.replaceInputs(output8, inputMapping);
          output9 = DAGUtil.replaceInputs(output9, inputMapping);
          output10 = DAGUtil.replaceInputs(output10, inputMapping);
        }

        List<Producer<?>> inputs = Arrays.asList(_input1);

        return ((DAG1x10.Prepared) DAGUtil
            .createPreparedDAG(
                Arrays.asList(_placeholder1),
                Arrays
                    .asList(output1, output2, output3, output4, output5, output6, output7, output8, output9, output10))
            .internalAPI().withInputsUnsafe(inputs)).withReduction(_minimumReducerLevel);
      }
    }

    /**
      * A partial DAG with 2 placeholder.  Partial DAGs are <i>completed</i> to create a usable DAG by specifying
      * the outputs (<i>outputs</i>) of the DAG using the withOutputs(...) methods.
      *
     * @param <A> the type of the first input
     * @param <B> the type of the second input
      */
    public static class WithPlaceholders2<A, B> extends AbstractWithPlaceholders2<A, B, WithPlaceholders2<A, B>> {
      /**
       * Creates a new partial DAG that will be rooted at the provided placeholders.
       *
       * @param placeholder1 the first placeholder
       * @param placeholder2 the second placeholder
       */
      WithPlaceholders2(Placeholder<? extends A> placeholder1, Placeholder<? extends B> placeholder2) {
        super(placeholder1, placeholder2);
      }

      /**
       * Creates a new partial DAG that will be rooted at the provided placeholders, which will replace ("remap") the provided
       * "input" nodes that define a subgraph of the original graph (as defined by the ancestors of the outputs that will
       * be provided when the partial DAG is completed).  The input nodes, and any nodes that were exclusively the
       * ancestors of the input nodes, are truncated from the resulting graph.
       *
       * @param placeholder1 the first placeholder
       * @param placeholder2 the second placeholder
       * @param input1 the first input
       * @param input2 the second input
       */
      WithPlaceholders2(Placeholder<? extends A> placeholder1, Placeholder<? extends B> placeholder2,
          Producer<? extends A> input1, Producer<? extends B> input2) {
        super(placeholder1, placeholder2, input1, input2);
      }

      /**
       * Creates a completed DAG by supplying this partial DAG with its outputs (outputs).
       *
       * @param output1 the first output (output) of the DAG
       * @param <RA> the type of the first result
       * @return a completed DAG with 2 inputs (placeholders) and 1 output (outputs).
       */
      public <RA> DAG2x1.Prepared<A, B, RA> withOutputs(Producer<? extends RA> output1) {
        Objects.requireNonNull(output1, "Output 1 may not be null");

        if (_shouldRemapInputs) {
          Map<Producer<?>, Producer<?>> inputMapping =
              DAGUtil.createInputMap(_input1, _placeholder1, _input2, _placeholder2);
          output1 = DAGUtil.replaceInputs(output1, inputMapping);
        }

        List<Producer<?>> inputs = Arrays.asList(_input1, _input2);

        return ((DAG2x1.Prepared) DAGUtil
            .createPreparedDAG(Arrays.asList(_placeholder1, _placeholder2), Arrays.asList(output1)).internalAPI()
            .withInputsUnsafe(inputs)).withReduction(_minimumReducerLevel);
      }

      /**
       * Creates a completed DAG by supplying this partial DAG with its outputs (outputs).
       *
       * @param output1 the first output (output) of the DAG
       * @param <RA> the type of the first result
       * @return a completed DAG with 2 inputs (placeholders) and 1 output (outputs).
       */
      public <RA> DAG2x1.Prepared<A, B, RA> withOutput(Producer<? extends RA> output1) {
        Objects.requireNonNull(output1, "Output 1 may not be null");

        if (_shouldRemapInputs) {
          Map<Producer<?>, Producer<?>> inputMapping =
              DAGUtil.createInputMap(_input1, _placeholder1, _input2, _placeholder2);
          output1 = DAGUtil.replaceInputs(output1, inputMapping);
        }

        List<Producer<?>> inputs = Arrays.asList(_input1, _input2);

        return ((DAG2x1.Prepared) DAGUtil
            .createPreparedDAG(Arrays.asList(_placeholder1, _placeholder2), Arrays.asList(output1)).internalAPI()
            .withInputsUnsafe(inputs)).withReduction(_minimumReducerLevel);
      }

      /**
       * Creates a completed DAG by supplying this partial DAG with its outputs (outputs).
       *
       * @param output1 the first output (output) of the DAG
       * @param output2 the second output (output) of the DAG
       * @param <RA> the type of the first result
       * @param <RB> the type of the second result
       * @return a completed DAG with 2 inputs (placeholders) and 2 outputs (outputs).
       */
      public <RA, RB> DAG2x2.Prepared<A, B, RA, RB> withOutputs(Producer<? extends RA> output1,
          Producer<? extends RB> output2) {
        Objects.requireNonNull(output1, "Output 1 may not be null");
        Objects.requireNonNull(output2, "Output 2 may not be null");

        if (_shouldRemapInputs) {
          Map<Producer<?>, Producer<?>> inputMapping =
              DAGUtil.createInputMap(_input1, _placeholder1, _input2, _placeholder2);
          output1 = DAGUtil.replaceInputs(output1, inputMapping);
          output2 = DAGUtil.replaceInputs(output2, inputMapping);
        }

        List<Producer<?>> inputs = Arrays.asList(_input1, _input2);

        return ((DAG2x2.Prepared) DAGUtil
            .createPreparedDAG(Arrays.asList(_placeholder1, _placeholder2), Arrays.asList(output1, output2))
            .internalAPI().withInputsUnsafe(inputs)).withReduction(_minimumReducerLevel);
      }

      /**
       * Creates a completed DAG by supplying this partial DAG with its outputs (outputs).
       *
       * @param output1 the first output (output) of the DAG
       * @param output2 the second output (output) of the DAG
       * @param output3 the third output (output) of the DAG
       * @param <RA> the type of the first result
       * @param <RB> the type of the second result
       * @param <RC> the type of the third result
       * @return a completed DAG with 2 inputs (placeholders) and 3 outputs (outputs).
       */
      public <RA, RB, RC> DAG2x3.Prepared<A, B, RA, RB, RC> withOutputs(Producer<? extends RA> output1,
          Producer<? extends RB> output2, Producer<? extends RC> output3) {
        Objects.requireNonNull(output1, "Output 1 may not be null");
        Objects.requireNonNull(output2, "Output 2 may not be null");
        Objects.requireNonNull(output3, "Output 3 may not be null");

        if (_shouldRemapInputs) {
          Map<Producer<?>, Producer<?>> inputMapping =
              DAGUtil.createInputMap(_input1, _placeholder1, _input2, _placeholder2);
          output1 = DAGUtil.replaceInputs(output1, inputMapping);
          output2 = DAGUtil.replaceInputs(output2, inputMapping);
          output3 = DAGUtil.replaceInputs(output3, inputMapping);
        }

        List<Producer<?>> inputs = Arrays.asList(_input1, _input2);

        return ((DAG2x3.Prepared) DAGUtil
            .createPreparedDAG(Arrays.asList(_placeholder1, _placeholder2), Arrays.asList(output1, output2, output3))
            .internalAPI().withInputsUnsafe(inputs)).withReduction(_minimumReducerLevel);
      }

      /**
       * Creates a completed DAG by supplying this partial DAG with its outputs (outputs).
       *
       * @param output1 the first output (output) of the DAG
       * @param output2 the second output (output) of the DAG
       * @param output3 the third output (output) of the DAG
       * @param output4 the fourth output (output) of the DAG
       * @param <RA> the type of the first result
       * @param <RB> the type of the second result
       * @param <RC> the type of the third result
       * @param <RD> the type of the fourth result
       * @return a completed DAG with 2 inputs (placeholders) and 4 outputs (outputs).
       */
      public <RA, RB, RC, RD> DAG2x4.Prepared<A, B, RA, RB, RC, RD> withOutputs(Producer<? extends RA> output1,
          Producer<? extends RB> output2, Producer<? extends RC> output3, Producer<? extends RD> output4) {
        Objects.requireNonNull(output1, "Output 1 may not be null");
        Objects.requireNonNull(output2, "Output 2 may not be null");
        Objects.requireNonNull(output3, "Output 3 may not be null");
        Objects.requireNonNull(output4, "Output 4 may not be null");

        if (_shouldRemapInputs) {
          Map<Producer<?>, Producer<?>> inputMapping =
              DAGUtil.createInputMap(_input1, _placeholder1, _input2, _placeholder2);
          output1 = DAGUtil.replaceInputs(output1, inputMapping);
          output2 = DAGUtil.replaceInputs(output2, inputMapping);
          output3 = DAGUtil.replaceInputs(output3, inputMapping);
          output4 = DAGUtil.replaceInputs(output4, inputMapping);
        }

        List<Producer<?>> inputs = Arrays.asList(_input1, _input2);

        return ((DAG2x4.Prepared) DAGUtil
            .createPreparedDAG(Arrays.asList(_placeholder1, _placeholder2),
                Arrays.asList(output1, output2, output3, output4)).internalAPI().withInputsUnsafe(inputs))
            .withReduction(_minimumReducerLevel);
      }

      /**
       * Creates a completed DAG by supplying this partial DAG with its outputs (outputs).
       *
       * @param output1 the first output (output) of the DAG
       * @param output2 the second output (output) of the DAG
       * @param output3 the third output (output) of the DAG
       * @param output4 the fourth output (output) of the DAG
       * @param output5 the fifth output (output) of the DAG
       * @param <RA> the type of the first result
       * @param <RB> the type of the second result
       * @param <RC> the type of the third result
       * @param <RD> the type of the fourth result
       * @param <RE> the type of the fifth result
       * @return a completed DAG with 2 inputs (placeholders) and 5 outputs (outputs).
       */
      public <RA, RB, RC, RD, RE> DAG2x5.Prepared<A, B, RA, RB, RC, RD, RE> withOutputs(Producer<? extends RA> output1,
          Producer<? extends RB> output2, Producer<? extends RC> output3, Producer<? extends RD> output4,
          Producer<? extends RE> output5) {
        Objects.requireNonNull(output1, "Output 1 may not be null");
        Objects.requireNonNull(output2, "Output 2 may not be null");
        Objects.requireNonNull(output3, "Output 3 may not be null");
        Objects.requireNonNull(output4, "Output 4 may not be null");
        Objects.requireNonNull(output5, "Output 5 may not be null");

        if (_shouldRemapInputs) {
          Map<Producer<?>, Producer<?>> inputMapping =
              DAGUtil.createInputMap(_input1, _placeholder1, _input2, _placeholder2);
          output1 = DAGUtil.replaceInputs(output1, inputMapping);
          output2 = DAGUtil.replaceInputs(output2, inputMapping);
          output3 = DAGUtil.replaceInputs(output3, inputMapping);
          output4 = DAGUtil.replaceInputs(output4, inputMapping);
          output5 = DAGUtil.replaceInputs(output5, inputMapping);
        }

        List<Producer<?>> inputs = Arrays.asList(_input1, _input2);

        return ((DAG2x5.Prepared) DAGUtil
            .createPreparedDAG(Arrays.asList(_placeholder1, _placeholder2),
                Arrays.asList(output1, output2, output3, output4, output5)).internalAPI().withInputsUnsafe(inputs))
            .withReduction(_minimumReducerLevel);
      }

      /**
       * Creates a completed DAG by supplying this partial DAG with its outputs (outputs).
       *
       * @param output1 the first output (output) of the DAG
       * @param output2 the second output (output) of the DAG
       * @param output3 the third output (output) of the DAG
       * @param output4 the fourth output (output) of the DAG
       * @param output5 the fifth output (output) of the DAG
       * @param output6 the sixth output (output) of the DAG
       * @param <RA> the type of the first result
       * @param <RB> the type of the second result
       * @param <RC> the type of the third result
       * @param <RD> the type of the fourth result
       * @param <RE> the type of the fifth result
       * @param <RF> the type of the sixth result
       * @return a completed DAG with 2 inputs (placeholders) and 6 outputs (outputs).
       */
      public <RA, RB, RC, RD, RE, RF> DAG2x6.Prepared<A, B, RA, RB, RC, RD, RE, RF> withOutputs(
          Producer<? extends RA> output1, Producer<? extends RB> output2, Producer<? extends RC> output3,
          Producer<? extends RD> output4, Producer<? extends RE> output5, Producer<? extends RF> output6) {
        Objects.requireNonNull(output1, "Output 1 may not be null");
        Objects.requireNonNull(output2, "Output 2 may not be null");
        Objects.requireNonNull(output3, "Output 3 may not be null");
        Objects.requireNonNull(output4, "Output 4 may not be null");
        Objects.requireNonNull(output5, "Output 5 may not be null");
        Objects.requireNonNull(output6, "Output 6 may not be null");

        if (_shouldRemapInputs) {
          Map<Producer<?>, Producer<?>> inputMapping =
              DAGUtil.createInputMap(_input1, _placeholder1, _input2, _placeholder2);
          output1 = DAGUtil.replaceInputs(output1, inputMapping);
          output2 = DAGUtil.replaceInputs(output2, inputMapping);
          output3 = DAGUtil.replaceInputs(output3, inputMapping);
          output4 = DAGUtil.replaceInputs(output4, inputMapping);
          output5 = DAGUtil.replaceInputs(output5, inputMapping);
          output6 = DAGUtil.replaceInputs(output6, inputMapping);
        }

        List<Producer<?>> inputs = Arrays.asList(_input1, _input2);

        return ((DAG2x6.Prepared) DAGUtil
            .createPreparedDAG(Arrays.asList(_placeholder1, _placeholder2),
                Arrays.asList(output1, output2, output3, output4, output5, output6)).internalAPI()
            .withInputsUnsafe(inputs)).withReduction(_minimumReducerLevel);
      }

      /**
       * Creates a completed DAG by supplying this partial DAG with its outputs (outputs).
       *
       * @param output1 the first output (output) of the DAG
       * @param output2 the second output (output) of the DAG
       * @param output3 the third output (output) of the DAG
       * @param output4 the fourth output (output) of the DAG
       * @param output5 the fifth output (output) of the DAG
       * @param output6 the sixth output (output) of the DAG
       * @param output7 the seventh output (output) of the DAG
       * @param <RA> the type of the first result
       * @param <RB> the type of the second result
       * @param <RC> the type of the third result
       * @param <RD> the type of the fourth result
       * @param <RE> the type of the fifth result
       * @param <RF> the type of the sixth result
       * @param <RG> the type of the seventh result
       * @return a completed DAG with 2 inputs (placeholders) and 7 outputs (outputs).
       */
      public <RA, RB, RC, RD, RE, RF, RG> DAG2x7.Prepared<A, B, RA, RB, RC, RD, RE, RF, RG> withOutputs(
          Producer<? extends RA> output1, Producer<? extends RB> output2, Producer<? extends RC> output3,
          Producer<? extends RD> output4, Producer<? extends RE> output5, Producer<? extends RF> output6,
          Producer<? extends RG> output7) {
        Objects.requireNonNull(output1, "Output 1 may not be null");
        Objects.requireNonNull(output2, "Output 2 may not be null");
        Objects.requireNonNull(output3, "Output 3 may not be null");
        Objects.requireNonNull(output4, "Output 4 may not be null");
        Objects.requireNonNull(output5, "Output 5 may not be null");
        Objects.requireNonNull(output6, "Output 6 may not be null");
        Objects.requireNonNull(output7, "Output 7 may not be null");

        if (_shouldRemapInputs) {
          Map<Producer<?>, Producer<?>> inputMapping =
              DAGUtil.createInputMap(_input1, _placeholder1, _input2, _placeholder2);
          output1 = DAGUtil.replaceInputs(output1, inputMapping);
          output2 = DAGUtil.replaceInputs(output2, inputMapping);
          output3 = DAGUtil.replaceInputs(output3, inputMapping);
          output4 = DAGUtil.replaceInputs(output4, inputMapping);
          output5 = DAGUtil.replaceInputs(output5, inputMapping);
          output6 = DAGUtil.replaceInputs(output6, inputMapping);
          output7 = DAGUtil.replaceInputs(output7, inputMapping);
        }

        List<Producer<?>> inputs = Arrays.asList(_input1, _input2);

        return ((DAG2x7.Prepared) DAGUtil
            .createPreparedDAG(Arrays.asList(_placeholder1, _placeholder2),
                Arrays.asList(output1, output2, output3, output4, output5, output6, output7)).internalAPI()
            .withInputsUnsafe(inputs)).withReduction(_minimumReducerLevel);
      }

      /**
       * Creates a completed DAG by supplying this partial DAG with its outputs (outputs).
       *
       * @param output1 the first output (output) of the DAG
       * @param output2 the second output (output) of the DAG
       * @param output3 the third output (output) of the DAG
       * @param output4 the fourth output (output) of the DAG
       * @param output5 the fifth output (output) of the DAG
       * @param output6 the sixth output (output) of the DAG
       * @param output7 the seventh output (output) of the DAG
       * @param output8 the eighth output (output) of the DAG
       * @param <RA> the type of the first result
       * @param <RB> the type of the second result
       * @param <RC> the type of the third result
       * @param <RD> the type of the fourth result
       * @param <RE> the type of the fifth result
       * @param <RF> the type of the sixth result
       * @param <RG> the type of the seventh result
       * @param <RH> the type of the eighth result
       * @return a completed DAG with 2 inputs (placeholders) and 8 outputs (outputs).
       */
      public <RA, RB, RC, RD, RE, RF, RG, RH> DAG2x8.Prepared<A, B, RA, RB, RC, RD, RE, RF, RG, RH> withOutputs(
          Producer<? extends RA> output1, Producer<? extends RB> output2, Producer<? extends RC> output3,
          Producer<? extends RD> output4, Producer<? extends RE> output5, Producer<? extends RF> output6,
          Producer<? extends RG> output7, Producer<? extends RH> output8) {
        Objects.requireNonNull(output1, "Output 1 may not be null");
        Objects.requireNonNull(output2, "Output 2 may not be null");
        Objects.requireNonNull(output3, "Output 3 may not be null");
        Objects.requireNonNull(output4, "Output 4 may not be null");
        Objects.requireNonNull(output5, "Output 5 may not be null");
        Objects.requireNonNull(output6, "Output 6 may not be null");
        Objects.requireNonNull(output7, "Output 7 may not be null");
        Objects.requireNonNull(output8, "Output 8 may not be null");

        if (_shouldRemapInputs) {
          Map<Producer<?>, Producer<?>> inputMapping =
              DAGUtil.createInputMap(_input1, _placeholder1, _input2, _placeholder2);
          output1 = DAGUtil.replaceInputs(output1, inputMapping);
          output2 = DAGUtil.replaceInputs(output2, inputMapping);
          output3 = DAGUtil.replaceInputs(output3, inputMapping);
          output4 = DAGUtil.replaceInputs(output4, inputMapping);
          output5 = DAGUtil.replaceInputs(output5, inputMapping);
          output6 = DAGUtil.replaceInputs(output6, inputMapping);
          output7 = DAGUtil.replaceInputs(output7, inputMapping);
          output8 = DAGUtil.replaceInputs(output8, inputMapping);
        }

        List<Producer<?>> inputs = Arrays.asList(_input1, _input2);

        return ((DAG2x8.Prepared) DAGUtil
            .createPreparedDAG(Arrays.asList(_placeholder1, _placeholder2),
                Arrays.asList(output1, output2, output3, output4, output5, output6, output7, output8)).internalAPI()
            .withInputsUnsafe(inputs)).withReduction(_minimumReducerLevel);
      }

      /**
       * Creates a completed DAG by supplying this partial DAG with its outputs (outputs).
       *
       * @param output1 the first output (output) of the DAG
       * @param output2 the second output (output) of the DAG
       * @param output3 the third output (output) of the DAG
       * @param output4 the fourth output (output) of the DAG
       * @param output5 the fifth output (output) of the DAG
       * @param output6 the sixth output (output) of the DAG
       * @param output7 the seventh output (output) of the DAG
       * @param output8 the eighth output (output) of the DAG
       * @param output9 the ninth output (output) of the DAG
       * @param <RA> the type of the first result
       * @param <RB> the type of the second result
       * @param <RC> the type of the third result
       * @param <RD> the type of the fourth result
       * @param <RE> the type of the fifth result
       * @param <RF> the type of the sixth result
       * @param <RG> the type of the seventh result
       * @param <RH> the type of the eighth result
       * @param <RI> the type of the ninth result
       * @return a completed DAG with 2 inputs (placeholders) and 9 outputs (outputs).
       */
      public <RA, RB, RC, RD, RE, RF, RG, RH, RI> DAG2x9.Prepared<A, B, RA, RB, RC, RD, RE, RF, RG, RH, RI> withOutputs(
          Producer<? extends RA> output1, Producer<? extends RB> output2, Producer<? extends RC> output3,
          Producer<? extends RD> output4, Producer<? extends RE> output5, Producer<? extends RF> output6,
          Producer<? extends RG> output7, Producer<? extends RH> output8, Producer<? extends RI> output9) {
        Objects.requireNonNull(output1, "Output 1 may not be null");
        Objects.requireNonNull(output2, "Output 2 may not be null");
        Objects.requireNonNull(output3, "Output 3 may not be null");
        Objects.requireNonNull(output4, "Output 4 may not be null");
        Objects.requireNonNull(output5, "Output 5 may not be null");
        Objects.requireNonNull(output6, "Output 6 may not be null");
        Objects.requireNonNull(output7, "Output 7 may not be null");
        Objects.requireNonNull(output8, "Output 8 may not be null");
        Objects.requireNonNull(output9, "Output 9 may not be null");

        if (_shouldRemapInputs) {
          Map<Producer<?>, Producer<?>> inputMapping =
              DAGUtil.createInputMap(_input1, _placeholder1, _input2, _placeholder2);
          output1 = DAGUtil.replaceInputs(output1, inputMapping);
          output2 = DAGUtil.replaceInputs(output2, inputMapping);
          output3 = DAGUtil.replaceInputs(output3, inputMapping);
          output4 = DAGUtil.replaceInputs(output4, inputMapping);
          output5 = DAGUtil.replaceInputs(output5, inputMapping);
          output6 = DAGUtil.replaceInputs(output6, inputMapping);
          output7 = DAGUtil.replaceInputs(output7, inputMapping);
          output8 = DAGUtil.replaceInputs(output8, inputMapping);
          output9 = DAGUtil.replaceInputs(output9, inputMapping);
        }

        List<Producer<?>> inputs = Arrays.asList(_input1, _input2);

        return ((DAG2x9.Prepared) DAGUtil
            .createPreparedDAG(Arrays.asList(_placeholder1, _placeholder2),
                Arrays.asList(output1, output2, output3, output4, output5, output6, output7, output8, output9))
            .internalAPI().withInputsUnsafe(inputs)).withReduction(_minimumReducerLevel);
      }

      /**
       * Creates a completed DAG by supplying this partial DAG with its outputs (outputs).
       *
       * @param output1 the first output (output) of the DAG
       * @param output2 the second output (output) of the DAG
       * @param output3 the third output (output) of the DAG
       * @param output4 the fourth output (output) of the DAG
       * @param output5 the fifth output (output) of the DAG
       * @param output6 the sixth output (output) of the DAG
       * @param output7 the seventh output (output) of the DAG
       * @param output8 the eighth output (output) of the DAG
       * @param output9 the ninth output (output) of the DAG
       * @param output10 the tenth output (output) of the DAG
       * @param <RA> the type of the first result
       * @param <RB> the type of the second result
       * @param <RC> the type of the third result
       * @param <RD> the type of the fourth result
       * @param <RE> the type of the fifth result
       * @param <RF> the type of the sixth result
       * @param <RG> the type of the seventh result
       * @param <RH> the type of the eighth result
       * @param <RI> the type of the ninth result
       * @param <RJ> the type of the tenth result
       * @return a completed DAG with 2 inputs (placeholders) and 10 outputs (outputs).
       */
      public <RA, RB, RC, RD, RE, RF, RG, RH, RI, RJ> DAG2x10.Prepared<A, B, RA, RB, RC, RD, RE, RF, RG, RH, RI, RJ> withOutputs(
          Producer<? extends RA> output1, Producer<? extends RB> output2, Producer<? extends RC> output3,
          Producer<? extends RD> output4, Producer<? extends RE> output5, Producer<? extends RF> output6,
          Producer<? extends RG> output7, Producer<? extends RH> output8, Producer<? extends RI> output9,
          Producer<? extends RJ> output10) {
        Objects.requireNonNull(output1, "Output 1 may not be null");
        Objects.requireNonNull(output2, "Output 2 may not be null");
        Objects.requireNonNull(output3, "Output 3 may not be null");
        Objects.requireNonNull(output4, "Output 4 may not be null");
        Objects.requireNonNull(output5, "Output 5 may not be null");
        Objects.requireNonNull(output6, "Output 6 may not be null");
        Objects.requireNonNull(output7, "Output 7 may not be null");
        Objects.requireNonNull(output8, "Output 8 may not be null");
        Objects.requireNonNull(output9, "Output 9 may not be null");
        Objects.requireNonNull(output10, "Output 10 may not be null");

        if (_shouldRemapInputs) {
          Map<Producer<?>, Producer<?>> inputMapping =
              DAGUtil.createInputMap(_input1, _placeholder1, _input2, _placeholder2);
          output1 = DAGUtil.replaceInputs(output1, inputMapping);
          output2 = DAGUtil.replaceInputs(output2, inputMapping);
          output3 = DAGUtil.replaceInputs(output3, inputMapping);
          output4 = DAGUtil.replaceInputs(output4, inputMapping);
          output5 = DAGUtil.replaceInputs(output5, inputMapping);
          output6 = DAGUtil.replaceInputs(output6, inputMapping);
          output7 = DAGUtil.replaceInputs(output7, inputMapping);
          output8 = DAGUtil.replaceInputs(output8, inputMapping);
          output9 = DAGUtil.replaceInputs(output9, inputMapping);
          output10 = DAGUtil.replaceInputs(output10, inputMapping);
        }

        List<Producer<?>> inputs = Arrays.asList(_input1, _input2);

        return ((DAG2x10.Prepared) DAGUtil
            .createPreparedDAG(
                Arrays.asList(_placeholder1, _placeholder2),
                Arrays
                    .asList(output1, output2, output3, output4, output5, output6, output7, output8, output9, output10))
            .internalAPI().withInputsUnsafe(inputs)).withReduction(_minimumReducerLevel);
      }
    }

    /**
      * A partial DAG with 3 placeholder.  Partial DAGs are <i>completed</i> to create a usable DAG by specifying
      * the outputs (<i>outputs</i>) of the DAG using the withOutputs(...) methods.
      *
     * @param <A> the type of the first input
     * @param <B> the type of the second input
     * @param <C> the type of the third input
      */
    public static class WithPlaceholders3<A, B, C> extends
        AbstractWithPlaceholders3<A, B, C, WithPlaceholders3<A, B, C>> {
      /**
       * Creates a new partial DAG that will be rooted at the provided placeholders.
       *
       * @param placeholder1 the first placeholder
       * @param placeholder2 the second placeholder
       * @param placeholder3 the third placeholder
       */
      WithPlaceholders3(Placeholder<? extends A> placeholder1, Placeholder<? extends B> placeholder2,
          Placeholder<? extends C> placeholder3) {
        super(placeholder1, placeholder2, placeholder3);
      }

      /**
       * Creates a new partial DAG that will be rooted at the provided placeholders, which will replace ("remap") the provided
       * "input" nodes that define a subgraph of the original graph (as defined by the ancestors of the outputs that will
       * be provided when the partial DAG is completed).  The input nodes, and any nodes that were exclusively the
       * ancestors of the input nodes, are truncated from the resulting graph.
       *
       * @param placeholder1 the first placeholder
       * @param placeholder2 the second placeholder
       * @param placeholder3 the third placeholder
       * @param input1 the first input
       * @param input2 the second input
       * @param input3 the third input
       */
      WithPlaceholders3(Placeholder<? extends A> placeholder1, Placeholder<? extends B> placeholder2,
          Placeholder<? extends C> placeholder3, Producer<? extends A> input1, Producer<? extends B> input2,
          Producer<? extends C> input3) {
        super(placeholder1, placeholder2, placeholder3, input1, input2, input3);
      }

      /**
       * Creates a completed DAG by supplying this partial DAG with its outputs (outputs).
       *
       * @param output1 the first output (output) of the DAG
       * @param <RA> the type of the first result
       * @return a completed DAG with 3 inputs (placeholders) and 1 output (outputs).
       */
      public <RA> DAG3x1.Prepared<A, B, C, RA> withOutputs(Producer<? extends RA> output1) {
        Objects.requireNonNull(output1, "Output 1 may not be null");

        if (_shouldRemapInputs) {
          Map<Producer<?>, Producer<?>> inputMapping =
              DAGUtil.createInputMap(_input1, _placeholder1, _input2, _placeholder2, _input3, _placeholder3);
          output1 = DAGUtil.replaceInputs(output1, inputMapping);
        }

        List<Producer<?>> inputs = Arrays.asList(_input1, _input2, _input3);

        return ((DAG3x1.Prepared) DAGUtil
            .createPreparedDAG(Arrays.asList(_placeholder1, _placeholder2, _placeholder3), Arrays.asList(output1))
            .internalAPI().withInputsUnsafe(inputs)).withReduction(_minimumReducerLevel);
      }

      /**
       * Creates a completed DAG by supplying this partial DAG with its outputs (outputs).
       *
       * @param output1 the first output (output) of the DAG
       * @param <RA> the type of the first result
       * @return a completed DAG with 3 inputs (placeholders) and 1 output (outputs).
       */
      public <RA> DAG3x1.Prepared<A, B, C, RA> withOutput(Producer<? extends RA> output1) {
        Objects.requireNonNull(output1, "Output 1 may not be null");

        if (_shouldRemapInputs) {
          Map<Producer<?>, Producer<?>> inputMapping =
              DAGUtil.createInputMap(_input1, _placeholder1, _input2, _placeholder2, _input3, _placeholder3);
          output1 = DAGUtil.replaceInputs(output1, inputMapping);
        }

        List<Producer<?>> inputs = Arrays.asList(_input1, _input2, _input3);

        return ((DAG3x1.Prepared) DAGUtil
            .createPreparedDAG(Arrays.asList(_placeholder1, _placeholder2, _placeholder3), Arrays.asList(output1))
            .internalAPI().withInputsUnsafe(inputs)).withReduction(_minimumReducerLevel);
      }

      /**
       * Creates a completed DAG by supplying this partial DAG with its outputs (outputs).
       *
       * @param output1 the first output (output) of the DAG
       * @param output2 the second output (output) of the DAG
       * @param <RA> the type of the first result
       * @param <RB> the type of the second result
       * @return a completed DAG with 3 inputs (placeholders) and 2 outputs (outputs).
       */
      public <RA, RB> DAG3x2.Prepared<A, B, C, RA, RB> withOutputs(Producer<? extends RA> output1,
          Producer<? extends RB> output2) {
        Objects.requireNonNull(output1, "Output 1 may not be null");
        Objects.requireNonNull(output2, "Output 2 may not be null");

        if (_shouldRemapInputs) {
          Map<Producer<?>, Producer<?>> inputMapping =
              DAGUtil.createInputMap(_input1, _placeholder1, _input2, _placeholder2, _input3, _placeholder3);
          output1 = DAGUtil.replaceInputs(output1, inputMapping);
          output2 = DAGUtil.replaceInputs(output2, inputMapping);
        }

        List<Producer<?>> inputs = Arrays.asList(_input1, _input2, _input3);

        return ((DAG3x2.Prepared) DAGUtil
            .createPreparedDAG(Arrays.asList(_placeholder1, _placeholder2, _placeholder3),
                Arrays.asList(output1, output2)).internalAPI().withInputsUnsafe(inputs))
            .withReduction(_minimumReducerLevel);
      }

      /**
       * Creates a completed DAG by supplying this partial DAG with its outputs (outputs).
       *
       * @param output1 the first output (output) of the DAG
       * @param output2 the second output (output) of the DAG
       * @param output3 the third output (output) of the DAG
       * @param <RA> the type of the first result
       * @param <RB> the type of the second result
       * @param <RC> the type of the third result
       * @return a completed DAG with 3 inputs (placeholders) and 3 outputs (outputs).
       */
      public <RA, RB, RC> DAG3x3.Prepared<A, B, C, RA, RB, RC> withOutputs(Producer<? extends RA> output1,
          Producer<? extends RB> output2, Producer<? extends RC> output3) {
        Objects.requireNonNull(output1, "Output 1 may not be null");
        Objects.requireNonNull(output2, "Output 2 may not be null");
        Objects.requireNonNull(output3, "Output 3 may not be null");

        if (_shouldRemapInputs) {
          Map<Producer<?>, Producer<?>> inputMapping =
              DAGUtil.createInputMap(_input1, _placeholder1, _input2, _placeholder2, _input3, _placeholder3);
          output1 = DAGUtil.replaceInputs(output1, inputMapping);
          output2 = DAGUtil.replaceInputs(output2, inputMapping);
          output3 = DAGUtil.replaceInputs(output3, inputMapping);
        }

        List<Producer<?>> inputs = Arrays.asList(_input1, _input2, _input3);

        return ((DAG3x3.Prepared) DAGUtil
            .createPreparedDAG(Arrays.asList(_placeholder1, _placeholder2, _placeholder3),
                Arrays.asList(output1, output2, output3)).internalAPI().withInputsUnsafe(inputs))
            .withReduction(_minimumReducerLevel);
      }

      /**
       * Creates a completed DAG by supplying this partial DAG with its outputs (outputs).
       *
       * @param output1 the first output (output) of the DAG
       * @param output2 the second output (output) of the DAG
       * @param output3 the third output (output) of the DAG
       * @param output4 the fourth output (output) of the DAG
       * @param <RA> the type of the first result
       * @param <RB> the type of the second result
       * @param <RC> the type of the third result
       * @param <RD> the type of the fourth result
       * @return a completed DAG with 3 inputs (placeholders) and 4 outputs (outputs).
       */
      public <RA, RB, RC, RD> DAG3x4.Prepared<A, B, C, RA, RB, RC, RD> withOutputs(Producer<? extends RA> output1,
          Producer<? extends RB> output2, Producer<? extends RC> output3, Producer<? extends RD> output4) {
        Objects.requireNonNull(output1, "Output 1 may not be null");
        Objects.requireNonNull(output2, "Output 2 may not be null");
        Objects.requireNonNull(output3, "Output 3 may not be null");
        Objects.requireNonNull(output4, "Output 4 may not be null");

        if (_shouldRemapInputs) {
          Map<Producer<?>, Producer<?>> inputMapping =
              DAGUtil.createInputMap(_input1, _placeholder1, _input2, _placeholder2, _input3, _placeholder3);
          output1 = DAGUtil.replaceInputs(output1, inputMapping);
          output2 = DAGUtil.replaceInputs(output2, inputMapping);
          output3 = DAGUtil.replaceInputs(output3, inputMapping);
          output4 = DAGUtil.replaceInputs(output4, inputMapping);
        }

        List<Producer<?>> inputs = Arrays.asList(_input1, _input2, _input3);

        return ((DAG3x4.Prepared) DAGUtil
            .createPreparedDAG(Arrays.asList(_placeholder1, _placeholder2, _placeholder3),
                Arrays.asList(output1, output2, output3, output4)).internalAPI().withInputsUnsafe(inputs))
            .withReduction(_minimumReducerLevel);
      }

      /**
       * Creates a completed DAG by supplying this partial DAG with its outputs (outputs).
       *
       * @param output1 the first output (output) of the DAG
       * @param output2 the second output (output) of the DAG
       * @param output3 the third output (output) of the DAG
       * @param output4 the fourth output (output) of the DAG
       * @param output5 the fifth output (output) of the DAG
       * @param <RA> the type of the first result
       * @param <RB> the type of the second result
       * @param <RC> the type of the third result
       * @param <RD> the type of the fourth result
       * @param <RE> the type of the fifth result
       * @return a completed DAG with 3 inputs (placeholders) and 5 outputs (outputs).
       */
      public <RA, RB, RC, RD, RE> DAG3x5.Prepared<A, B, C, RA, RB, RC, RD, RE> withOutputs(
          Producer<? extends RA> output1, Producer<? extends RB> output2, Producer<? extends RC> output3,
          Producer<? extends RD> output4, Producer<? extends RE> output5) {
        Objects.requireNonNull(output1, "Output 1 may not be null");
        Objects.requireNonNull(output2, "Output 2 may not be null");
        Objects.requireNonNull(output3, "Output 3 may not be null");
        Objects.requireNonNull(output4, "Output 4 may not be null");
        Objects.requireNonNull(output5, "Output 5 may not be null");

        if (_shouldRemapInputs) {
          Map<Producer<?>, Producer<?>> inputMapping =
              DAGUtil.createInputMap(_input1, _placeholder1, _input2, _placeholder2, _input3, _placeholder3);
          output1 = DAGUtil.replaceInputs(output1, inputMapping);
          output2 = DAGUtil.replaceInputs(output2, inputMapping);
          output3 = DAGUtil.replaceInputs(output3, inputMapping);
          output4 = DAGUtil.replaceInputs(output4, inputMapping);
          output5 = DAGUtil.replaceInputs(output5, inputMapping);
        }

        List<Producer<?>> inputs = Arrays.asList(_input1, _input2, _input3);

        return ((DAG3x5.Prepared) DAGUtil
            .createPreparedDAG(Arrays.asList(_placeholder1, _placeholder2, _placeholder3),
                Arrays.asList(output1, output2, output3, output4, output5)).internalAPI().withInputsUnsafe(inputs))
            .withReduction(_minimumReducerLevel);
      }

      /**
       * Creates a completed DAG by supplying this partial DAG with its outputs (outputs).
       *
       * @param output1 the first output (output) of the DAG
       * @param output2 the second output (output) of the DAG
       * @param output3 the third output (output) of the DAG
       * @param output4 the fourth output (output) of the DAG
       * @param output5 the fifth output (output) of the DAG
       * @param output6 the sixth output (output) of the DAG
       * @param <RA> the type of the first result
       * @param <RB> the type of the second result
       * @param <RC> the type of the third result
       * @param <RD> the type of the fourth result
       * @param <RE> the type of the fifth result
       * @param <RF> the type of the sixth result
       * @return a completed DAG with 3 inputs (placeholders) and 6 outputs (outputs).
       */
      public <RA, RB, RC, RD, RE, RF> DAG3x6.Prepared<A, B, C, RA, RB, RC, RD, RE, RF> withOutputs(
          Producer<? extends RA> output1, Producer<? extends RB> output2, Producer<? extends RC> output3,
          Producer<? extends RD> output4, Producer<? extends RE> output5, Producer<? extends RF> output6) {
        Objects.requireNonNull(output1, "Output 1 may not be null");
        Objects.requireNonNull(output2, "Output 2 may not be null");
        Objects.requireNonNull(output3, "Output 3 may not be null");
        Objects.requireNonNull(output4, "Output 4 may not be null");
        Objects.requireNonNull(output5, "Output 5 may not be null");
        Objects.requireNonNull(output6, "Output 6 may not be null");

        if (_shouldRemapInputs) {
          Map<Producer<?>, Producer<?>> inputMapping =
              DAGUtil.createInputMap(_input1, _placeholder1, _input2, _placeholder2, _input3, _placeholder3);
          output1 = DAGUtil.replaceInputs(output1, inputMapping);
          output2 = DAGUtil.replaceInputs(output2, inputMapping);
          output3 = DAGUtil.replaceInputs(output3, inputMapping);
          output4 = DAGUtil.replaceInputs(output4, inputMapping);
          output5 = DAGUtil.replaceInputs(output5, inputMapping);
          output6 = DAGUtil.replaceInputs(output6, inputMapping);
        }

        List<Producer<?>> inputs = Arrays.asList(_input1, _input2, _input3);

        return ((DAG3x6.Prepared) DAGUtil
            .createPreparedDAG(Arrays.asList(_placeholder1, _placeholder2, _placeholder3),
                Arrays.asList(output1, output2, output3, output4, output5, output6)).internalAPI()
            .withInputsUnsafe(inputs)).withReduction(_minimumReducerLevel);
      }

      /**
       * Creates a completed DAG by supplying this partial DAG with its outputs (outputs).
       *
       * @param output1 the first output (output) of the DAG
       * @param output2 the second output (output) of the DAG
       * @param output3 the third output (output) of the DAG
       * @param output4 the fourth output (output) of the DAG
       * @param output5 the fifth output (output) of the DAG
       * @param output6 the sixth output (output) of the DAG
       * @param output7 the seventh output (output) of the DAG
       * @param <RA> the type of the first result
       * @param <RB> the type of the second result
       * @param <RC> the type of the third result
       * @param <RD> the type of the fourth result
       * @param <RE> the type of the fifth result
       * @param <RF> the type of the sixth result
       * @param <RG> the type of the seventh result
       * @return a completed DAG with 3 inputs (placeholders) and 7 outputs (outputs).
       */
      public <RA, RB, RC, RD, RE, RF, RG> DAG3x7.Prepared<A, B, C, RA, RB, RC, RD, RE, RF, RG> withOutputs(
          Producer<? extends RA> output1, Producer<? extends RB> output2, Producer<? extends RC> output3,
          Producer<? extends RD> output4, Producer<? extends RE> output5, Producer<? extends RF> output6,
          Producer<? extends RG> output7) {
        Objects.requireNonNull(output1, "Output 1 may not be null");
        Objects.requireNonNull(output2, "Output 2 may not be null");
        Objects.requireNonNull(output3, "Output 3 may not be null");
        Objects.requireNonNull(output4, "Output 4 may not be null");
        Objects.requireNonNull(output5, "Output 5 may not be null");
        Objects.requireNonNull(output6, "Output 6 may not be null");
        Objects.requireNonNull(output7, "Output 7 may not be null");

        if (_shouldRemapInputs) {
          Map<Producer<?>, Producer<?>> inputMapping =
              DAGUtil.createInputMap(_input1, _placeholder1, _input2, _placeholder2, _input3, _placeholder3);
          output1 = DAGUtil.replaceInputs(output1, inputMapping);
          output2 = DAGUtil.replaceInputs(output2, inputMapping);
          output3 = DAGUtil.replaceInputs(output3, inputMapping);
          output4 = DAGUtil.replaceInputs(output4, inputMapping);
          output5 = DAGUtil.replaceInputs(output5, inputMapping);
          output6 = DAGUtil.replaceInputs(output6, inputMapping);
          output7 = DAGUtil.replaceInputs(output7, inputMapping);
        }

        List<Producer<?>> inputs = Arrays.asList(_input1, _input2, _input3);

        return ((DAG3x7.Prepared) DAGUtil
            .createPreparedDAG(Arrays.asList(_placeholder1, _placeholder2, _placeholder3),
                Arrays.asList(output1, output2, output3, output4, output5, output6, output7)).internalAPI()
            .withInputsUnsafe(inputs)).withReduction(_minimumReducerLevel);
      }

      /**
       * Creates a completed DAG by supplying this partial DAG with its outputs (outputs).
       *
       * @param output1 the first output (output) of the DAG
       * @param output2 the second output (output) of the DAG
       * @param output3 the third output (output) of the DAG
       * @param output4 the fourth output (output) of the DAG
       * @param output5 the fifth output (output) of the DAG
       * @param output6 the sixth output (output) of the DAG
       * @param output7 the seventh output (output) of the DAG
       * @param output8 the eighth output (output) of the DAG
       * @param <RA> the type of the first result
       * @param <RB> the type of the second result
       * @param <RC> the type of the third result
       * @param <RD> the type of the fourth result
       * @param <RE> the type of the fifth result
       * @param <RF> the type of the sixth result
       * @param <RG> the type of the seventh result
       * @param <RH> the type of the eighth result
       * @return a completed DAG with 3 inputs (placeholders) and 8 outputs (outputs).
       */
      public <RA, RB, RC, RD, RE, RF, RG, RH> DAG3x8.Prepared<A, B, C, RA, RB, RC, RD, RE, RF, RG, RH> withOutputs(
          Producer<? extends RA> output1, Producer<? extends RB> output2, Producer<? extends RC> output3,
          Producer<? extends RD> output4, Producer<? extends RE> output5, Producer<? extends RF> output6,
          Producer<? extends RG> output7, Producer<? extends RH> output8) {
        Objects.requireNonNull(output1, "Output 1 may not be null");
        Objects.requireNonNull(output2, "Output 2 may not be null");
        Objects.requireNonNull(output3, "Output 3 may not be null");
        Objects.requireNonNull(output4, "Output 4 may not be null");
        Objects.requireNonNull(output5, "Output 5 may not be null");
        Objects.requireNonNull(output6, "Output 6 may not be null");
        Objects.requireNonNull(output7, "Output 7 may not be null");
        Objects.requireNonNull(output8, "Output 8 may not be null");

        if (_shouldRemapInputs) {
          Map<Producer<?>, Producer<?>> inputMapping =
              DAGUtil.createInputMap(_input1, _placeholder1, _input2, _placeholder2, _input3, _placeholder3);
          output1 = DAGUtil.replaceInputs(output1, inputMapping);
          output2 = DAGUtil.replaceInputs(output2, inputMapping);
          output3 = DAGUtil.replaceInputs(output3, inputMapping);
          output4 = DAGUtil.replaceInputs(output4, inputMapping);
          output5 = DAGUtil.replaceInputs(output5, inputMapping);
          output6 = DAGUtil.replaceInputs(output6, inputMapping);
          output7 = DAGUtil.replaceInputs(output7, inputMapping);
          output8 = DAGUtil.replaceInputs(output8, inputMapping);
        }

        List<Producer<?>> inputs = Arrays.asList(_input1, _input2, _input3);

        return ((DAG3x8.Prepared) DAGUtil
            .createPreparedDAG(Arrays.asList(_placeholder1, _placeholder2, _placeholder3),
                Arrays.asList(output1, output2, output3, output4, output5, output6, output7, output8)).internalAPI()
            .withInputsUnsafe(inputs)).withReduction(_minimumReducerLevel);
      }

      /**
       * Creates a completed DAG by supplying this partial DAG with its outputs (outputs).
       *
       * @param output1 the first output (output) of the DAG
       * @param output2 the second output (output) of the DAG
       * @param output3 the third output (output) of the DAG
       * @param output4 the fourth output (output) of the DAG
       * @param output5 the fifth output (output) of the DAG
       * @param output6 the sixth output (output) of the DAG
       * @param output7 the seventh output (output) of the DAG
       * @param output8 the eighth output (output) of the DAG
       * @param output9 the ninth output (output) of the DAG
       * @param <RA> the type of the first result
       * @param <RB> the type of the second result
       * @param <RC> the type of the third result
       * @param <RD> the type of the fourth result
       * @param <RE> the type of the fifth result
       * @param <RF> the type of the sixth result
       * @param <RG> the type of the seventh result
       * @param <RH> the type of the eighth result
       * @param <RI> the type of the ninth result
       * @return a completed DAG with 3 inputs (placeholders) and 9 outputs (outputs).
       */
      public <RA, RB, RC, RD, RE, RF, RG, RH, RI> DAG3x9.Prepared<A, B, C, RA, RB, RC, RD, RE, RF, RG, RH, RI> withOutputs(
          Producer<? extends RA> output1, Producer<? extends RB> output2, Producer<? extends RC> output3,
          Producer<? extends RD> output4, Producer<? extends RE> output5, Producer<? extends RF> output6,
          Producer<? extends RG> output7, Producer<? extends RH> output8, Producer<? extends RI> output9) {
        Objects.requireNonNull(output1, "Output 1 may not be null");
        Objects.requireNonNull(output2, "Output 2 may not be null");
        Objects.requireNonNull(output3, "Output 3 may not be null");
        Objects.requireNonNull(output4, "Output 4 may not be null");
        Objects.requireNonNull(output5, "Output 5 may not be null");
        Objects.requireNonNull(output6, "Output 6 may not be null");
        Objects.requireNonNull(output7, "Output 7 may not be null");
        Objects.requireNonNull(output8, "Output 8 may not be null");
        Objects.requireNonNull(output9, "Output 9 may not be null");

        if (_shouldRemapInputs) {
          Map<Producer<?>, Producer<?>> inputMapping =
              DAGUtil.createInputMap(_input1, _placeholder1, _input2, _placeholder2, _input3, _placeholder3);
          output1 = DAGUtil.replaceInputs(output1, inputMapping);
          output2 = DAGUtil.replaceInputs(output2, inputMapping);
          output3 = DAGUtil.replaceInputs(output3, inputMapping);
          output4 = DAGUtil.replaceInputs(output4, inputMapping);
          output5 = DAGUtil.replaceInputs(output5, inputMapping);
          output6 = DAGUtil.replaceInputs(output6, inputMapping);
          output7 = DAGUtil.replaceInputs(output7, inputMapping);
          output8 = DAGUtil.replaceInputs(output8, inputMapping);
          output9 = DAGUtil.replaceInputs(output9, inputMapping);
        }

        List<Producer<?>> inputs = Arrays.asList(_input1, _input2, _input3);

        return ((DAG3x9.Prepared) DAGUtil
            .createPreparedDAG(Arrays.asList(_placeholder1, _placeholder2, _placeholder3),
                Arrays.asList(output1, output2, output3, output4, output5, output6, output7, output8, output9))
            .internalAPI().withInputsUnsafe(inputs)).withReduction(_minimumReducerLevel);
      }

      /**
       * Creates a completed DAG by supplying this partial DAG with its outputs (outputs).
       *
       * @param output1 the first output (output) of the DAG
       * @param output2 the second output (output) of the DAG
       * @param output3 the third output (output) of the DAG
       * @param output4 the fourth output (output) of the DAG
       * @param output5 the fifth output (output) of the DAG
       * @param output6 the sixth output (output) of the DAG
       * @param output7 the seventh output (output) of the DAG
       * @param output8 the eighth output (output) of the DAG
       * @param output9 the ninth output (output) of the DAG
       * @param output10 the tenth output (output) of the DAG
       * @param <RA> the type of the first result
       * @param <RB> the type of the second result
       * @param <RC> the type of the third result
       * @param <RD> the type of the fourth result
       * @param <RE> the type of the fifth result
       * @param <RF> the type of the sixth result
       * @param <RG> the type of the seventh result
       * @param <RH> the type of the eighth result
       * @param <RI> the type of the ninth result
       * @param <RJ> the type of the tenth result
       * @return a completed DAG with 3 inputs (placeholders) and 10 outputs (outputs).
       */
      public <RA, RB, RC, RD, RE, RF, RG, RH, RI, RJ> DAG3x10.Prepared<A, B, C, RA, RB, RC, RD, RE, RF, RG, RH, RI, RJ> withOutputs(
          Producer<? extends RA> output1, Producer<? extends RB> output2, Producer<? extends RC> output3,
          Producer<? extends RD> output4, Producer<? extends RE> output5, Producer<? extends RF> output6,
          Producer<? extends RG> output7, Producer<? extends RH> output8, Producer<? extends RI> output9,
          Producer<? extends RJ> output10) {
        Objects.requireNonNull(output1, "Output 1 may not be null");
        Objects.requireNonNull(output2, "Output 2 may not be null");
        Objects.requireNonNull(output3, "Output 3 may not be null");
        Objects.requireNonNull(output4, "Output 4 may not be null");
        Objects.requireNonNull(output5, "Output 5 may not be null");
        Objects.requireNonNull(output6, "Output 6 may not be null");
        Objects.requireNonNull(output7, "Output 7 may not be null");
        Objects.requireNonNull(output8, "Output 8 may not be null");
        Objects.requireNonNull(output9, "Output 9 may not be null");
        Objects.requireNonNull(output10, "Output 10 may not be null");

        if (_shouldRemapInputs) {
          Map<Producer<?>, Producer<?>> inputMapping =
              DAGUtil.createInputMap(_input1, _placeholder1, _input2, _placeholder2, _input3, _placeholder3);
          output1 = DAGUtil.replaceInputs(output1, inputMapping);
          output2 = DAGUtil.replaceInputs(output2, inputMapping);
          output3 = DAGUtil.replaceInputs(output3, inputMapping);
          output4 = DAGUtil.replaceInputs(output4, inputMapping);
          output5 = DAGUtil.replaceInputs(output5, inputMapping);
          output6 = DAGUtil.replaceInputs(output6, inputMapping);
          output7 = DAGUtil.replaceInputs(output7, inputMapping);
          output8 = DAGUtil.replaceInputs(output8, inputMapping);
          output9 = DAGUtil.replaceInputs(output9, inputMapping);
          output10 = DAGUtil.replaceInputs(output10, inputMapping);
        }

        List<Producer<?>> inputs = Arrays.asList(_input1, _input2, _input3);

        return ((DAG3x10.Prepared) DAGUtil
            .createPreparedDAG(
                Arrays.asList(_placeholder1, _placeholder2, _placeholder3),
                Arrays
                    .asList(output1, output2, output3, output4, output5, output6, output7, output8, output9, output10))
            .internalAPI().withInputsUnsafe(inputs)).withReduction(_minimumReducerLevel);
      }
    }

    /**
      * A partial DAG with 4 placeholder.  Partial DAGs are <i>completed</i> to create a usable DAG by specifying
      * the outputs (<i>outputs</i>) of the DAG using the withOutputs(...) methods.
      *
     * @param <A> the type of the first input
     * @param <B> the type of the second input
     * @param <C> the type of the third input
     * @param <D> the type of the fourth input
      */
    public static class WithPlaceholders4<A, B, C, D> extends
        AbstractWithPlaceholders4<A, B, C, D, WithPlaceholders4<A, B, C, D>> {
      /**
       * Creates a new partial DAG that will be rooted at the provided placeholders.
       *
       * @param placeholder1 the first placeholder
       * @param placeholder2 the second placeholder
       * @param placeholder3 the third placeholder
       * @param placeholder4 the fourth placeholder
       */
      WithPlaceholders4(Placeholder<? extends A> placeholder1, Placeholder<? extends B> placeholder2,
          Placeholder<? extends C> placeholder3, Placeholder<? extends D> placeholder4) {
        super(placeholder1, placeholder2, placeholder3, placeholder4);
      }

      /**
       * Creates a new partial DAG that will be rooted at the provided placeholders, which will replace ("remap") the provided
       * "input" nodes that define a subgraph of the original graph (as defined by the ancestors of the outputs that will
       * be provided when the partial DAG is completed).  The input nodes, and any nodes that were exclusively the
       * ancestors of the input nodes, are truncated from the resulting graph.
       *
       * @param placeholder1 the first placeholder
       * @param placeholder2 the second placeholder
       * @param placeholder3 the third placeholder
       * @param placeholder4 the fourth placeholder
       * @param input1 the first input
       * @param input2 the second input
       * @param input3 the third input
       * @param input4 the fourth input
       */
      WithPlaceholders4(Placeholder<? extends A> placeholder1, Placeholder<? extends B> placeholder2,
          Placeholder<? extends C> placeholder3, Placeholder<? extends D> placeholder4, Producer<? extends A> input1,
          Producer<? extends B> input2, Producer<? extends C> input3, Producer<? extends D> input4) {
        super(placeholder1, placeholder2, placeholder3, placeholder4, input1, input2, input3, input4);
      }

      /**
       * Creates a completed DAG by supplying this partial DAG with its outputs (outputs).
       *
       * @param output1 the first output (output) of the DAG
       * @param <RA> the type of the first result
       * @return a completed DAG with 4 inputs (placeholders) and 1 output (outputs).
       */
      public <RA> DAG4x1.Prepared<A, B, C, D, RA> withOutputs(Producer<? extends RA> output1) {
        Objects.requireNonNull(output1, "Output 1 may not be null");

        if (_shouldRemapInputs) {
          Map<Producer<?>, Producer<?>> inputMapping =
              DAGUtil.createInputMap(_input1, _placeholder1, _input2, _placeholder2, _input3, _placeholder3, _input4,
                  _placeholder4);
          output1 = DAGUtil.replaceInputs(output1, inputMapping);
        }

        List<Producer<?>> inputs = Arrays.asList(_input1, _input2, _input3, _input4);

        return ((DAG4x1.Prepared) DAGUtil
            .createPreparedDAG(Arrays.asList(_placeholder1, _placeholder2, _placeholder3, _placeholder4),
                Arrays.asList(output1)).internalAPI().withInputsUnsafe(inputs)).withReduction(_minimumReducerLevel);
      }

      /**
       * Creates a completed DAG by supplying this partial DAG with its outputs (outputs).
       *
       * @param output1 the first output (output) of the DAG
       * @param <RA> the type of the first result
       * @return a completed DAG with 4 inputs (placeholders) and 1 output (outputs).
       */
      public <RA> DAG4x1.Prepared<A, B, C, D, RA> withOutput(Producer<? extends RA> output1) {
        Objects.requireNonNull(output1, "Output 1 may not be null");

        if (_shouldRemapInputs) {
          Map<Producer<?>, Producer<?>> inputMapping =
              DAGUtil.createInputMap(_input1, _placeholder1, _input2, _placeholder2, _input3, _placeholder3, _input4,
                  _placeholder4);
          output1 = DAGUtil.replaceInputs(output1, inputMapping);
        }

        List<Producer<?>> inputs = Arrays.asList(_input1, _input2, _input3, _input4);

        return ((DAG4x1.Prepared) DAGUtil
            .createPreparedDAG(Arrays.asList(_placeholder1, _placeholder2, _placeholder3, _placeholder4),
                Arrays.asList(output1)).internalAPI().withInputsUnsafe(inputs)).withReduction(_minimumReducerLevel);
      }

      /**
       * Creates a completed DAG by supplying this partial DAG with its outputs (outputs).
       *
       * @param output1 the first output (output) of the DAG
       * @param output2 the second output (output) of the DAG
       * @param <RA> the type of the first result
       * @param <RB> the type of the second result
       * @return a completed DAG with 4 inputs (placeholders) and 2 outputs (outputs).
       */
      public <RA, RB> DAG4x2.Prepared<A, B, C, D, RA, RB> withOutputs(Producer<? extends RA> output1,
          Producer<? extends RB> output2) {
        Objects.requireNonNull(output1, "Output 1 may not be null");
        Objects.requireNonNull(output2, "Output 2 may not be null");

        if (_shouldRemapInputs) {
          Map<Producer<?>, Producer<?>> inputMapping =
              DAGUtil.createInputMap(_input1, _placeholder1, _input2, _placeholder2, _input3, _placeholder3, _input4,
                  _placeholder4);
          output1 = DAGUtil.replaceInputs(output1, inputMapping);
          output2 = DAGUtil.replaceInputs(output2, inputMapping);
        }

        List<Producer<?>> inputs = Arrays.asList(_input1, _input2, _input3, _input4);

        return ((DAG4x2.Prepared) DAGUtil
            .createPreparedDAG(Arrays.asList(_placeholder1, _placeholder2, _placeholder3, _placeholder4),
                Arrays.asList(output1, output2)).internalAPI().withInputsUnsafe(inputs))
            .withReduction(_minimumReducerLevel);
      }

      /**
       * Creates a completed DAG by supplying this partial DAG with its outputs (outputs).
       *
       * @param output1 the first output (output) of the DAG
       * @param output2 the second output (output) of the DAG
       * @param output3 the third output (output) of the DAG
       * @param <RA> the type of the first result
       * @param <RB> the type of the second result
       * @param <RC> the type of the third result
       * @return a completed DAG with 4 inputs (placeholders) and 3 outputs (outputs).
       */
      public <RA, RB, RC> DAG4x3.Prepared<A, B, C, D, RA, RB, RC> withOutputs(Producer<? extends RA> output1,
          Producer<? extends RB> output2, Producer<? extends RC> output3) {
        Objects.requireNonNull(output1, "Output 1 may not be null");
        Objects.requireNonNull(output2, "Output 2 may not be null");
        Objects.requireNonNull(output3, "Output 3 may not be null");

        if (_shouldRemapInputs) {
          Map<Producer<?>, Producer<?>> inputMapping =
              DAGUtil.createInputMap(_input1, _placeholder1, _input2, _placeholder2, _input3, _placeholder3, _input4,
                  _placeholder4);
          output1 = DAGUtil.replaceInputs(output1, inputMapping);
          output2 = DAGUtil.replaceInputs(output2, inputMapping);
          output3 = DAGUtil.replaceInputs(output3, inputMapping);
        }

        List<Producer<?>> inputs = Arrays.asList(_input1, _input2, _input3, _input4);

        return ((DAG4x3.Prepared) DAGUtil
            .createPreparedDAG(Arrays.asList(_placeholder1, _placeholder2, _placeholder3, _placeholder4),
                Arrays.asList(output1, output2, output3)).internalAPI().withInputsUnsafe(inputs))
            .withReduction(_minimumReducerLevel);
      }

      /**
       * Creates a completed DAG by supplying this partial DAG with its outputs (outputs).
       *
       * @param output1 the first output (output) of the DAG
       * @param output2 the second output (output) of the DAG
       * @param output3 the third output (output) of the DAG
       * @param output4 the fourth output (output) of the DAG
       * @param <RA> the type of the first result
       * @param <RB> the type of the second result
       * @param <RC> the type of the third result
       * @param <RD> the type of the fourth result
       * @return a completed DAG with 4 inputs (placeholders) and 4 outputs (outputs).
       */
      public <RA, RB, RC, RD> DAG4x4.Prepared<A, B, C, D, RA, RB, RC, RD> withOutputs(Producer<? extends RA> output1,
          Producer<? extends RB> output2, Producer<? extends RC> output3, Producer<? extends RD> output4) {
        Objects.requireNonNull(output1, "Output 1 may not be null");
        Objects.requireNonNull(output2, "Output 2 may not be null");
        Objects.requireNonNull(output3, "Output 3 may not be null");
        Objects.requireNonNull(output4, "Output 4 may not be null");

        if (_shouldRemapInputs) {
          Map<Producer<?>, Producer<?>> inputMapping =
              DAGUtil.createInputMap(_input1, _placeholder1, _input2, _placeholder2, _input3, _placeholder3, _input4,
                  _placeholder4);
          output1 = DAGUtil.replaceInputs(output1, inputMapping);
          output2 = DAGUtil.replaceInputs(output2, inputMapping);
          output3 = DAGUtil.replaceInputs(output3, inputMapping);
          output4 = DAGUtil.replaceInputs(output4, inputMapping);
        }

        List<Producer<?>> inputs = Arrays.asList(_input1, _input2, _input3, _input4);

        return ((DAG4x4.Prepared) DAGUtil
            .createPreparedDAG(Arrays.asList(_placeholder1, _placeholder2, _placeholder3, _placeholder4),
                Arrays.asList(output1, output2, output3, output4)).internalAPI().withInputsUnsafe(inputs))
            .withReduction(_minimumReducerLevel);
      }

      /**
       * Creates a completed DAG by supplying this partial DAG with its outputs (outputs).
       *
       * @param output1 the first output (output) of the DAG
       * @param output2 the second output (output) of the DAG
       * @param output3 the third output (output) of the DAG
       * @param output4 the fourth output (output) of the DAG
       * @param output5 the fifth output (output) of the DAG
       * @param <RA> the type of the first result
       * @param <RB> the type of the second result
       * @param <RC> the type of the third result
       * @param <RD> the type of the fourth result
       * @param <RE> the type of the fifth result
       * @return a completed DAG with 4 inputs (placeholders) and 5 outputs (outputs).
       */
      public <RA, RB, RC, RD, RE> DAG4x5.Prepared<A, B, C, D, RA, RB, RC, RD, RE> withOutputs(
          Producer<? extends RA> output1, Producer<? extends RB> output2, Producer<? extends RC> output3,
          Producer<? extends RD> output4, Producer<? extends RE> output5) {
        Objects.requireNonNull(output1, "Output 1 may not be null");
        Objects.requireNonNull(output2, "Output 2 may not be null");
        Objects.requireNonNull(output3, "Output 3 may not be null");
        Objects.requireNonNull(output4, "Output 4 may not be null");
        Objects.requireNonNull(output5, "Output 5 may not be null");

        if (_shouldRemapInputs) {
          Map<Producer<?>, Producer<?>> inputMapping =
              DAGUtil.createInputMap(_input1, _placeholder1, _input2, _placeholder2, _input3, _placeholder3, _input4,
                  _placeholder4);
          output1 = DAGUtil.replaceInputs(output1, inputMapping);
          output2 = DAGUtil.replaceInputs(output2, inputMapping);
          output3 = DAGUtil.replaceInputs(output3, inputMapping);
          output4 = DAGUtil.replaceInputs(output4, inputMapping);
          output5 = DAGUtil.replaceInputs(output5, inputMapping);
        }

        List<Producer<?>> inputs = Arrays.asList(_input1, _input2, _input3, _input4);

        return ((DAG4x5.Prepared) DAGUtil
            .createPreparedDAG(Arrays.asList(_placeholder1, _placeholder2, _placeholder3, _placeholder4),
                Arrays.asList(output1, output2, output3, output4, output5)).internalAPI().withInputsUnsafe(inputs))
            .withReduction(_minimumReducerLevel);
      }

      /**
       * Creates a completed DAG by supplying this partial DAG with its outputs (outputs).
       *
       * @param output1 the first output (output) of the DAG
       * @param output2 the second output (output) of the DAG
       * @param output3 the third output (output) of the DAG
       * @param output4 the fourth output (output) of the DAG
       * @param output5 the fifth output (output) of the DAG
       * @param output6 the sixth output (output) of the DAG
       * @param <RA> the type of the first result
       * @param <RB> the type of the second result
       * @param <RC> the type of the third result
       * @param <RD> the type of the fourth result
       * @param <RE> the type of the fifth result
       * @param <RF> the type of the sixth result
       * @return a completed DAG with 4 inputs (placeholders) and 6 outputs (outputs).
       */
      public <RA, RB, RC, RD, RE, RF> DAG4x6.Prepared<A, B, C, D, RA, RB, RC, RD, RE, RF> withOutputs(
          Producer<? extends RA> output1, Producer<? extends RB> output2, Producer<? extends RC> output3,
          Producer<? extends RD> output4, Producer<? extends RE> output5, Producer<? extends RF> output6) {
        Objects.requireNonNull(output1, "Output 1 may not be null");
        Objects.requireNonNull(output2, "Output 2 may not be null");
        Objects.requireNonNull(output3, "Output 3 may not be null");
        Objects.requireNonNull(output4, "Output 4 may not be null");
        Objects.requireNonNull(output5, "Output 5 may not be null");
        Objects.requireNonNull(output6, "Output 6 may not be null");

        if (_shouldRemapInputs) {
          Map<Producer<?>, Producer<?>> inputMapping =
              DAGUtil.createInputMap(_input1, _placeholder1, _input2, _placeholder2, _input3, _placeholder3, _input4,
                  _placeholder4);
          output1 = DAGUtil.replaceInputs(output1, inputMapping);
          output2 = DAGUtil.replaceInputs(output2, inputMapping);
          output3 = DAGUtil.replaceInputs(output3, inputMapping);
          output4 = DAGUtil.replaceInputs(output4, inputMapping);
          output5 = DAGUtil.replaceInputs(output5, inputMapping);
          output6 = DAGUtil.replaceInputs(output6, inputMapping);
        }

        List<Producer<?>> inputs = Arrays.asList(_input1, _input2, _input3, _input4);

        return ((DAG4x6.Prepared) DAGUtil
            .createPreparedDAG(Arrays.asList(_placeholder1, _placeholder2, _placeholder3, _placeholder4),
                Arrays.asList(output1, output2, output3, output4, output5, output6)).internalAPI()
            .withInputsUnsafe(inputs)).withReduction(_minimumReducerLevel);
      }

      /**
       * Creates a completed DAG by supplying this partial DAG with its outputs (outputs).
       *
       * @param output1 the first output (output) of the DAG
       * @param output2 the second output (output) of the DAG
       * @param output3 the third output (output) of the DAG
       * @param output4 the fourth output (output) of the DAG
       * @param output5 the fifth output (output) of the DAG
       * @param output6 the sixth output (output) of the DAG
       * @param output7 the seventh output (output) of the DAG
       * @param <RA> the type of the first result
       * @param <RB> the type of the second result
       * @param <RC> the type of the third result
       * @param <RD> the type of the fourth result
       * @param <RE> the type of the fifth result
       * @param <RF> the type of the sixth result
       * @param <RG> the type of the seventh result
       * @return a completed DAG with 4 inputs (placeholders) and 7 outputs (outputs).
       */
      public <RA, RB, RC, RD, RE, RF, RG> DAG4x7.Prepared<A, B, C, D, RA, RB, RC, RD, RE, RF, RG> withOutputs(
          Producer<? extends RA> output1, Producer<? extends RB> output2, Producer<? extends RC> output3,
          Producer<? extends RD> output4, Producer<? extends RE> output5, Producer<? extends RF> output6,
          Producer<? extends RG> output7) {
        Objects.requireNonNull(output1, "Output 1 may not be null");
        Objects.requireNonNull(output2, "Output 2 may not be null");
        Objects.requireNonNull(output3, "Output 3 may not be null");
        Objects.requireNonNull(output4, "Output 4 may not be null");
        Objects.requireNonNull(output5, "Output 5 may not be null");
        Objects.requireNonNull(output6, "Output 6 may not be null");
        Objects.requireNonNull(output7, "Output 7 may not be null");

        if (_shouldRemapInputs) {
          Map<Producer<?>, Producer<?>> inputMapping =
              DAGUtil.createInputMap(_input1, _placeholder1, _input2, _placeholder2, _input3, _placeholder3, _input4,
                  _placeholder4);
          output1 = DAGUtil.replaceInputs(output1, inputMapping);
          output2 = DAGUtil.replaceInputs(output2, inputMapping);
          output3 = DAGUtil.replaceInputs(output3, inputMapping);
          output4 = DAGUtil.replaceInputs(output4, inputMapping);
          output5 = DAGUtil.replaceInputs(output5, inputMapping);
          output6 = DAGUtil.replaceInputs(output6, inputMapping);
          output7 = DAGUtil.replaceInputs(output7, inputMapping);
        }

        List<Producer<?>> inputs = Arrays.asList(_input1, _input2, _input3, _input4);

        return ((DAG4x7.Prepared) DAGUtil
            .createPreparedDAG(Arrays.asList(_placeholder1, _placeholder2, _placeholder3, _placeholder4),
                Arrays.asList(output1, output2, output3, output4, output5, output6, output7)).internalAPI()
            .withInputsUnsafe(inputs)).withReduction(_minimumReducerLevel);
      }

      /**
       * Creates a completed DAG by supplying this partial DAG with its outputs (outputs).
       *
       * @param output1 the first output (output) of the DAG
       * @param output2 the second output (output) of the DAG
       * @param output3 the third output (output) of the DAG
       * @param output4 the fourth output (output) of the DAG
       * @param output5 the fifth output (output) of the DAG
       * @param output6 the sixth output (output) of the DAG
       * @param output7 the seventh output (output) of the DAG
       * @param output8 the eighth output (output) of the DAG
       * @param <RA> the type of the first result
       * @param <RB> the type of the second result
       * @param <RC> the type of the third result
       * @param <RD> the type of the fourth result
       * @param <RE> the type of the fifth result
       * @param <RF> the type of the sixth result
       * @param <RG> the type of the seventh result
       * @param <RH> the type of the eighth result
       * @return a completed DAG with 4 inputs (placeholders) and 8 outputs (outputs).
       */
      public <RA, RB, RC, RD, RE, RF, RG, RH> DAG4x8.Prepared<A, B, C, D, RA, RB, RC, RD, RE, RF, RG, RH> withOutputs(
          Producer<? extends RA> output1, Producer<? extends RB> output2, Producer<? extends RC> output3,
          Producer<? extends RD> output4, Producer<? extends RE> output5, Producer<? extends RF> output6,
          Producer<? extends RG> output7, Producer<? extends RH> output8) {
        Objects.requireNonNull(output1, "Output 1 may not be null");
        Objects.requireNonNull(output2, "Output 2 may not be null");
        Objects.requireNonNull(output3, "Output 3 may not be null");
        Objects.requireNonNull(output4, "Output 4 may not be null");
        Objects.requireNonNull(output5, "Output 5 may not be null");
        Objects.requireNonNull(output6, "Output 6 may not be null");
        Objects.requireNonNull(output7, "Output 7 may not be null");
        Objects.requireNonNull(output8, "Output 8 may not be null");

        if (_shouldRemapInputs) {
          Map<Producer<?>, Producer<?>> inputMapping =
              DAGUtil.createInputMap(_input1, _placeholder1, _input2, _placeholder2, _input3, _placeholder3, _input4,
                  _placeholder4);
          output1 = DAGUtil.replaceInputs(output1, inputMapping);
          output2 = DAGUtil.replaceInputs(output2, inputMapping);
          output3 = DAGUtil.replaceInputs(output3, inputMapping);
          output4 = DAGUtil.replaceInputs(output4, inputMapping);
          output5 = DAGUtil.replaceInputs(output5, inputMapping);
          output6 = DAGUtil.replaceInputs(output6, inputMapping);
          output7 = DAGUtil.replaceInputs(output7, inputMapping);
          output8 = DAGUtil.replaceInputs(output8, inputMapping);
        }

        List<Producer<?>> inputs = Arrays.asList(_input1, _input2, _input3, _input4);

        return ((DAG4x8.Prepared) DAGUtil
            .createPreparedDAG(Arrays.asList(_placeholder1, _placeholder2, _placeholder3, _placeholder4),
                Arrays.asList(output1, output2, output3, output4, output5, output6, output7, output8)).internalAPI()
            .withInputsUnsafe(inputs)).withReduction(_minimumReducerLevel);
      }

      /**
       * Creates a completed DAG by supplying this partial DAG with its outputs (outputs).
       *
       * @param output1 the first output (output) of the DAG
       * @param output2 the second output (output) of the DAG
       * @param output3 the third output (output) of the DAG
       * @param output4 the fourth output (output) of the DAG
       * @param output5 the fifth output (output) of the DAG
       * @param output6 the sixth output (output) of the DAG
       * @param output7 the seventh output (output) of the DAG
       * @param output8 the eighth output (output) of the DAG
       * @param output9 the ninth output (output) of the DAG
       * @param <RA> the type of the first result
       * @param <RB> the type of the second result
       * @param <RC> the type of the third result
       * @param <RD> the type of the fourth result
       * @param <RE> the type of the fifth result
       * @param <RF> the type of the sixth result
       * @param <RG> the type of the seventh result
       * @param <RH> the type of the eighth result
       * @param <RI> the type of the ninth result
       * @return a completed DAG with 4 inputs (placeholders) and 9 outputs (outputs).
       */
      public <RA, RB, RC, RD, RE, RF, RG, RH, RI> DAG4x9.Prepared<A, B, C, D, RA, RB, RC, RD, RE, RF, RG, RH, RI> withOutputs(
          Producer<? extends RA> output1, Producer<? extends RB> output2, Producer<? extends RC> output3,
          Producer<? extends RD> output4, Producer<? extends RE> output5, Producer<? extends RF> output6,
          Producer<? extends RG> output7, Producer<? extends RH> output8, Producer<? extends RI> output9) {
        Objects.requireNonNull(output1, "Output 1 may not be null");
        Objects.requireNonNull(output2, "Output 2 may not be null");
        Objects.requireNonNull(output3, "Output 3 may not be null");
        Objects.requireNonNull(output4, "Output 4 may not be null");
        Objects.requireNonNull(output5, "Output 5 may not be null");
        Objects.requireNonNull(output6, "Output 6 may not be null");
        Objects.requireNonNull(output7, "Output 7 may not be null");
        Objects.requireNonNull(output8, "Output 8 may not be null");
        Objects.requireNonNull(output9, "Output 9 may not be null");

        if (_shouldRemapInputs) {
          Map<Producer<?>, Producer<?>> inputMapping =
              DAGUtil.createInputMap(_input1, _placeholder1, _input2, _placeholder2, _input3, _placeholder3, _input4,
                  _placeholder4);
          output1 = DAGUtil.replaceInputs(output1, inputMapping);
          output2 = DAGUtil.replaceInputs(output2, inputMapping);
          output3 = DAGUtil.replaceInputs(output3, inputMapping);
          output4 = DAGUtil.replaceInputs(output4, inputMapping);
          output5 = DAGUtil.replaceInputs(output5, inputMapping);
          output6 = DAGUtil.replaceInputs(output6, inputMapping);
          output7 = DAGUtil.replaceInputs(output7, inputMapping);
          output8 = DAGUtil.replaceInputs(output8, inputMapping);
          output9 = DAGUtil.replaceInputs(output9, inputMapping);
        }

        List<Producer<?>> inputs = Arrays.asList(_input1, _input2, _input3, _input4);

        return ((DAG4x9.Prepared) DAGUtil
            .createPreparedDAG(Arrays.asList(_placeholder1, _placeholder2, _placeholder3, _placeholder4),
                Arrays.asList(output1, output2, output3, output4, output5, output6, output7, output8, output9))
            .internalAPI().withInputsUnsafe(inputs)).withReduction(_minimumReducerLevel);
      }

      /**
       * Creates a completed DAG by supplying this partial DAG with its outputs (outputs).
       *
       * @param output1 the first output (output) of the DAG
       * @param output2 the second output (output) of the DAG
       * @param output3 the third output (output) of the DAG
       * @param output4 the fourth output (output) of the DAG
       * @param output5 the fifth output (output) of the DAG
       * @param output6 the sixth output (output) of the DAG
       * @param output7 the seventh output (output) of the DAG
       * @param output8 the eighth output (output) of the DAG
       * @param output9 the ninth output (output) of the DAG
       * @param output10 the tenth output (output) of the DAG
       * @param <RA> the type of the first result
       * @param <RB> the type of the second result
       * @param <RC> the type of the third result
       * @param <RD> the type of the fourth result
       * @param <RE> the type of the fifth result
       * @param <RF> the type of the sixth result
       * @param <RG> the type of the seventh result
       * @param <RH> the type of the eighth result
       * @param <RI> the type of the ninth result
       * @param <RJ> the type of the tenth result
       * @return a completed DAG with 4 inputs (placeholders) and 10 outputs (outputs).
       */
      public <RA, RB, RC, RD, RE, RF, RG, RH, RI, RJ> DAG4x10.Prepared<A, B, C, D, RA, RB, RC, RD, RE, RF, RG, RH, RI, RJ> withOutputs(
          Producer<? extends RA> output1, Producer<? extends RB> output2, Producer<? extends RC> output3,
          Producer<? extends RD> output4, Producer<? extends RE> output5, Producer<? extends RF> output6,
          Producer<? extends RG> output7, Producer<? extends RH> output8, Producer<? extends RI> output9,
          Producer<? extends RJ> output10) {
        Objects.requireNonNull(output1, "Output 1 may not be null");
        Objects.requireNonNull(output2, "Output 2 may not be null");
        Objects.requireNonNull(output3, "Output 3 may not be null");
        Objects.requireNonNull(output4, "Output 4 may not be null");
        Objects.requireNonNull(output5, "Output 5 may not be null");
        Objects.requireNonNull(output6, "Output 6 may not be null");
        Objects.requireNonNull(output7, "Output 7 may not be null");
        Objects.requireNonNull(output8, "Output 8 may not be null");
        Objects.requireNonNull(output9, "Output 9 may not be null");
        Objects.requireNonNull(output10, "Output 10 may not be null");

        if (_shouldRemapInputs) {
          Map<Producer<?>, Producer<?>> inputMapping =
              DAGUtil.createInputMap(_input1, _placeholder1, _input2, _placeholder2, _input3, _placeholder3, _input4,
                  _placeholder4);
          output1 = DAGUtil.replaceInputs(output1, inputMapping);
          output2 = DAGUtil.replaceInputs(output2, inputMapping);
          output3 = DAGUtil.replaceInputs(output3, inputMapping);
          output4 = DAGUtil.replaceInputs(output4, inputMapping);
          output5 = DAGUtil.replaceInputs(output5, inputMapping);
          output6 = DAGUtil.replaceInputs(output6, inputMapping);
          output7 = DAGUtil.replaceInputs(output7, inputMapping);
          output8 = DAGUtil.replaceInputs(output8, inputMapping);
          output9 = DAGUtil.replaceInputs(output9, inputMapping);
          output10 = DAGUtil.replaceInputs(output10, inputMapping);
        }

        List<Producer<?>> inputs = Arrays.asList(_input1, _input2, _input3, _input4);

        return ((DAG4x10.Prepared) DAGUtil
            .createPreparedDAG(
                Arrays.asList(_placeholder1, _placeholder2, _placeholder3, _placeholder4),
                Arrays
                    .asList(output1, output2, output3, output4, output5, output6, output7, output8, output9, output10))
            .internalAPI().withInputsUnsafe(inputs)).withReduction(_minimumReducerLevel);
      }
    }

    /**
      * A partial DAG with 5 placeholder.  Partial DAGs are <i>completed</i> to create a usable DAG by specifying
      * the outputs (<i>outputs</i>) of the DAG using the withOutputs(...) methods.
      *
     * @param <A> the type of the first input
     * @param <B> the type of the second input
     * @param <C> the type of the third input
     * @param <D> the type of the fourth input
     * @param <E> the type of the fifth input
      */
    public static class WithPlaceholders5<A, B, C, D, E> extends
        AbstractWithPlaceholders5<A, B, C, D, E, WithPlaceholders5<A, B, C, D, E>> {
      /**
       * Creates a new partial DAG that will be rooted at the provided placeholders.
       *
       * @param placeholder1 the first placeholder
       * @param placeholder2 the second placeholder
       * @param placeholder3 the third placeholder
       * @param placeholder4 the fourth placeholder
       * @param placeholder5 the fifth placeholder
       */
      WithPlaceholders5(Placeholder<? extends A> placeholder1, Placeholder<? extends B> placeholder2,
          Placeholder<? extends C> placeholder3, Placeholder<? extends D> placeholder4,
          Placeholder<? extends E> placeholder5) {
        super(placeholder1, placeholder2, placeholder3, placeholder4, placeholder5);
      }

      /**
       * Creates a new partial DAG that will be rooted at the provided placeholders, which will replace ("remap") the provided
       * "input" nodes that define a subgraph of the original graph (as defined by the ancestors of the outputs that will
       * be provided when the partial DAG is completed).  The input nodes, and any nodes that were exclusively the
       * ancestors of the input nodes, are truncated from the resulting graph.
       *
       * @param placeholder1 the first placeholder
       * @param placeholder2 the second placeholder
       * @param placeholder3 the third placeholder
       * @param placeholder4 the fourth placeholder
       * @param placeholder5 the fifth placeholder
       * @param input1 the first input
       * @param input2 the second input
       * @param input3 the third input
       * @param input4 the fourth input
       * @param input5 the fifth input
       */
      WithPlaceholders5(Placeholder<? extends A> placeholder1, Placeholder<? extends B> placeholder2,
          Placeholder<? extends C> placeholder3, Placeholder<? extends D> placeholder4,
          Placeholder<? extends E> placeholder5, Producer<? extends A> input1, Producer<? extends B> input2,
          Producer<? extends C> input3, Producer<? extends D> input4, Producer<? extends E> input5) {
        super(placeholder1, placeholder2, placeholder3, placeholder4, placeholder5, input1, input2, input3, input4,
            input5);
      }

      /**
       * Creates a completed DAG by supplying this partial DAG with its outputs (outputs).
       *
       * @param output1 the first output (output) of the DAG
       * @param <RA> the type of the first result
       * @return a completed DAG with 5 inputs (placeholders) and 1 output (outputs).
       */
      public <RA> DAG5x1.Prepared<A, B, C, D, E, RA> withOutputs(Producer<? extends RA> output1) {
        Objects.requireNonNull(output1, "Output 1 may not be null");

        if (_shouldRemapInputs) {
          Map<Producer<?>, Producer<?>> inputMapping =
              DAGUtil.createInputMap(_input1, _placeholder1, _input2, _placeholder2, _input3, _placeholder3, _input4,
                  _placeholder4, _input5, _placeholder5);
          output1 = DAGUtil.replaceInputs(output1, inputMapping);
        }

        List<Producer<?>> inputs = Arrays.asList(_input1, _input2, _input3, _input4, _input5);

        return ((DAG5x1.Prepared) DAGUtil
            .createPreparedDAG(
                Arrays.asList(_placeholder1, _placeholder2, _placeholder3, _placeholder4, _placeholder5),
                Arrays.asList(output1)).internalAPI().withInputsUnsafe(inputs)).withReduction(_minimumReducerLevel);
      }

      /**
       * Creates a completed DAG by supplying this partial DAG with its outputs (outputs).
       *
       * @param output1 the first output (output) of the DAG
       * @param <RA> the type of the first result
       * @return a completed DAG with 5 inputs (placeholders) and 1 output (outputs).
       */
      public <RA> DAG5x1.Prepared<A, B, C, D, E, RA> withOutput(Producer<? extends RA> output1) {
        Objects.requireNonNull(output1, "Output 1 may not be null");

        if (_shouldRemapInputs) {
          Map<Producer<?>, Producer<?>> inputMapping =
              DAGUtil.createInputMap(_input1, _placeholder1, _input2, _placeholder2, _input3, _placeholder3, _input4,
                  _placeholder4, _input5, _placeholder5);
          output1 = DAGUtil.replaceInputs(output1, inputMapping);
        }

        List<Producer<?>> inputs = Arrays.asList(_input1, _input2, _input3, _input4, _input5);

        return ((DAG5x1.Prepared) DAGUtil
            .createPreparedDAG(
                Arrays.asList(_placeholder1, _placeholder2, _placeholder3, _placeholder4, _placeholder5),
                Arrays.asList(output1)).internalAPI().withInputsUnsafe(inputs)).withReduction(_minimumReducerLevel);
      }

      /**
       * Creates a completed DAG by supplying this partial DAG with its outputs (outputs).
       *
       * @param output1 the first output (output) of the DAG
       * @param output2 the second output (output) of the DAG
       * @param <RA> the type of the first result
       * @param <RB> the type of the second result
       * @return a completed DAG with 5 inputs (placeholders) and 2 outputs (outputs).
       */
      public <RA, RB> DAG5x2.Prepared<A, B, C, D, E, RA, RB> withOutputs(Producer<? extends RA> output1,
          Producer<? extends RB> output2) {
        Objects.requireNonNull(output1, "Output 1 may not be null");
        Objects.requireNonNull(output2, "Output 2 may not be null");

        if (_shouldRemapInputs) {
          Map<Producer<?>, Producer<?>> inputMapping =
              DAGUtil.createInputMap(_input1, _placeholder1, _input2, _placeholder2, _input3, _placeholder3, _input4,
                  _placeholder4, _input5, _placeholder5);
          output1 = DAGUtil.replaceInputs(output1, inputMapping);
          output2 = DAGUtil.replaceInputs(output2, inputMapping);
        }

        List<Producer<?>> inputs = Arrays.asList(_input1, _input2, _input3, _input4, _input5);

        return ((DAG5x2.Prepared) DAGUtil
            .createPreparedDAG(
                Arrays.asList(_placeholder1, _placeholder2, _placeholder3, _placeholder4, _placeholder5),
                Arrays.asList(output1, output2)).internalAPI().withInputsUnsafe(inputs))
            .withReduction(_minimumReducerLevel);
      }

      /**
       * Creates a completed DAG by supplying this partial DAG with its outputs (outputs).
       *
       * @param output1 the first output (output) of the DAG
       * @param output2 the second output (output) of the DAG
       * @param output3 the third output (output) of the DAG
       * @param <RA> the type of the first result
       * @param <RB> the type of the second result
       * @param <RC> the type of the third result
       * @return a completed DAG with 5 inputs (placeholders) and 3 outputs (outputs).
       */
      public <RA, RB, RC> DAG5x3.Prepared<A, B, C, D, E, RA, RB, RC> withOutputs(Producer<? extends RA> output1,
          Producer<? extends RB> output2, Producer<? extends RC> output3) {
        Objects.requireNonNull(output1, "Output 1 may not be null");
        Objects.requireNonNull(output2, "Output 2 may not be null");
        Objects.requireNonNull(output3, "Output 3 may not be null");

        if (_shouldRemapInputs) {
          Map<Producer<?>, Producer<?>> inputMapping =
              DAGUtil.createInputMap(_input1, _placeholder1, _input2, _placeholder2, _input3, _placeholder3, _input4,
                  _placeholder4, _input5, _placeholder5);
          output1 = DAGUtil.replaceInputs(output1, inputMapping);
          output2 = DAGUtil.replaceInputs(output2, inputMapping);
          output3 = DAGUtil.replaceInputs(output3, inputMapping);
        }

        List<Producer<?>> inputs = Arrays.asList(_input1, _input2, _input3, _input4, _input5);

        return ((DAG5x3.Prepared) DAGUtil
            .createPreparedDAG(
                Arrays.asList(_placeholder1, _placeholder2, _placeholder3, _placeholder4, _placeholder5),
                Arrays.asList(output1, output2, output3)).internalAPI().withInputsUnsafe(inputs))
            .withReduction(_minimumReducerLevel);
      }

      /**
       * Creates a completed DAG by supplying this partial DAG with its outputs (outputs).
       *
       * @param output1 the first output (output) of the DAG
       * @param output2 the second output (output) of the DAG
       * @param output3 the third output (output) of the DAG
       * @param output4 the fourth output (output) of the DAG
       * @param <RA> the type of the first result
       * @param <RB> the type of the second result
       * @param <RC> the type of the third result
       * @param <RD> the type of the fourth result
       * @return a completed DAG with 5 inputs (placeholders) and 4 outputs (outputs).
       */
      public <RA, RB, RC, RD> DAG5x4.Prepared<A, B, C, D, E, RA, RB, RC, RD> withOutputs(
          Producer<? extends RA> output1, Producer<? extends RB> output2, Producer<? extends RC> output3,
          Producer<? extends RD> output4) {
        Objects.requireNonNull(output1, "Output 1 may not be null");
        Objects.requireNonNull(output2, "Output 2 may not be null");
        Objects.requireNonNull(output3, "Output 3 may not be null");
        Objects.requireNonNull(output4, "Output 4 may not be null");

        if (_shouldRemapInputs) {
          Map<Producer<?>, Producer<?>> inputMapping =
              DAGUtil.createInputMap(_input1, _placeholder1, _input2, _placeholder2, _input3, _placeholder3, _input4,
                  _placeholder4, _input5, _placeholder5);
          output1 = DAGUtil.replaceInputs(output1, inputMapping);
          output2 = DAGUtil.replaceInputs(output2, inputMapping);
          output3 = DAGUtil.replaceInputs(output3, inputMapping);
          output4 = DAGUtil.replaceInputs(output4, inputMapping);
        }

        List<Producer<?>> inputs = Arrays.asList(_input1, _input2, _input3, _input4, _input5);

        return ((DAG5x4.Prepared) DAGUtil
            .createPreparedDAG(
                Arrays.asList(_placeholder1, _placeholder2, _placeholder3, _placeholder4, _placeholder5),
                Arrays.asList(output1, output2, output3, output4)).internalAPI().withInputsUnsafe(inputs))
            .withReduction(_minimumReducerLevel);
      }

      /**
       * Creates a completed DAG by supplying this partial DAG with its outputs (outputs).
       *
       * @param output1 the first output (output) of the DAG
       * @param output2 the second output (output) of the DAG
       * @param output3 the third output (output) of the DAG
       * @param output4 the fourth output (output) of the DAG
       * @param output5 the fifth output (output) of the DAG
       * @param <RA> the type of the first result
       * @param <RB> the type of the second result
       * @param <RC> the type of the third result
       * @param <RD> the type of the fourth result
       * @param <RE> the type of the fifth result
       * @return a completed DAG with 5 inputs (placeholders) and 5 outputs (outputs).
       */
      public <RA, RB, RC, RD, RE> DAG5x5.Prepared<A, B, C, D, E, RA, RB, RC, RD, RE> withOutputs(
          Producer<? extends RA> output1, Producer<? extends RB> output2, Producer<? extends RC> output3,
          Producer<? extends RD> output4, Producer<? extends RE> output5) {
        Objects.requireNonNull(output1, "Output 1 may not be null");
        Objects.requireNonNull(output2, "Output 2 may not be null");
        Objects.requireNonNull(output3, "Output 3 may not be null");
        Objects.requireNonNull(output4, "Output 4 may not be null");
        Objects.requireNonNull(output5, "Output 5 may not be null");

        if (_shouldRemapInputs) {
          Map<Producer<?>, Producer<?>> inputMapping =
              DAGUtil.createInputMap(_input1, _placeholder1, _input2, _placeholder2, _input3, _placeholder3, _input4,
                  _placeholder4, _input5, _placeholder5);
          output1 = DAGUtil.replaceInputs(output1, inputMapping);
          output2 = DAGUtil.replaceInputs(output2, inputMapping);
          output3 = DAGUtil.replaceInputs(output3, inputMapping);
          output4 = DAGUtil.replaceInputs(output4, inputMapping);
          output5 = DAGUtil.replaceInputs(output5, inputMapping);
        }

        List<Producer<?>> inputs = Arrays.asList(_input1, _input2, _input3, _input4, _input5);

        return ((DAG5x5.Prepared) DAGUtil
            .createPreparedDAG(
                Arrays.asList(_placeholder1, _placeholder2, _placeholder3, _placeholder4, _placeholder5),
                Arrays.asList(output1, output2, output3, output4, output5)).internalAPI().withInputsUnsafe(inputs))
            .withReduction(_minimumReducerLevel);
      }

      /**
       * Creates a completed DAG by supplying this partial DAG with its outputs (outputs).
       *
       * @param output1 the first output (output) of the DAG
       * @param output2 the second output (output) of the DAG
       * @param output3 the third output (output) of the DAG
       * @param output4 the fourth output (output) of the DAG
       * @param output5 the fifth output (output) of the DAG
       * @param output6 the sixth output (output) of the DAG
       * @param <RA> the type of the first result
       * @param <RB> the type of the second result
       * @param <RC> the type of the third result
       * @param <RD> the type of the fourth result
       * @param <RE> the type of the fifth result
       * @param <RF> the type of the sixth result
       * @return a completed DAG with 5 inputs (placeholders) and 6 outputs (outputs).
       */
      public <RA, RB, RC, RD, RE, RF> DAG5x6.Prepared<A, B, C, D, E, RA, RB, RC, RD, RE, RF> withOutputs(
          Producer<? extends RA> output1, Producer<? extends RB> output2, Producer<? extends RC> output3,
          Producer<? extends RD> output4, Producer<? extends RE> output5, Producer<? extends RF> output6) {
        Objects.requireNonNull(output1, "Output 1 may not be null");
        Objects.requireNonNull(output2, "Output 2 may not be null");
        Objects.requireNonNull(output3, "Output 3 may not be null");
        Objects.requireNonNull(output4, "Output 4 may not be null");
        Objects.requireNonNull(output5, "Output 5 may not be null");
        Objects.requireNonNull(output6, "Output 6 may not be null");

        if (_shouldRemapInputs) {
          Map<Producer<?>, Producer<?>> inputMapping =
              DAGUtil.createInputMap(_input1, _placeholder1, _input2, _placeholder2, _input3, _placeholder3, _input4,
                  _placeholder4, _input5, _placeholder5);
          output1 = DAGUtil.replaceInputs(output1, inputMapping);
          output2 = DAGUtil.replaceInputs(output2, inputMapping);
          output3 = DAGUtil.replaceInputs(output3, inputMapping);
          output4 = DAGUtil.replaceInputs(output4, inputMapping);
          output5 = DAGUtil.replaceInputs(output5, inputMapping);
          output6 = DAGUtil.replaceInputs(output6, inputMapping);
        }

        List<Producer<?>> inputs = Arrays.asList(_input1, _input2, _input3, _input4, _input5);

        return ((DAG5x6.Prepared) DAGUtil
            .createPreparedDAG(
                Arrays.asList(_placeholder1, _placeholder2, _placeholder3, _placeholder4, _placeholder5),
                Arrays.asList(output1, output2, output3, output4, output5, output6)).internalAPI()
            .withInputsUnsafe(inputs)).withReduction(_minimumReducerLevel);
      }

      /**
       * Creates a completed DAG by supplying this partial DAG with its outputs (outputs).
       *
       * @param output1 the first output (output) of the DAG
       * @param output2 the second output (output) of the DAG
       * @param output3 the third output (output) of the DAG
       * @param output4 the fourth output (output) of the DAG
       * @param output5 the fifth output (output) of the DAG
       * @param output6 the sixth output (output) of the DAG
       * @param output7 the seventh output (output) of the DAG
       * @param <RA> the type of the first result
       * @param <RB> the type of the second result
       * @param <RC> the type of the third result
       * @param <RD> the type of the fourth result
       * @param <RE> the type of the fifth result
       * @param <RF> the type of the sixth result
       * @param <RG> the type of the seventh result
       * @return a completed DAG with 5 inputs (placeholders) and 7 outputs (outputs).
       */
      public <RA, RB, RC, RD, RE, RF, RG> DAG5x7.Prepared<A, B, C, D, E, RA, RB, RC, RD, RE, RF, RG> withOutputs(
          Producer<? extends RA> output1, Producer<? extends RB> output2, Producer<? extends RC> output3,
          Producer<? extends RD> output4, Producer<? extends RE> output5, Producer<? extends RF> output6,
          Producer<? extends RG> output7) {
        Objects.requireNonNull(output1, "Output 1 may not be null");
        Objects.requireNonNull(output2, "Output 2 may not be null");
        Objects.requireNonNull(output3, "Output 3 may not be null");
        Objects.requireNonNull(output4, "Output 4 may not be null");
        Objects.requireNonNull(output5, "Output 5 may not be null");
        Objects.requireNonNull(output6, "Output 6 may not be null");
        Objects.requireNonNull(output7, "Output 7 may not be null");

        if (_shouldRemapInputs) {
          Map<Producer<?>, Producer<?>> inputMapping =
              DAGUtil.createInputMap(_input1, _placeholder1, _input2, _placeholder2, _input3, _placeholder3, _input4,
                  _placeholder4, _input5, _placeholder5);
          output1 = DAGUtil.replaceInputs(output1, inputMapping);
          output2 = DAGUtil.replaceInputs(output2, inputMapping);
          output3 = DAGUtil.replaceInputs(output3, inputMapping);
          output4 = DAGUtil.replaceInputs(output4, inputMapping);
          output5 = DAGUtil.replaceInputs(output5, inputMapping);
          output6 = DAGUtil.replaceInputs(output6, inputMapping);
          output7 = DAGUtil.replaceInputs(output7, inputMapping);
        }

        List<Producer<?>> inputs = Arrays.asList(_input1, _input2, _input3, _input4, _input5);

        return ((DAG5x7.Prepared) DAGUtil
            .createPreparedDAG(
                Arrays.asList(_placeholder1, _placeholder2, _placeholder3, _placeholder4, _placeholder5),
                Arrays.asList(output1, output2, output3, output4, output5, output6, output7)).internalAPI()
            .withInputsUnsafe(inputs)).withReduction(_minimumReducerLevel);
      }

      /**
       * Creates a completed DAG by supplying this partial DAG with its outputs (outputs).
       *
       * @param output1 the first output (output) of the DAG
       * @param output2 the second output (output) of the DAG
       * @param output3 the third output (output) of the DAG
       * @param output4 the fourth output (output) of the DAG
       * @param output5 the fifth output (output) of the DAG
       * @param output6 the sixth output (output) of the DAG
       * @param output7 the seventh output (output) of the DAG
       * @param output8 the eighth output (output) of the DAG
       * @param <RA> the type of the first result
       * @param <RB> the type of the second result
       * @param <RC> the type of the third result
       * @param <RD> the type of the fourth result
       * @param <RE> the type of the fifth result
       * @param <RF> the type of the sixth result
       * @param <RG> the type of the seventh result
       * @param <RH> the type of the eighth result
       * @return a completed DAG with 5 inputs (placeholders) and 8 outputs (outputs).
       */
      public <RA, RB, RC, RD, RE, RF, RG, RH> DAG5x8.Prepared<A, B, C, D, E, RA, RB, RC, RD, RE, RF, RG, RH> withOutputs(
          Producer<? extends RA> output1, Producer<? extends RB> output2, Producer<? extends RC> output3,
          Producer<? extends RD> output4, Producer<? extends RE> output5, Producer<? extends RF> output6,
          Producer<? extends RG> output7, Producer<? extends RH> output8) {
        Objects.requireNonNull(output1, "Output 1 may not be null");
        Objects.requireNonNull(output2, "Output 2 may not be null");
        Objects.requireNonNull(output3, "Output 3 may not be null");
        Objects.requireNonNull(output4, "Output 4 may not be null");
        Objects.requireNonNull(output5, "Output 5 may not be null");
        Objects.requireNonNull(output6, "Output 6 may not be null");
        Objects.requireNonNull(output7, "Output 7 may not be null");
        Objects.requireNonNull(output8, "Output 8 may not be null");

        if (_shouldRemapInputs) {
          Map<Producer<?>, Producer<?>> inputMapping =
              DAGUtil.createInputMap(_input1, _placeholder1, _input2, _placeholder2, _input3, _placeholder3, _input4,
                  _placeholder4, _input5, _placeholder5);
          output1 = DAGUtil.replaceInputs(output1, inputMapping);
          output2 = DAGUtil.replaceInputs(output2, inputMapping);
          output3 = DAGUtil.replaceInputs(output3, inputMapping);
          output4 = DAGUtil.replaceInputs(output4, inputMapping);
          output5 = DAGUtil.replaceInputs(output5, inputMapping);
          output6 = DAGUtil.replaceInputs(output6, inputMapping);
          output7 = DAGUtil.replaceInputs(output7, inputMapping);
          output8 = DAGUtil.replaceInputs(output8, inputMapping);
        }

        List<Producer<?>> inputs = Arrays.asList(_input1, _input2, _input3, _input4, _input5);

        return ((DAG5x8.Prepared) DAGUtil
            .createPreparedDAG(
                Arrays.asList(_placeholder1, _placeholder2, _placeholder3, _placeholder4, _placeholder5),
                Arrays.asList(output1, output2, output3, output4, output5, output6, output7, output8)).internalAPI()
            .withInputsUnsafe(inputs)).withReduction(_minimumReducerLevel);
      }

      /**
       * Creates a completed DAG by supplying this partial DAG with its outputs (outputs).
       *
       * @param output1 the first output (output) of the DAG
       * @param output2 the second output (output) of the DAG
       * @param output3 the third output (output) of the DAG
       * @param output4 the fourth output (output) of the DAG
       * @param output5 the fifth output (output) of the DAG
       * @param output6 the sixth output (output) of the DAG
       * @param output7 the seventh output (output) of the DAG
       * @param output8 the eighth output (output) of the DAG
       * @param output9 the ninth output (output) of the DAG
       * @param <RA> the type of the first result
       * @param <RB> the type of the second result
       * @param <RC> the type of the third result
       * @param <RD> the type of the fourth result
       * @param <RE> the type of the fifth result
       * @param <RF> the type of the sixth result
       * @param <RG> the type of the seventh result
       * @param <RH> the type of the eighth result
       * @param <RI> the type of the ninth result
       * @return a completed DAG with 5 inputs (placeholders) and 9 outputs (outputs).
       */
      public <RA, RB, RC, RD, RE, RF, RG, RH, RI> DAG5x9.Prepared<A, B, C, D, E, RA, RB, RC, RD, RE, RF, RG, RH, RI> withOutputs(
          Producer<? extends RA> output1, Producer<? extends RB> output2, Producer<? extends RC> output3,
          Producer<? extends RD> output4, Producer<? extends RE> output5, Producer<? extends RF> output6,
          Producer<? extends RG> output7, Producer<? extends RH> output8, Producer<? extends RI> output9) {
        Objects.requireNonNull(output1, "Output 1 may not be null");
        Objects.requireNonNull(output2, "Output 2 may not be null");
        Objects.requireNonNull(output3, "Output 3 may not be null");
        Objects.requireNonNull(output4, "Output 4 may not be null");
        Objects.requireNonNull(output5, "Output 5 may not be null");
        Objects.requireNonNull(output6, "Output 6 may not be null");
        Objects.requireNonNull(output7, "Output 7 may not be null");
        Objects.requireNonNull(output8, "Output 8 may not be null");
        Objects.requireNonNull(output9, "Output 9 may not be null");

        if (_shouldRemapInputs) {
          Map<Producer<?>, Producer<?>> inputMapping =
              DAGUtil.createInputMap(_input1, _placeholder1, _input2, _placeholder2, _input3, _placeholder3, _input4,
                  _placeholder4, _input5, _placeholder5);
          output1 = DAGUtil.replaceInputs(output1, inputMapping);
          output2 = DAGUtil.replaceInputs(output2, inputMapping);
          output3 = DAGUtil.replaceInputs(output3, inputMapping);
          output4 = DAGUtil.replaceInputs(output4, inputMapping);
          output5 = DAGUtil.replaceInputs(output5, inputMapping);
          output6 = DAGUtil.replaceInputs(output6, inputMapping);
          output7 = DAGUtil.replaceInputs(output7, inputMapping);
          output8 = DAGUtil.replaceInputs(output8, inputMapping);
          output9 = DAGUtil.replaceInputs(output9, inputMapping);
        }

        List<Producer<?>> inputs = Arrays.asList(_input1, _input2, _input3, _input4, _input5);

        return ((DAG5x9.Prepared) DAGUtil
            .createPreparedDAG(
                Arrays.asList(_placeholder1, _placeholder2, _placeholder3, _placeholder4, _placeholder5),
                Arrays.asList(output1, output2, output3, output4, output5, output6, output7, output8, output9))
            .internalAPI().withInputsUnsafe(inputs)).withReduction(_minimumReducerLevel);
      }

      /**
       * Creates a completed DAG by supplying this partial DAG with its outputs (outputs).
       *
       * @param output1 the first output (output) of the DAG
       * @param output2 the second output (output) of the DAG
       * @param output3 the third output (output) of the DAG
       * @param output4 the fourth output (output) of the DAG
       * @param output5 the fifth output (output) of the DAG
       * @param output6 the sixth output (output) of the DAG
       * @param output7 the seventh output (output) of the DAG
       * @param output8 the eighth output (output) of the DAG
       * @param output9 the ninth output (output) of the DAG
       * @param output10 the tenth output (output) of the DAG
       * @param <RA> the type of the first result
       * @param <RB> the type of the second result
       * @param <RC> the type of the third result
       * @param <RD> the type of the fourth result
       * @param <RE> the type of the fifth result
       * @param <RF> the type of the sixth result
       * @param <RG> the type of the seventh result
       * @param <RH> the type of the eighth result
       * @param <RI> the type of the ninth result
       * @param <RJ> the type of the tenth result
       * @return a completed DAG with 5 inputs (placeholders) and 10 outputs (outputs).
       */
      public <RA, RB, RC, RD, RE, RF, RG, RH, RI, RJ> DAG5x10.Prepared<A, B, C, D, E, RA, RB, RC, RD, RE, RF, RG, RH, RI, RJ> withOutputs(
          Producer<? extends RA> output1, Producer<? extends RB> output2, Producer<? extends RC> output3,
          Producer<? extends RD> output4, Producer<? extends RE> output5, Producer<? extends RF> output6,
          Producer<? extends RG> output7, Producer<? extends RH> output8, Producer<? extends RI> output9,
          Producer<? extends RJ> output10) {
        Objects.requireNonNull(output1, "Output 1 may not be null");
        Objects.requireNonNull(output2, "Output 2 may not be null");
        Objects.requireNonNull(output3, "Output 3 may not be null");
        Objects.requireNonNull(output4, "Output 4 may not be null");
        Objects.requireNonNull(output5, "Output 5 may not be null");
        Objects.requireNonNull(output6, "Output 6 may not be null");
        Objects.requireNonNull(output7, "Output 7 may not be null");
        Objects.requireNonNull(output8, "Output 8 may not be null");
        Objects.requireNonNull(output9, "Output 9 may not be null");
        Objects.requireNonNull(output10, "Output 10 may not be null");

        if (_shouldRemapInputs) {
          Map<Producer<?>, Producer<?>> inputMapping =
              DAGUtil.createInputMap(_input1, _placeholder1, _input2, _placeholder2, _input3, _placeholder3, _input4,
                  _placeholder4, _input5, _placeholder5);
          output1 = DAGUtil.replaceInputs(output1, inputMapping);
          output2 = DAGUtil.replaceInputs(output2, inputMapping);
          output3 = DAGUtil.replaceInputs(output3, inputMapping);
          output4 = DAGUtil.replaceInputs(output4, inputMapping);
          output5 = DAGUtil.replaceInputs(output5, inputMapping);
          output6 = DAGUtil.replaceInputs(output6, inputMapping);
          output7 = DAGUtil.replaceInputs(output7, inputMapping);
          output8 = DAGUtil.replaceInputs(output8, inputMapping);
          output9 = DAGUtil.replaceInputs(output9, inputMapping);
          output10 = DAGUtil.replaceInputs(output10, inputMapping);
        }

        List<Producer<?>> inputs = Arrays.asList(_input1, _input2, _input3, _input4, _input5);

        return ((DAG5x10.Prepared) DAGUtil
            .createPreparedDAG(
                Arrays.asList(_placeholder1, _placeholder2, _placeholder3, _placeholder4, _placeholder5),
                Arrays
                    .asList(output1, output2, output3, output4, output5, output6, output7, output8, output9, output10))
            .internalAPI().withInputsUnsafe(inputs)).withReduction(_minimumReducerLevel);
      }
    }

    /**
      * A partial DAG with 6 placeholder.  Partial DAGs are <i>completed</i> to create a usable DAG by specifying
      * the outputs (<i>outputs</i>) of the DAG using the withOutputs(...) methods.
      *
     * @param <A> the type of the first input
     * @param <B> the type of the second input
     * @param <C> the type of the third input
     * @param <D> the type of the fourth input
     * @param <E> the type of the fifth input
     * @param <F> the type of the sixth input
      */
    public static class WithPlaceholders6<A, B, C, D, E, F> extends
        AbstractWithPlaceholders6<A, B, C, D, E, F, WithPlaceholders6<A, B, C, D, E, F>> {
      /**
       * Creates a new partial DAG that will be rooted at the provided placeholders.
       *
       * @param placeholder1 the first placeholder
       * @param placeholder2 the second placeholder
       * @param placeholder3 the third placeholder
       * @param placeholder4 the fourth placeholder
       * @param placeholder5 the fifth placeholder
       * @param placeholder6 the sixth placeholder
       */
      WithPlaceholders6(Placeholder<? extends A> placeholder1, Placeholder<? extends B> placeholder2,
          Placeholder<? extends C> placeholder3, Placeholder<? extends D> placeholder4,
          Placeholder<? extends E> placeholder5, Placeholder<? extends F> placeholder6) {
        super(placeholder1, placeholder2, placeholder3, placeholder4, placeholder5, placeholder6);
      }

      /**
       * Creates a new partial DAG that will be rooted at the provided placeholders, which will replace ("remap") the provided
       * "input" nodes that define a subgraph of the original graph (as defined by the ancestors of the outputs that will
       * be provided when the partial DAG is completed).  The input nodes, and any nodes that were exclusively the
       * ancestors of the input nodes, are truncated from the resulting graph.
       *
       * @param placeholder1 the first placeholder
       * @param placeholder2 the second placeholder
       * @param placeholder3 the third placeholder
       * @param placeholder4 the fourth placeholder
       * @param placeholder5 the fifth placeholder
       * @param placeholder6 the sixth placeholder
       * @param input1 the first input
       * @param input2 the second input
       * @param input3 the third input
       * @param input4 the fourth input
       * @param input5 the fifth input
       * @param input6 the sixth input
       */
      WithPlaceholders6(Placeholder<? extends A> placeholder1, Placeholder<? extends B> placeholder2,
          Placeholder<? extends C> placeholder3, Placeholder<? extends D> placeholder4,
          Placeholder<? extends E> placeholder5, Placeholder<? extends F> placeholder6, Producer<? extends A> input1,
          Producer<? extends B> input2, Producer<? extends C> input3, Producer<? extends D> input4,
          Producer<? extends E> input5, Producer<? extends F> input6) {
        super(placeholder1, placeholder2, placeholder3, placeholder4, placeholder5, placeholder6, input1, input2,
            input3, input4, input5, input6);
      }

      /**
       * Creates a completed DAG by supplying this partial DAG with its outputs (outputs).
       *
       * @param output1 the first output (output) of the DAG
       * @param <RA> the type of the first result
       * @return a completed DAG with 6 inputs (placeholders) and 1 output (outputs).
       */
      public <RA> DAG6x1.Prepared<A, B, C, D, E, F, RA> withOutputs(Producer<? extends RA> output1) {
        Objects.requireNonNull(output1, "Output 1 may not be null");

        if (_shouldRemapInputs) {
          Map<Producer<?>, Producer<?>> inputMapping =
              DAGUtil.createInputMap(_input1, _placeholder1, _input2, _placeholder2, _input3, _placeholder3, _input4,
                  _placeholder4, _input5, _placeholder5, _input6, _placeholder6);
          output1 = DAGUtil.replaceInputs(output1, inputMapping);
        }

        List<Producer<?>> inputs = Arrays.asList(_input1, _input2, _input3, _input4, _input5, _input6);

        return ((DAG6x1.Prepared) DAGUtil
            .createPreparedDAG(
                Arrays.asList(_placeholder1, _placeholder2, _placeholder3, _placeholder4, _placeholder5, _placeholder6),
                Arrays.asList(output1)).internalAPI().withInputsUnsafe(inputs)).withReduction(_minimumReducerLevel);
      }

      /**
       * Creates a completed DAG by supplying this partial DAG with its outputs (outputs).
       *
       * @param output1 the first output (output) of the DAG
       * @param <RA> the type of the first result
       * @return a completed DAG with 6 inputs (placeholders) and 1 output (outputs).
       */
      public <RA> DAG6x1.Prepared<A, B, C, D, E, F, RA> withOutput(Producer<? extends RA> output1) {
        Objects.requireNonNull(output1, "Output 1 may not be null");

        if (_shouldRemapInputs) {
          Map<Producer<?>, Producer<?>> inputMapping =
              DAGUtil.createInputMap(_input1, _placeholder1, _input2, _placeholder2, _input3, _placeholder3, _input4,
                  _placeholder4, _input5, _placeholder5, _input6, _placeholder6);
          output1 = DAGUtil.replaceInputs(output1, inputMapping);
        }

        List<Producer<?>> inputs = Arrays.asList(_input1, _input2, _input3, _input4, _input5, _input6);

        return ((DAG6x1.Prepared) DAGUtil
            .createPreparedDAG(
                Arrays.asList(_placeholder1, _placeholder2, _placeholder3, _placeholder4, _placeholder5, _placeholder6),
                Arrays.asList(output1)).internalAPI().withInputsUnsafe(inputs)).withReduction(_minimumReducerLevel);
      }

      /**
       * Creates a completed DAG by supplying this partial DAG with its outputs (outputs).
       *
       * @param output1 the first output (output) of the DAG
       * @param output2 the second output (output) of the DAG
       * @param <RA> the type of the first result
       * @param <RB> the type of the second result
       * @return a completed DAG with 6 inputs (placeholders) and 2 outputs (outputs).
       */
      public <RA, RB> DAG6x2.Prepared<A, B, C, D, E, F, RA, RB> withOutputs(Producer<? extends RA> output1,
          Producer<? extends RB> output2) {
        Objects.requireNonNull(output1, "Output 1 may not be null");
        Objects.requireNonNull(output2, "Output 2 may not be null");

        if (_shouldRemapInputs) {
          Map<Producer<?>, Producer<?>> inputMapping =
              DAGUtil.createInputMap(_input1, _placeholder1, _input2, _placeholder2, _input3, _placeholder3, _input4,
                  _placeholder4, _input5, _placeholder5, _input6, _placeholder6);
          output1 = DAGUtil.replaceInputs(output1, inputMapping);
          output2 = DAGUtil.replaceInputs(output2, inputMapping);
        }

        List<Producer<?>> inputs = Arrays.asList(_input1, _input2, _input3, _input4, _input5, _input6);

        return ((DAG6x2.Prepared) DAGUtil
            .createPreparedDAG(
                Arrays.asList(_placeholder1, _placeholder2, _placeholder3, _placeholder4, _placeholder5, _placeholder6),
                Arrays.asList(output1, output2)).internalAPI().withInputsUnsafe(inputs))
            .withReduction(_minimumReducerLevel);
      }

      /**
       * Creates a completed DAG by supplying this partial DAG with its outputs (outputs).
       *
       * @param output1 the first output (output) of the DAG
       * @param output2 the second output (output) of the DAG
       * @param output3 the third output (output) of the DAG
       * @param <RA> the type of the first result
       * @param <RB> the type of the second result
       * @param <RC> the type of the third result
       * @return a completed DAG with 6 inputs (placeholders) and 3 outputs (outputs).
       */
      public <RA, RB, RC> DAG6x3.Prepared<A, B, C, D, E, F, RA, RB, RC> withOutputs(Producer<? extends RA> output1,
          Producer<? extends RB> output2, Producer<? extends RC> output3) {
        Objects.requireNonNull(output1, "Output 1 may not be null");
        Objects.requireNonNull(output2, "Output 2 may not be null");
        Objects.requireNonNull(output3, "Output 3 may not be null");

        if (_shouldRemapInputs) {
          Map<Producer<?>, Producer<?>> inputMapping =
              DAGUtil.createInputMap(_input1, _placeholder1, _input2, _placeholder2, _input3, _placeholder3, _input4,
                  _placeholder4, _input5, _placeholder5, _input6, _placeholder6);
          output1 = DAGUtil.replaceInputs(output1, inputMapping);
          output2 = DAGUtil.replaceInputs(output2, inputMapping);
          output3 = DAGUtil.replaceInputs(output3, inputMapping);
        }

        List<Producer<?>> inputs = Arrays.asList(_input1, _input2, _input3, _input4, _input5, _input6);

        return ((DAG6x3.Prepared) DAGUtil
            .createPreparedDAG(
                Arrays.asList(_placeholder1, _placeholder2, _placeholder3, _placeholder4, _placeholder5, _placeholder6),
                Arrays.asList(output1, output2, output3)).internalAPI().withInputsUnsafe(inputs))
            .withReduction(_minimumReducerLevel);
      }

      /**
       * Creates a completed DAG by supplying this partial DAG with its outputs (outputs).
       *
       * @param output1 the first output (output) of the DAG
       * @param output2 the second output (output) of the DAG
       * @param output3 the third output (output) of the DAG
       * @param output4 the fourth output (output) of the DAG
       * @param <RA> the type of the first result
       * @param <RB> the type of the second result
       * @param <RC> the type of the third result
       * @param <RD> the type of the fourth result
       * @return a completed DAG with 6 inputs (placeholders) and 4 outputs (outputs).
       */
      public <RA, RB, RC, RD> DAG6x4.Prepared<A, B, C, D, E, F, RA, RB, RC, RD> withOutputs(
          Producer<? extends RA> output1, Producer<? extends RB> output2, Producer<? extends RC> output3,
          Producer<? extends RD> output4) {
        Objects.requireNonNull(output1, "Output 1 may not be null");
        Objects.requireNonNull(output2, "Output 2 may not be null");
        Objects.requireNonNull(output3, "Output 3 may not be null");
        Objects.requireNonNull(output4, "Output 4 may not be null");

        if (_shouldRemapInputs) {
          Map<Producer<?>, Producer<?>> inputMapping =
              DAGUtil.createInputMap(_input1, _placeholder1, _input2, _placeholder2, _input3, _placeholder3, _input4,
                  _placeholder4, _input5, _placeholder5, _input6, _placeholder6);
          output1 = DAGUtil.replaceInputs(output1, inputMapping);
          output2 = DAGUtil.replaceInputs(output2, inputMapping);
          output3 = DAGUtil.replaceInputs(output3, inputMapping);
          output4 = DAGUtil.replaceInputs(output4, inputMapping);
        }

        List<Producer<?>> inputs = Arrays.asList(_input1, _input2, _input3, _input4, _input5, _input6);

        return ((DAG6x4.Prepared) DAGUtil
            .createPreparedDAG(
                Arrays.asList(_placeholder1, _placeholder2, _placeholder3, _placeholder4, _placeholder5, _placeholder6),
                Arrays.asList(output1, output2, output3, output4)).internalAPI().withInputsUnsafe(inputs))
            .withReduction(_minimumReducerLevel);
      }

      /**
       * Creates a completed DAG by supplying this partial DAG with its outputs (outputs).
       *
       * @param output1 the first output (output) of the DAG
       * @param output2 the second output (output) of the DAG
       * @param output3 the third output (output) of the DAG
       * @param output4 the fourth output (output) of the DAG
       * @param output5 the fifth output (output) of the DAG
       * @param <RA> the type of the first result
       * @param <RB> the type of the second result
       * @param <RC> the type of the third result
       * @param <RD> the type of the fourth result
       * @param <RE> the type of the fifth result
       * @return a completed DAG with 6 inputs (placeholders) and 5 outputs (outputs).
       */
      public <RA, RB, RC, RD, RE> DAG6x5.Prepared<A, B, C, D, E, F, RA, RB, RC, RD, RE> withOutputs(
          Producer<? extends RA> output1, Producer<? extends RB> output2, Producer<? extends RC> output3,
          Producer<? extends RD> output4, Producer<? extends RE> output5) {
        Objects.requireNonNull(output1, "Output 1 may not be null");
        Objects.requireNonNull(output2, "Output 2 may not be null");
        Objects.requireNonNull(output3, "Output 3 may not be null");
        Objects.requireNonNull(output4, "Output 4 may not be null");
        Objects.requireNonNull(output5, "Output 5 may not be null");

        if (_shouldRemapInputs) {
          Map<Producer<?>, Producer<?>> inputMapping =
              DAGUtil.createInputMap(_input1, _placeholder1, _input2, _placeholder2, _input3, _placeholder3, _input4,
                  _placeholder4, _input5, _placeholder5, _input6, _placeholder6);
          output1 = DAGUtil.replaceInputs(output1, inputMapping);
          output2 = DAGUtil.replaceInputs(output2, inputMapping);
          output3 = DAGUtil.replaceInputs(output3, inputMapping);
          output4 = DAGUtil.replaceInputs(output4, inputMapping);
          output5 = DAGUtil.replaceInputs(output5, inputMapping);
        }

        List<Producer<?>> inputs = Arrays.asList(_input1, _input2, _input3, _input4, _input5, _input6);

        return ((DAG6x5.Prepared) DAGUtil
            .createPreparedDAG(
                Arrays.asList(_placeholder1, _placeholder2, _placeholder3, _placeholder4, _placeholder5, _placeholder6),
                Arrays.asList(output1, output2, output3, output4, output5)).internalAPI().withInputsUnsafe(inputs))
            .withReduction(_minimumReducerLevel);
      }

      /**
       * Creates a completed DAG by supplying this partial DAG with its outputs (outputs).
       *
       * @param output1 the first output (output) of the DAG
       * @param output2 the second output (output) of the DAG
       * @param output3 the third output (output) of the DAG
       * @param output4 the fourth output (output) of the DAG
       * @param output5 the fifth output (output) of the DAG
       * @param output6 the sixth output (output) of the DAG
       * @param <RA> the type of the first result
       * @param <RB> the type of the second result
       * @param <RC> the type of the third result
       * @param <RD> the type of the fourth result
       * @param <RE> the type of the fifth result
       * @param <RF> the type of the sixth result
       * @return a completed DAG with 6 inputs (placeholders) and 6 outputs (outputs).
       */
      public <RA, RB, RC, RD, RE, RF> DAG6x6.Prepared<A, B, C, D, E, F, RA, RB, RC, RD, RE, RF> withOutputs(
          Producer<? extends RA> output1, Producer<? extends RB> output2, Producer<? extends RC> output3,
          Producer<? extends RD> output4, Producer<? extends RE> output5, Producer<? extends RF> output6) {
        Objects.requireNonNull(output1, "Output 1 may not be null");
        Objects.requireNonNull(output2, "Output 2 may not be null");
        Objects.requireNonNull(output3, "Output 3 may not be null");
        Objects.requireNonNull(output4, "Output 4 may not be null");
        Objects.requireNonNull(output5, "Output 5 may not be null");
        Objects.requireNonNull(output6, "Output 6 may not be null");

        if (_shouldRemapInputs) {
          Map<Producer<?>, Producer<?>> inputMapping =
              DAGUtil.createInputMap(_input1, _placeholder1, _input2, _placeholder2, _input3, _placeholder3, _input4,
                  _placeholder4, _input5, _placeholder5, _input6, _placeholder6);
          output1 = DAGUtil.replaceInputs(output1, inputMapping);
          output2 = DAGUtil.replaceInputs(output2, inputMapping);
          output3 = DAGUtil.replaceInputs(output3, inputMapping);
          output4 = DAGUtil.replaceInputs(output4, inputMapping);
          output5 = DAGUtil.replaceInputs(output5, inputMapping);
          output6 = DAGUtil.replaceInputs(output6, inputMapping);
        }

        List<Producer<?>> inputs = Arrays.asList(_input1, _input2, _input3, _input4, _input5, _input6);

        return ((DAG6x6.Prepared) DAGUtil
            .createPreparedDAG(
                Arrays.asList(_placeholder1, _placeholder2, _placeholder3, _placeholder4, _placeholder5, _placeholder6),
                Arrays.asList(output1, output2, output3, output4, output5, output6)).internalAPI()
            .withInputsUnsafe(inputs)).withReduction(_minimumReducerLevel);
      }

      /**
       * Creates a completed DAG by supplying this partial DAG with its outputs (outputs).
       *
       * @param output1 the first output (output) of the DAG
       * @param output2 the second output (output) of the DAG
       * @param output3 the third output (output) of the DAG
       * @param output4 the fourth output (output) of the DAG
       * @param output5 the fifth output (output) of the DAG
       * @param output6 the sixth output (output) of the DAG
       * @param output7 the seventh output (output) of the DAG
       * @param <RA> the type of the first result
       * @param <RB> the type of the second result
       * @param <RC> the type of the third result
       * @param <RD> the type of the fourth result
       * @param <RE> the type of the fifth result
       * @param <RF> the type of the sixth result
       * @param <RG> the type of the seventh result
       * @return a completed DAG with 6 inputs (placeholders) and 7 outputs (outputs).
       */
      public <RA, RB, RC, RD, RE, RF, RG> DAG6x7.Prepared<A, B, C, D, E, F, RA, RB, RC, RD, RE, RF, RG> withOutputs(
          Producer<? extends RA> output1, Producer<? extends RB> output2, Producer<? extends RC> output3,
          Producer<? extends RD> output4, Producer<? extends RE> output5, Producer<? extends RF> output6,
          Producer<? extends RG> output7) {
        Objects.requireNonNull(output1, "Output 1 may not be null");
        Objects.requireNonNull(output2, "Output 2 may not be null");
        Objects.requireNonNull(output3, "Output 3 may not be null");
        Objects.requireNonNull(output4, "Output 4 may not be null");
        Objects.requireNonNull(output5, "Output 5 may not be null");
        Objects.requireNonNull(output6, "Output 6 may not be null");
        Objects.requireNonNull(output7, "Output 7 may not be null");

        if (_shouldRemapInputs) {
          Map<Producer<?>, Producer<?>> inputMapping =
              DAGUtil.createInputMap(_input1, _placeholder1, _input2, _placeholder2, _input3, _placeholder3, _input4,
                  _placeholder4, _input5, _placeholder5, _input6, _placeholder6);
          output1 = DAGUtil.replaceInputs(output1, inputMapping);
          output2 = DAGUtil.replaceInputs(output2, inputMapping);
          output3 = DAGUtil.replaceInputs(output3, inputMapping);
          output4 = DAGUtil.replaceInputs(output4, inputMapping);
          output5 = DAGUtil.replaceInputs(output5, inputMapping);
          output6 = DAGUtil.replaceInputs(output6, inputMapping);
          output7 = DAGUtil.replaceInputs(output7, inputMapping);
        }

        List<Producer<?>> inputs = Arrays.asList(_input1, _input2, _input3, _input4, _input5, _input6);

        return ((DAG6x7.Prepared) DAGUtil
            .createPreparedDAG(
                Arrays.asList(_placeholder1, _placeholder2, _placeholder3, _placeholder4, _placeholder5, _placeholder6),
                Arrays.asList(output1, output2, output3, output4, output5, output6, output7)).internalAPI()
            .withInputsUnsafe(inputs)).withReduction(_minimumReducerLevel);
      }

      /**
       * Creates a completed DAG by supplying this partial DAG with its outputs (outputs).
       *
       * @param output1 the first output (output) of the DAG
       * @param output2 the second output (output) of the DAG
       * @param output3 the third output (output) of the DAG
       * @param output4 the fourth output (output) of the DAG
       * @param output5 the fifth output (output) of the DAG
       * @param output6 the sixth output (output) of the DAG
       * @param output7 the seventh output (output) of the DAG
       * @param output8 the eighth output (output) of the DAG
       * @param <RA> the type of the first result
       * @param <RB> the type of the second result
       * @param <RC> the type of the third result
       * @param <RD> the type of the fourth result
       * @param <RE> the type of the fifth result
       * @param <RF> the type of the sixth result
       * @param <RG> the type of the seventh result
       * @param <RH> the type of the eighth result
       * @return a completed DAG with 6 inputs (placeholders) and 8 outputs (outputs).
       */
      public <RA, RB, RC, RD, RE, RF, RG, RH> DAG6x8.Prepared<A, B, C, D, E, F, RA, RB, RC, RD, RE, RF, RG, RH> withOutputs(
          Producer<? extends RA> output1, Producer<? extends RB> output2, Producer<? extends RC> output3,
          Producer<? extends RD> output4, Producer<? extends RE> output5, Producer<? extends RF> output6,
          Producer<? extends RG> output7, Producer<? extends RH> output8) {
        Objects.requireNonNull(output1, "Output 1 may not be null");
        Objects.requireNonNull(output2, "Output 2 may not be null");
        Objects.requireNonNull(output3, "Output 3 may not be null");
        Objects.requireNonNull(output4, "Output 4 may not be null");
        Objects.requireNonNull(output5, "Output 5 may not be null");
        Objects.requireNonNull(output6, "Output 6 may not be null");
        Objects.requireNonNull(output7, "Output 7 may not be null");
        Objects.requireNonNull(output8, "Output 8 may not be null");

        if (_shouldRemapInputs) {
          Map<Producer<?>, Producer<?>> inputMapping =
              DAGUtil.createInputMap(_input1, _placeholder1, _input2, _placeholder2, _input3, _placeholder3, _input4,
                  _placeholder4, _input5, _placeholder5, _input6, _placeholder6);
          output1 = DAGUtil.replaceInputs(output1, inputMapping);
          output2 = DAGUtil.replaceInputs(output2, inputMapping);
          output3 = DAGUtil.replaceInputs(output3, inputMapping);
          output4 = DAGUtil.replaceInputs(output4, inputMapping);
          output5 = DAGUtil.replaceInputs(output5, inputMapping);
          output6 = DAGUtil.replaceInputs(output6, inputMapping);
          output7 = DAGUtil.replaceInputs(output7, inputMapping);
          output8 = DAGUtil.replaceInputs(output8, inputMapping);
        }

        List<Producer<?>> inputs = Arrays.asList(_input1, _input2, _input3, _input4, _input5, _input6);

        return ((DAG6x8.Prepared) DAGUtil
            .createPreparedDAG(
                Arrays.asList(_placeholder1, _placeholder2, _placeholder3, _placeholder4, _placeholder5, _placeholder6),
                Arrays.asList(output1, output2, output3, output4, output5, output6, output7, output8)).internalAPI()
            .withInputsUnsafe(inputs)).withReduction(_minimumReducerLevel);
      }

      /**
       * Creates a completed DAG by supplying this partial DAG with its outputs (outputs).
       *
       * @param output1 the first output (output) of the DAG
       * @param output2 the second output (output) of the DAG
       * @param output3 the third output (output) of the DAG
       * @param output4 the fourth output (output) of the DAG
       * @param output5 the fifth output (output) of the DAG
       * @param output6 the sixth output (output) of the DAG
       * @param output7 the seventh output (output) of the DAG
       * @param output8 the eighth output (output) of the DAG
       * @param output9 the ninth output (output) of the DAG
       * @param <RA> the type of the first result
       * @param <RB> the type of the second result
       * @param <RC> the type of the third result
       * @param <RD> the type of the fourth result
       * @param <RE> the type of the fifth result
       * @param <RF> the type of the sixth result
       * @param <RG> the type of the seventh result
       * @param <RH> the type of the eighth result
       * @param <RI> the type of the ninth result
       * @return a completed DAG with 6 inputs (placeholders) and 9 outputs (outputs).
       */
      public <RA, RB, RC, RD, RE, RF, RG, RH, RI> DAG6x9.Prepared<A, B, C, D, E, F, RA, RB, RC, RD, RE, RF, RG, RH, RI> withOutputs(
          Producer<? extends RA> output1, Producer<? extends RB> output2, Producer<? extends RC> output3,
          Producer<? extends RD> output4, Producer<? extends RE> output5, Producer<? extends RF> output6,
          Producer<? extends RG> output7, Producer<? extends RH> output8, Producer<? extends RI> output9) {
        Objects.requireNonNull(output1, "Output 1 may not be null");
        Objects.requireNonNull(output2, "Output 2 may not be null");
        Objects.requireNonNull(output3, "Output 3 may not be null");
        Objects.requireNonNull(output4, "Output 4 may not be null");
        Objects.requireNonNull(output5, "Output 5 may not be null");
        Objects.requireNonNull(output6, "Output 6 may not be null");
        Objects.requireNonNull(output7, "Output 7 may not be null");
        Objects.requireNonNull(output8, "Output 8 may not be null");
        Objects.requireNonNull(output9, "Output 9 may not be null");

        if (_shouldRemapInputs) {
          Map<Producer<?>, Producer<?>> inputMapping =
              DAGUtil.createInputMap(_input1, _placeholder1, _input2, _placeholder2, _input3, _placeholder3, _input4,
                  _placeholder4, _input5, _placeholder5, _input6, _placeholder6);
          output1 = DAGUtil.replaceInputs(output1, inputMapping);
          output2 = DAGUtil.replaceInputs(output2, inputMapping);
          output3 = DAGUtil.replaceInputs(output3, inputMapping);
          output4 = DAGUtil.replaceInputs(output4, inputMapping);
          output5 = DAGUtil.replaceInputs(output5, inputMapping);
          output6 = DAGUtil.replaceInputs(output6, inputMapping);
          output7 = DAGUtil.replaceInputs(output7, inputMapping);
          output8 = DAGUtil.replaceInputs(output8, inputMapping);
          output9 = DAGUtil.replaceInputs(output9, inputMapping);
        }

        List<Producer<?>> inputs = Arrays.asList(_input1, _input2, _input3, _input4, _input5, _input6);

        return ((DAG6x9.Prepared) DAGUtil
            .createPreparedDAG(
                Arrays.asList(_placeholder1, _placeholder2, _placeholder3, _placeholder4, _placeholder5, _placeholder6),
                Arrays.asList(output1, output2, output3, output4, output5, output6, output7, output8, output9))
            .internalAPI().withInputsUnsafe(inputs)).withReduction(_minimumReducerLevel);
      }

      /**
       * Creates a completed DAG by supplying this partial DAG with its outputs (outputs).
       *
       * @param output1 the first output (output) of the DAG
       * @param output2 the second output (output) of the DAG
       * @param output3 the third output (output) of the DAG
       * @param output4 the fourth output (output) of the DAG
       * @param output5 the fifth output (output) of the DAG
       * @param output6 the sixth output (output) of the DAG
       * @param output7 the seventh output (output) of the DAG
       * @param output8 the eighth output (output) of the DAG
       * @param output9 the ninth output (output) of the DAG
       * @param output10 the tenth output (output) of the DAG
       * @param <RA> the type of the first result
       * @param <RB> the type of the second result
       * @param <RC> the type of the third result
       * @param <RD> the type of the fourth result
       * @param <RE> the type of the fifth result
       * @param <RF> the type of the sixth result
       * @param <RG> the type of the seventh result
       * @param <RH> the type of the eighth result
       * @param <RI> the type of the ninth result
       * @param <RJ> the type of the tenth result
       * @return a completed DAG with 6 inputs (placeholders) and 10 outputs (outputs).
       */
      public <RA, RB, RC, RD, RE, RF, RG, RH, RI, RJ> DAG6x10.Prepared<A, B, C, D, E, F, RA, RB, RC, RD, RE, RF, RG, RH, RI, RJ> withOutputs(
          Producer<? extends RA> output1, Producer<? extends RB> output2, Producer<? extends RC> output3,
          Producer<? extends RD> output4, Producer<? extends RE> output5, Producer<? extends RF> output6,
          Producer<? extends RG> output7, Producer<? extends RH> output8, Producer<? extends RI> output9,
          Producer<? extends RJ> output10) {
        Objects.requireNonNull(output1, "Output 1 may not be null");
        Objects.requireNonNull(output2, "Output 2 may not be null");
        Objects.requireNonNull(output3, "Output 3 may not be null");
        Objects.requireNonNull(output4, "Output 4 may not be null");
        Objects.requireNonNull(output5, "Output 5 may not be null");
        Objects.requireNonNull(output6, "Output 6 may not be null");
        Objects.requireNonNull(output7, "Output 7 may not be null");
        Objects.requireNonNull(output8, "Output 8 may not be null");
        Objects.requireNonNull(output9, "Output 9 may not be null");
        Objects.requireNonNull(output10, "Output 10 may not be null");

        if (_shouldRemapInputs) {
          Map<Producer<?>, Producer<?>> inputMapping =
              DAGUtil.createInputMap(_input1, _placeholder1, _input2, _placeholder2, _input3, _placeholder3, _input4,
                  _placeholder4, _input5, _placeholder5, _input6, _placeholder6);
          output1 = DAGUtil.replaceInputs(output1, inputMapping);
          output2 = DAGUtil.replaceInputs(output2, inputMapping);
          output3 = DAGUtil.replaceInputs(output3, inputMapping);
          output4 = DAGUtil.replaceInputs(output4, inputMapping);
          output5 = DAGUtil.replaceInputs(output5, inputMapping);
          output6 = DAGUtil.replaceInputs(output6, inputMapping);
          output7 = DAGUtil.replaceInputs(output7, inputMapping);
          output8 = DAGUtil.replaceInputs(output8, inputMapping);
          output9 = DAGUtil.replaceInputs(output9, inputMapping);
          output10 = DAGUtil.replaceInputs(output10, inputMapping);
        }

        List<Producer<?>> inputs = Arrays.asList(_input1, _input2, _input3, _input4, _input5, _input6);

        return ((DAG6x10.Prepared) DAGUtil
            .createPreparedDAG(
                Arrays.asList(_placeholder1, _placeholder2, _placeholder3, _placeholder4, _placeholder5, _placeholder6),
                Arrays
                    .asList(output1, output2, output3, output4, output5, output6, output7, output8, output9, output10))
            .internalAPI().withInputsUnsafe(inputs)).withReduction(_minimumReducerLevel);
      }
    }

    /**
      * A partial DAG with 7 placeholder.  Partial DAGs are <i>completed</i> to create a usable DAG by specifying
      * the outputs (<i>outputs</i>) of the DAG using the withOutputs(...) methods.
      *
     * @param <A> the type of the first input
     * @param <B> the type of the second input
     * @param <C> the type of the third input
     * @param <D> the type of the fourth input
     * @param <E> the type of the fifth input
     * @param <F> the type of the sixth input
     * @param <G> the type of the seventh input
      */
    public static class WithPlaceholders7<A, B, C, D, E, F, G> extends
        AbstractWithPlaceholders7<A, B, C, D, E, F, G, WithPlaceholders7<A, B, C, D, E, F, G>> {
      /**
       * Creates a new partial DAG that will be rooted at the provided placeholders.
       *
       * @param placeholder1 the first placeholder
       * @param placeholder2 the second placeholder
       * @param placeholder3 the third placeholder
       * @param placeholder4 the fourth placeholder
       * @param placeholder5 the fifth placeholder
       * @param placeholder6 the sixth placeholder
       * @param placeholder7 the seventh placeholder
       */
      WithPlaceholders7(Placeholder<? extends A> placeholder1, Placeholder<? extends B> placeholder2,
          Placeholder<? extends C> placeholder3, Placeholder<? extends D> placeholder4,
          Placeholder<? extends E> placeholder5, Placeholder<? extends F> placeholder6,
          Placeholder<? extends G> placeholder7) {
        super(placeholder1, placeholder2, placeholder3, placeholder4, placeholder5, placeholder6, placeholder7);
      }

      /**
       * Creates a new partial DAG that will be rooted at the provided placeholders, which will replace ("remap") the provided
       * "input" nodes that define a subgraph of the original graph (as defined by the ancestors of the outputs that will
       * be provided when the partial DAG is completed).  The input nodes, and any nodes that were exclusively the
       * ancestors of the input nodes, are truncated from the resulting graph.
       *
       * @param placeholder1 the first placeholder
       * @param placeholder2 the second placeholder
       * @param placeholder3 the third placeholder
       * @param placeholder4 the fourth placeholder
       * @param placeholder5 the fifth placeholder
       * @param placeholder6 the sixth placeholder
       * @param placeholder7 the seventh placeholder
       * @param input1 the first input
       * @param input2 the second input
       * @param input3 the third input
       * @param input4 the fourth input
       * @param input5 the fifth input
       * @param input6 the sixth input
       * @param input7 the seventh input
       */
      WithPlaceholders7(Placeholder<? extends A> placeholder1, Placeholder<? extends B> placeholder2,
          Placeholder<? extends C> placeholder3, Placeholder<? extends D> placeholder4,
          Placeholder<? extends E> placeholder5, Placeholder<? extends F> placeholder6,
          Placeholder<? extends G> placeholder7, Producer<? extends A> input1, Producer<? extends B> input2,
          Producer<? extends C> input3, Producer<? extends D> input4, Producer<? extends E> input5,
          Producer<? extends F> input6, Producer<? extends G> input7) {
        super(placeholder1, placeholder2, placeholder3, placeholder4, placeholder5, placeholder6, placeholder7, input1,
            input2, input3, input4, input5, input6, input7);
      }

      /**
       * Creates a completed DAG by supplying this partial DAG with its outputs (outputs).
       *
       * @param output1 the first output (output) of the DAG
       * @param <RA> the type of the first result
       * @return a completed DAG with 7 inputs (placeholders) and 1 output (outputs).
       */
      public <RA> DAG7x1.Prepared<A, B, C, D, E, F, G, RA> withOutputs(Producer<? extends RA> output1) {
        Objects.requireNonNull(output1, "Output 1 may not be null");

        if (_shouldRemapInputs) {
          Map<Producer<?>, Producer<?>> inputMapping =
              DAGUtil.createInputMap(_input1, _placeholder1, _input2, _placeholder2, _input3, _placeholder3, _input4,
                  _placeholder4, _input5, _placeholder5, _input6, _placeholder6, _input7, _placeholder7);
          output1 = DAGUtil.replaceInputs(output1, inputMapping);
        }

        List<Producer<?>> inputs = Arrays.asList(_input1, _input2, _input3, _input4, _input5, _input6, _input7);

        return ((DAG7x1.Prepared) DAGUtil
            .createPreparedDAG(
                Arrays.asList(_placeholder1, _placeholder2, _placeholder3, _placeholder4, _placeholder5, _placeholder6,
                    _placeholder7), Arrays.asList(output1)).internalAPI().withInputsUnsafe(inputs))
            .withReduction(_minimumReducerLevel);
      }

      /**
       * Creates a completed DAG by supplying this partial DAG with its outputs (outputs).
       *
       * @param output1 the first output (output) of the DAG
       * @param <RA> the type of the first result
       * @return a completed DAG with 7 inputs (placeholders) and 1 output (outputs).
       */
      public <RA> DAG7x1.Prepared<A, B, C, D, E, F, G, RA> withOutput(Producer<? extends RA> output1) {
        Objects.requireNonNull(output1, "Output 1 may not be null");

        if (_shouldRemapInputs) {
          Map<Producer<?>, Producer<?>> inputMapping =
              DAGUtil.createInputMap(_input1, _placeholder1, _input2, _placeholder2, _input3, _placeholder3, _input4,
                  _placeholder4, _input5, _placeholder5, _input6, _placeholder6, _input7, _placeholder7);
          output1 = DAGUtil.replaceInputs(output1, inputMapping);
        }

        List<Producer<?>> inputs = Arrays.asList(_input1, _input2, _input3, _input4, _input5, _input6, _input7);

        return ((DAG7x1.Prepared) DAGUtil
            .createPreparedDAG(
                Arrays.asList(_placeholder1, _placeholder2, _placeholder3, _placeholder4, _placeholder5, _placeholder6,
                    _placeholder7), Arrays.asList(output1)).internalAPI().withInputsUnsafe(inputs))
            .withReduction(_minimumReducerLevel);
      }

      /**
       * Creates a completed DAG by supplying this partial DAG with its outputs (outputs).
       *
       * @param output1 the first output (output) of the DAG
       * @param output2 the second output (output) of the DAG
       * @param <RA> the type of the first result
       * @param <RB> the type of the second result
       * @return a completed DAG with 7 inputs (placeholders) and 2 outputs (outputs).
       */
      public <RA, RB> DAG7x2.Prepared<A, B, C, D, E, F, G, RA, RB> withOutputs(Producer<? extends RA> output1,
          Producer<? extends RB> output2) {
        Objects.requireNonNull(output1, "Output 1 may not be null");
        Objects.requireNonNull(output2, "Output 2 may not be null");

        if (_shouldRemapInputs) {
          Map<Producer<?>, Producer<?>> inputMapping =
              DAGUtil.createInputMap(_input1, _placeholder1, _input2, _placeholder2, _input3, _placeholder3, _input4,
                  _placeholder4, _input5, _placeholder5, _input6, _placeholder6, _input7, _placeholder7);
          output1 = DAGUtil.replaceInputs(output1, inputMapping);
          output2 = DAGUtil.replaceInputs(output2, inputMapping);
        }

        List<Producer<?>> inputs = Arrays.asList(_input1, _input2, _input3, _input4, _input5, _input6, _input7);

        return ((DAG7x2.Prepared) DAGUtil
            .createPreparedDAG(
                Arrays.asList(_placeholder1, _placeholder2, _placeholder3, _placeholder4, _placeholder5, _placeholder6,
                    _placeholder7), Arrays.asList(output1, output2)).internalAPI().withInputsUnsafe(inputs))
            .withReduction(_minimumReducerLevel);
      }

      /**
       * Creates a completed DAG by supplying this partial DAG with its outputs (outputs).
       *
       * @param output1 the first output (output) of the DAG
       * @param output2 the second output (output) of the DAG
       * @param output3 the third output (output) of the DAG
       * @param <RA> the type of the first result
       * @param <RB> the type of the second result
       * @param <RC> the type of the third result
       * @return a completed DAG with 7 inputs (placeholders) and 3 outputs (outputs).
       */
      public <RA, RB, RC> DAG7x3.Prepared<A, B, C, D, E, F, G, RA, RB, RC> withOutputs(Producer<? extends RA> output1,
          Producer<? extends RB> output2, Producer<? extends RC> output3) {
        Objects.requireNonNull(output1, "Output 1 may not be null");
        Objects.requireNonNull(output2, "Output 2 may not be null");
        Objects.requireNonNull(output3, "Output 3 may not be null");

        if (_shouldRemapInputs) {
          Map<Producer<?>, Producer<?>> inputMapping =
              DAGUtil.createInputMap(_input1, _placeholder1, _input2, _placeholder2, _input3, _placeholder3, _input4,
                  _placeholder4, _input5, _placeholder5, _input6, _placeholder6, _input7, _placeholder7);
          output1 = DAGUtil.replaceInputs(output1, inputMapping);
          output2 = DAGUtil.replaceInputs(output2, inputMapping);
          output3 = DAGUtil.replaceInputs(output3, inputMapping);
        }

        List<Producer<?>> inputs = Arrays.asList(_input1, _input2, _input3, _input4, _input5, _input6, _input7);

        return ((DAG7x3.Prepared) DAGUtil
            .createPreparedDAG(
                Arrays.asList(_placeholder1, _placeholder2, _placeholder3, _placeholder4, _placeholder5, _placeholder6,
                    _placeholder7), Arrays.asList(output1, output2, output3)).internalAPI().withInputsUnsafe(inputs))
            .withReduction(_minimumReducerLevel);
      }

      /**
       * Creates a completed DAG by supplying this partial DAG with its outputs (outputs).
       *
       * @param output1 the first output (output) of the DAG
       * @param output2 the second output (output) of the DAG
       * @param output3 the third output (output) of the DAG
       * @param output4 the fourth output (output) of the DAG
       * @param <RA> the type of the first result
       * @param <RB> the type of the second result
       * @param <RC> the type of the third result
       * @param <RD> the type of the fourth result
       * @return a completed DAG with 7 inputs (placeholders) and 4 outputs (outputs).
       */
      public <RA, RB, RC, RD> DAG7x4.Prepared<A, B, C, D, E, F, G, RA, RB, RC, RD> withOutputs(
          Producer<? extends RA> output1, Producer<? extends RB> output2, Producer<? extends RC> output3,
          Producer<? extends RD> output4) {
        Objects.requireNonNull(output1, "Output 1 may not be null");
        Objects.requireNonNull(output2, "Output 2 may not be null");
        Objects.requireNonNull(output3, "Output 3 may not be null");
        Objects.requireNonNull(output4, "Output 4 may not be null");

        if (_shouldRemapInputs) {
          Map<Producer<?>, Producer<?>> inputMapping =
              DAGUtil.createInputMap(_input1, _placeholder1, _input2, _placeholder2, _input3, _placeholder3, _input4,
                  _placeholder4, _input5, _placeholder5, _input6, _placeholder6, _input7, _placeholder7);
          output1 = DAGUtil.replaceInputs(output1, inputMapping);
          output2 = DAGUtil.replaceInputs(output2, inputMapping);
          output3 = DAGUtil.replaceInputs(output3, inputMapping);
          output4 = DAGUtil.replaceInputs(output4, inputMapping);
        }

        List<Producer<?>> inputs = Arrays.asList(_input1, _input2, _input3, _input4, _input5, _input6, _input7);

        return ((DAG7x4.Prepared) DAGUtil
            .createPreparedDAG(
                Arrays.asList(_placeholder1, _placeholder2, _placeholder3, _placeholder4, _placeholder5, _placeholder6,
                    _placeholder7), Arrays.asList(output1, output2, output3, output4)).internalAPI()
            .withInputsUnsafe(inputs)).withReduction(_minimumReducerLevel);
      }

      /**
       * Creates a completed DAG by supplying this partial DAG with its outputs (outputs).
       *
       * @param output1 the first output (output) of the DAG
       * @param output2 the second output (output) of the DAG
       * @param output3 the third output (output) of the DAG
       * @param output4 the fourth output (output) of the DAG
       * @param output5 the fifth output (output) of the DAG
       * @param <RA> the type of the first result
       * @param <RB> the type of the second result
       * @param <RC> the type of the third result
       * @param <RD> the type of the fourth result
       * @param <RE> the type of the fifth result
       * @return a completed DAG with 7 inputs (placeholders) and 5 outputs (outputs).
       */
      public <RA, RB, RC, RD, RE> DAG7x5.Prepared<A, B, C, D, E, F, G, RA, RB, RC, RD, RE> withOutputs(
          Producer<? extends RA> output1, Producer<? extends RB> output2, Producer<? extends RC> output3,
          Producer<? extends RD> output4, Producer<? extends RE> output5) {
        Objects.requireNonNull(output1, "Output 1 may not be null");
        Objects.requireNonNull(output2, "Output 2 may not be null");
        Objects.requireNonNull(output3, "Output 3 may not be null");
        Objects.requireNonNull(output4, "Output 4 may not be null");
        Objects.requireNonNull(output5, "Output 5 may not be null");

        if (_shouldRemapInputs) {
          Map<Producer<?>, Producer<?>> inputMapping =
              DAGUtil.createInputMap(_input1, _placeholder1, _input2, _placeholder2, _input3, _placeholder3, _input4,
                  _placeholder4, _input5, _placeholder5, _input6, _placeholder6, _input7, _placeholder7);
          output1 = DAGUtil.replaceInputs(output1, inputMapping);
          output2 = DAGUtil.replaceInputs(output2, inputMapping);
          output3 = DAGUtil.replaceInputs(output3, inputMapping);
          output4 = DAGUtil.replaceInputs(output4, inputMapping);
          output5 = DAGUtil.replaceInputs(output5, inputMapping);
        }

        List<Producer<?>> inputs = Arrays.asList(_input1, _input2, _input3, _input4, _input5, _input6, _input7);

        return ((DAG7x5.Prepared) DAGUtil
            .createPreparedDAG(
                Arrays.asList(_placeholder1, _placeholder2, _placeholder3, _placeholder4, _placeholder5, _placeholder6,
                    _placeholder7), Arrays.asList(output1, output2, output3, output4, output5)).internalAPI()
            .withInputsUnsafe(inputs)).withReduction(_minimumReducerLevel);
      }

      /**
       * Creates a completed DAG by supplying this partial DAG with its outputs (outputs).
       *
       * @param output1 the first output (output) of the DAG
       * @param output2 the second output (output) of the DAG
       * @param output3 the third output (output) of the DAG
       * @param output4 the fourth output (output) of the DAG
       * @param output5 the fifth output (output) of the DAG
       * @param output6 the sixth output (output) of the DAG
       * @param <RA> the type of the first result
       * @param <RB> the type of the second result
       * @param <RC> the type of the third result
       * @param <RD> the type of the fourth result
       * @param <RE> the type of the fifth result
       * @param <RF> the type of the sixth result
       * @return a completed DAG with 7 inputs (placeholders) and 6 outputs (outputs).
       */
      public <RA, RB, RC, RD, RE, RF> DAG7x6.Prepared<A, B, C, D, E, F, G, RA, RB, RC, RD, RE, RF> withOutputs(
          Producer<? extends RA> output1, Producer<? extends RB> output2, Producer<? extends RC> output3,
          Producer<? extends RD> output4, Producer<? extends RE> output5, Producer<? extends RF> output6) {
        Objects.requireNonNull(output1, "Output 1 may not be null");
        Objects.requireNonNull(output2, "Output 2 may not be null");
        Objects.requireNonNull(output3, "Output 3 may not be null");
        Objects.requireNonNull(output4, "Output 4 may not be null");
        Objects.requireNonNull(output5, "Output 5 may not be null");
        Objects.requireNonNull(output6, "Output 6 may not be null");

        if (_shouldRemapInputs) {
          Map<Producer<?>, Producer<?>> inputMapping =
              DAGUtil.createInputMap(_input1, _placeholder1, _input2, _placeholder2, _input3, _placeholder3, _input4,
                  _placeholder4, _input5, _placeholder5, _input6, _placeholder6, _input7, _placeholder7);
          output1 = DAGUtil.replaceInputs(output1, inputMapping);
          output2 = DAGUtil.replaceInputs(output2, inputMapping);
          output3 = DAGUtil.replaceInputs(output3, inputMapping);
          output4 = DAGUtil.replaceInputs(output4, inputMapping);
          output5 = DAGUtil.replaceInputs(output5, inputMapping);
          output6 = DAGUtil.replaceInputs(output6, inputMapping);
        }

        List<Producer<?>> inputs = Arrays.asList(_input1, _input2, _input3, _input4, _input5, _input6, _input7);

        return ((DAG7x6.Prepared) DAGUtil
            .createPreparedDAG(
                Arrays.asList(_placeholder1, _placeholder2, _placeholder3, _placeholder4, _placeholder5, _placeholder6,
                    _placeholder7), Arrays.asList(output1, output2, output3, output4, output5, output6)).internalAPI()
            .withInputsUnsafe(inputs)).withReduction(_minimumReducerLevel);
      }

      /**
       * Creates a completed DAG by supplying this partial DAG with its outputs (outputs).
       *
       * @param output1 the first output (output) of the DAG
       * @param output2 the second output (output) of the DAG
       * @param output3 the third output (output) of the DAG
       * @param output4 the fourth output (output) of the DAG
       * @param output5 the fifth output (output) of the DAG
       * @param output6 the sixth output (output) of the DAG
       * @param output7 the seventh output (output) of the DAG
       * @param <RA> the type of the first result
       * @param <RB> the type of the second result
       * @param <RC> the type of the third result
       * @param <RD> the type of the fourth result
       * @param <RE> the type of the fifth result
       * @param <RF> the type of the sixth result
       * @param <RG> the type of the seventh result
       * @return a completed DAG with 7 inputs (placeholders) and 7 outputs (outputs).
       */
      public <RA, RB, RC, RD, RE, RF, RG> DAG7x7.Prepared<A, B, C, D, E, F, G, RA, RB, RC, RD, RE, RF, RG> withOutputs(
          Producer<? extends RA> output1, Producer<? extends RB> output2, Producer<? extends RC> output3,
          Producer<? extends RD> output4, Producer<? extends RE> output5, Producer<? extends RF> output6,
          Producer<? extends RG> output7) {
        Objects.requireNonNull(output1, "Output 1 may not be null");
        Objects.requireNonNull(output2, "Output 2 may not be null");
        Objects.requireNonNull(output3, "Output 3 may not be null");
        Objects.requireNonNull(output4, "Output 4 may not be null");
        Objects.requireNonNull(output5, "Output 5 may not be null");
        Objects.requireNonNull(output6, "Output 6 may not be null");
        Objects.requireNonNull(output7, "Output 7 may not be null");

        if (_shouldRemapInputs) {
          Map<Producer<?>, Producer<?>> inputMapping =
              DAGUtil.createInputMap(_input1, _placeholder1, _input2, _placeholder2, _input3, _placeholder3, _input4,
                  _placeholder4, _input5, _placeholder5, _input6, _placeholder6, _input7, _placeholder7);
          output1 = DAGUtil.replaceInputs(output1, inputMapping);
          output2 = DAGUtil.replaceInputs(output2, inputMapping);
          output3 = DAGUtil.replaceInputs(output3, inputMapping);
          output4 = DAGUtil.replaceInputs(output4, inputMapping);
          output5 = DAGUtil.replaceInputs(output5, inputMapping);
          output6 = DAGUtil.replaceInputs(output6, inputMapping);
          output7 = DAGUtil.replaceInputs(output7, inputMapping);
        }

        List<Producer<?>> inputs = Arrays.asList(_input1, _input2, _input3, _input4, _input5, _input6, _input7);

        return ((DAG7x7.Prepared) DAGUtil
            .createPreparedDAG(
                Arrays.asList(_placeholder1, _placeholder2, _placeholder3, _placeholder4, _placeholder5, _placeholder6,
                    _placeholder7), Arrays.asList(output1, output2, output3, output4, output5, output6, output7))
            .internalAPI().withInputsUnsafe(inputs)).withReduction(_minimumReducerLevel);
      }

      /**
       * Creates a completed DAG by supplying this partial DAG with its outputs (outputs).
       *
       * @param output1 the first output (output) of the DAG
       * @param output2 the second output (output) of the DAG
       * @param output3 the third output (output) of the DAG
       * @param output4 the fourth output (output) of the DAG
       * @param output5 the fifth output (output) of the DAG
       * @param output6 the sixth output (output) of the DAG
       * @param output7 the seventh output (output) of the DAG
       * @param output8 the eighth output (output) of the DAG
       * @param <RA> the type of the first result
       * @param <RB> the type of the second result
       * @param <RC> the type of the third result
       * @param <RD> the type of the fourth result
       * @param <RE> the type of the fifth result
       * @param <RF> the type of the sixth result
       * @param <RG> the type of the seventh result
       * @param <RH> the type of the eighth result
       * @return a completed DAG with 7 inputs (placeholders) and 8 outputs (outputs).
       */
      public <RA, RB, RC, RD, RE, RF, RG, RH> DAG7x8.Prepared<A, B, C, D, E, F, G, RA, RB, RC, RD, RE, RF, RG, RH> withOutputs(
          Producer<? extends RA> output1, Producer<? extends RB> output2, Producer<? extends RC> output3,
          Producer<? extends RD> output4, Producer<? extends RE> output5, Producer<? extends RF> output6,
          Producer<? extends RG> output7, Producer<? extends RH> output8) {
        Objects.requireNonNull(output1, "Output 1 may not be null");
        Objects.requireNonNull(output2, "Output 2 may not be null");
        Objects.requireNonNull(output3, "Output 3 may not be null");
        Objects.requireNonNull(output4, "Output 4 may not be null");
        Objects.requireNonNull(output5, "Output 5 may not be null");
        Objects.requireNonNull(output6, "Output 6 may not be null");
        Objects.requireNonNull(output7, "Output 7 may not be null");
        Objects.requireNonNull(output8, "Output 8 may not be null");

        if (_shouldRemapInputs) {
          Map<Producer<?>, Producer<?>> inputMapping =
              DAGUtil.createInputMap(_input1, _placeholder1, _input2, _placeholder2, _input3, _placeholder3, _input4,
                  _placeholder4, _input5, _placeholder5, _input6, _placeholder6, _input7, _placeholder7);
          output1 = DAGUtil.replaceInputs(output1, inputMapping);
          output2 = DAGUtil.replaceInputs(output2, inputMapping);
          output3 = DAGUtil.replaceInputs(output3, inputMapping);
          output4 = DAGUtil.replaceInputs(output4, inputMapping);
          output5 = DAGUtil.replaceInputs(output5, inputMapping);
          output6 = DAGUtil.replaceInputs(output6, inputMapping);
          output7 = DAGUtil.replaceInputs(output7, inputMapping);
          output8 = DAGUtil.replaceInputs(output8, inputMapping);
        }

        List<Producer<?>> inputs = Arrays.asList(_input1, _input2, _input3, _input4, _input5, _input6, _input7);

        return ((DAG7x8.Prepared) DAGUtil
            .createPreparedDAG(
                Arrays.asList(_placeholder1, _placeholder2, _placeholder3, _placeholder4, _placeholder5, _placeholder6,
                    _placeholder7),
                Arrays.asList(output1, output2, output3, output4, output5, output6, output7, output8)).internalAPI()
            .withInputsUnsafe(inputs)).withReduction(_minimumReducerLevel);
      }

      /**
       * Creates a completed DAG by supplying this partial DAG with its outputs (outputs).
       *
       * @param output1 the first output (output) of the DAG
       * @param output2 the second output (output) of the DAG
       * @param output3 the third output (output) of the DAG
       * @param output4 the fourth output (output) of the DAG
       * @param output5 the fifth output (output) of the DAG
       * @param output6 the sixth output (output) of the DAG
       * @param output7 the seventh output (output) of the DAG
       * @param output8 the eighth output (output) of the DAG
       * @param output9 the ninth output (output) of the DAG
       * @param <RA> the type of the first result
       * @param <RB> the type of the second result
       * @param <RC> the type of the third result
       * @param <RD> the type of the fourth result
       * @param <RE> the type of the fifth result
       * @param <RF> the type of the sixth result
       * @param <RG> the type of the seventh result
       * @param <RH> the type of the eighth result
       * @param <RI> the type of the ninth result
       * @return a completed DAG with 7 inputs (placeholders) and 9 outputs (outputs).
       */
      public <RA, RB, RC, RD, RE, RF, RG, RH, RI> DAG7x9.Prepared<A, B, C, D, E, F, G, RA, RB, RC, RD, RE, RF, RG, RH, RI> withOutputs(
          Producer<? extends RA> output1, Producer<? extends RB> output2, Producer<? extends RC> output3,
          Producer<? extends RD> output4, Producer<? extends RE> output5, Producer<? extends RF> output6,
          Producer<? extends RG> output7, Producer<? extends RH> output8, Producer<? extends RI> output9) {
        Objects.requireNonNull(output1, "Output 1 may not be null");
        Objects.requireNonNull(output2, "Output 2 may not be null");
        Objects.requireNonNull(output3, "Output 3 may not be null");
        Objects.requireNonNull(output4, "Output 4 may not be null");
        Objects.requireNonNull(output5, "Output 5 may not be null");
        Objects.requireNonNull(output6, "Output 6 may not be null");
        Objects.requireNonNull(output7, "Output 7 may not be null");
        Objects.requireNonNull(output8, "Output 8 may not be null");
        Objects.requireNonNull(output9, "Output 9 may not be null");

        if (_shouldRemapInputs) {
          Map<Producer<?>, Producer<?>> inputMapping =
              DAGUtil.createInputMap(_input1, _placeholder1, _input2, _placeholder2, _input3, _placeholder3, _input4,
                  _placeholder4, _input5, _placeholder5, _input6, _placeholder6, _input7, _placeholder7);
          output1 = DAGUtil.replaceInputs(output1, inputMapping);
          output2 = DAGUtil.replaceInputs(output2, inputMapping);
          output3 = DAGUtil.replaceInputs(output3, inputMapping);
          output4 = DAGUtil.replaceInputs(output4, inputMapping);
          output5 = DAGUtil.replaceInputs(output5, inputMapping);
          output6 = DAGUtil.replaceInputs(output6, inputMapping);
          output7 = DAGUtil.replaceInputs(output7, inputMapping);
          output8 = DAGUtil.replaceInputs(output8, inputMapping);
          output9 = DAGUtil.replaceInputs(output9, inputMapping);
        }

        List<Producer<?>> inputs = Arrays.asList(_input1, _input2, _input3, _input4, _input5, _input6, _input7);

        return ((DAG7x9.Prepared) DAGUtil
            .createPreparedDAG(
                Arrays.asList(_placeholder1, _placeholder2, _placeholder3, _placeholder4, _placeholder5, _placeholder6,
                    _placeholder7),
                Arrays.asList(output1, output2, output3, output4, output5, output6, output7, output8, output9))
            .internalAPI().withInputsUnsafe(inputs)).withReduction(_minimumReducerLevel);
      }

      /**
       * Creates a completed DAG by supplying this partial DAG with its outputs (outputs).
       *
       * @param output1 the first output (output) of the DAG
       * @param output2 the second output (output) of the DAG
       * @param output3 the third output (output) of the DAG
       * @param output4 the fourth output (output) of the DAG
       * @param output5 the fifth output (output) of the DAG
       * @param output6 the sixth output (output) of the DAG
       * @param output7 the seventh output (output) of the DAG
       * @param output8 the eighth output (output) of the DAG
       * @param output9 the ninth output (output) of the DAG
       * @param output10 the tenth output (output) of the DAG
       * @param <RA> the type of the first result
       * @param <RB> the type of the second result
       * @param <RC> the type of the third result
       * @param <RD> the type of the fourth result
       * @param <RE> the type of the fifth result
       * @param <RF> the type of the sixth result
       * @param <RG> the type of the seventh result
       * @param <RH> the type of the eighth result
       * @param <RI> the type of the ninth result
       * @param <RJ> the type of the tenth result
       * @return a completed DAG with 7 inputs (placeholders) and 10 outputs (outputs).
       */
      public <RA, RB, RC, RD, RE, RF, RG, RH, RI, RJ> DAG7x10.Prepared<A, B, C, D, E, F, G, RA, RB, RC, RD, RE, RF, RG, RH, RI, RJ> withOutputs(
          Producer<? extends RA> output1, Producer<? extends RB> output2, Producer<? extends RC> output3,
          Producer<? extends RD> output4, Producer<? extends RE> output5, Producer<? extends RF> output6,
          Producer<? extends RG> output7, Producer<? extends RH> output8, Producer<? extends RI> output9,
          Producer<? extends RJ> output10) {
        Objects.requireNonNull(output1, "Output 1 may not be null");
        Objects.requireNonNull(output2, "Output 2 may not be null");
        Objects.requireNonNull(output3, "Output 3 may not be null");
        Objects.requireNonNull(output4, "Output 4 may not be null");
        Objects.requireNonNull(output5, "Output 5 may not be null");
        Objects.requireNonNull(output6, "Output 6 may not be null");
        Objects.requireNonNull(output7, "Output 7 may not be null");
        Objects.requireNonNull(output8, "Output 8 may not be null");
        Objects.requireNonNull(output9, "Output 9 may not be null");
        Objects.requireNonNull(output10, "Output 10 may not be null");

        if (_shouldRemapInputs) {
          Map<Producer<?>, Producer<?>> inputMapping =
              DAGUtil.createInputMap(_input1, _placeholder1, _input2, _placeholder2, _input3, _placeholder3, _input4,
                  _placeholder4, _input5, _placeholder5, _input6, _placeholder6, _input7, _placeholder7);
          output1 = DAGUtil.replaceInputs(output1, inputMapping);
          output2 = DAGUtil.replaceInputs(output2, inputMapping);
          output3 = DAGUtil.replaceInputs(output3, inputMapping);
          output4 = DAGUtil.replaceInputs(output4, inputMapping);
          output5 = DAGUtil.replaceInputs(output5, inputMapping);
          output6 = DAGUtil.replaceInputs(output6, inputMapping);
          output7 = DAGUtil.replaceInputs(output7, inputMapping);
          output8 = DAGUtil.replaceInputs(output8, inputMapping);
          output9 = DAGUtil.replaceInputs(output9, inputMapping);
          output10 = DAGUtil.replaceInputs(output10, inputMapping);
        }

        List<Producer<?>> inputs = Arrays.asList(_input1, _input2, _input3, _input4, _input5, _input6, _input7);

        return ((DAG7x10.Prepared) DAGUtil
            .createPreparedDAG(
                Arrays.asList(_placeholder1, _placeholder2, _placeholder3, _placeholder4, _placeholder5, _placeholder6,
                    _placeholder7),
                Arrays
                    .asList(output1, output2, output3, output4, output5, output6, output7, output8, output9, output10))
            .internalAPI().withInputsUnsafe(inputs)).withReduction(_minimumReducerLevel);
      }
    }

    /**
      * A partial DAG with 8 placeholder.  Partial DAGs are <i>completed</i> to create a usable DAG by specifying
      * the outputs (<i>outputs</i>) of the DAG using the withOutputs(...) methods.
      *
     * @param <A> the type of the first input
     * @param <B> the type of the second input
     * @param <C> the type of the third input
     * @param <D> the type of the fourth input
     * @param <E> the type of the fifth input
     * @param <F> the type of the sixth input
     * @param <G> the type of the seventh input
     * @param <H> the type of the eighth input
      */
    public static class WithPlaceholders8<A, B, C, D, E, F, G, H> extends
        AbstractWithPlaceholders8<A, B, C, D, E, F, G, H, WithPlaceholders8<A, B, C, D, E, F, G, H>> {
      /**
       * Creates a new partial DAG that will be rooted at the provided placeholders.
       *
       * @param placeholder1 the first placeholder
       * @param placeholder2 the second placeholder
       * @param placeholder3 the third placeholder
       * @param placeholder4 the fourth placeholder
       * @param placeholder5 the fifth placeholder
       * @param placeholder6 the sixth placeholder
       * @param placeholder7 the seventh placeholder
       * @param placeholder8 the eighth placeholder
       */
      WithPlaceholders8(Placeholder<? extends A> placeholder1, Placeholder<? extends B> placeholder2,
          Placeholder<? extends C> placeholder3, Placeholder<? extends D> placeholder4,
          Placeholder<? extends E> placeholder5, Placeholder<? extends F> placeholder6,
          Placeholder<? extends G> placeholder7, Placeholder<? extends H> placeholder8) {
        super(placeholder1, placeholder2, placeholder3, placeholder4, placeholder5, placeholder6, placeholder7,
            placeholder8);
      }

      /**
       * Creates a new partial DAG that will be rooted at the provided placeholders, which will replace ("remap") the provided
       * "input" nodes that define a subgraph of the original graph (as defined by the ancestors of the outputs that will
       * be provided when the partial DAG is completed).  The input nodes, and any nodes that were exclusively the
       * ancestors of the input nodes, are truncated from the resulting graph.
       *
       * @param placeholder1 the first placeholder
       * @param placeholder2 the second placeholder
       * @param placeholder3 the third placeholder
       * @param placeholder4 the fourth placeholder
       * @param placeholder5 the fifth placeholder
       * @param placeholder6 the sixth placeholder
       * @param placeholder7 the seventh placeholder
       * @param placeholder8 the eighth placeholder
       * @param input1 the first input
       * @param input2 the second input
       * @param input3 the third input
       * @param input4 the fourth input
       * @param input5 the fifth input
       * @param input6 the sixth input
       * @param input7 the seventh input
       * @param input8 the eighth input
       */
      WithPlaceholders8(Placeholder<? extends A> placeholder1, Placeholder<? extends B> placeholder2,
          Placeholder<? extends C> placeholder3, Placeholder<? extends D> placeholder4,
          Placeholder<? extends E> placeholder5, Placeholder<? extends F> placeholder6,
          Placeholder<? extends G> placeholder7, Placeholder<? extends H> placeholder8, Producer<? extends A> input1,
          Producer<? extends B> input2, Producer<? extends C> input3, Producer<? extends D> input4,
          Producer<? extends E> input5, Producer<? extends F> input6, Producer<? extends G> input7,
          Producer<? extends H> input8) {
        super(placeholder1, placeholder2, placeholder3, placeholder4, placeholder5, placeholder6, placeholder7,
            placeholder8, input1, input2, input3, input4, input5, input6, input7, input8);
      }

      /**
       * Creates a completed DAG by supplying this partial DAG with its outputs (outputs).
       *
       * @param output1 the first output (output) of the DAG
       * @param <RA> the type of the first result
       * @return a completed DAG with 8 inputs (placeholders) and 1 output (outputs).
       */
      public <RA> DAG8x1.Prepared<A, B, C, D, E, F, G, H, RA> withOutputs(Producer<? extends RA> output1) {
        Objects.requireNonNull(output1, "Output 1 may not be null");

        if (_shouldRemapInputs) {
          Map<Producer<?>, Producer<?>> inputMapping =
              DAGUtil.createInputMap(_input1, _placeholder1, _input2, _placeholder2, _input3, _placeholder3, _input4,
                  _placeholder4, _input5, _placeholder5, _input6, _placeholder6, _input7, _placeholder7, _input8,
                  _placeholder8);
          output1 = DAGUtil.replaceInputs(output1, inputMapping);
        }

        List<Producer<?>> inputs =
            Arrays.asList(_input1, _input2, _input3, _input4, _input5, _input6, _input7, _input8);

        return ((DAG8x1.Prepared) DAGUtil
            .createPreparedDAG(
                Arrays.asList(_placeholder1, _placeholder2, _placeholder3, _placeholder4, _placeholder5, _placeholder6,
                    _placeholder7, _placeholder8), Arrays.asList(output1)).internalAPI().withInputsUnsafe(inputs))
            .withReduction(_minimumReducerLevel);
      }

      /**
       * Creates a completed DAG by supplying this partial DAG with its outputs (outputs).
       *
       * @param output1 the first output (output) of the DAG
       * @param <RA> the type of the first result
       * @return a completed DAG with 8 inputs (placeholders) and 1 output (outputs).
       */
      public <RA> DAG8x1.Prepared<A, B, C, D, E, F, G, H, RA> withOutput(Producer<? extends RA> output1) {
        Objects.requireNonNull(output1, "Output 1 may not be null");

        if (_shouldRemapInputs) {
          Map<Producer<?>, Producer<?>> inputMapping =
              DAGUtil.createInputMap(_input1, _placeholder1, _input2, _placeholder2, _input3, _placeholder3, _input4,
                  _placeholder4, _input5, _placeholder5, _input6, _placeholder6, _input7, _placeholder7, _input8,
                  _placeholder8);
          output1 = DAGUtil.replaceInputs(output1, inputMapping);
        }

        List<Producer<?>> inputs =
            Arrays.asList(_input1, _input2, _input3, _input4, _input5, _input6, _input7, _input8);

        return ((DAG8x1.Prepared) DAGUtil
            .createPreparedDAG(
                Arrays.asList(_placeholder1, _placeholder2, _placeholder3, _placeholder4, _placeholder5, _placeholder6,
                    _placeholder7, _placeholder8), Arrays.asList(output1)).internalAPI().withInputsUnsafe(inputs))
            .withReduction(_minimumReducerLevel);
      }

      /**
       * Creates a completed DAG by supplying this partial DAG with its outputs (outputs).
       *
       * @param output1 the first output (output) of the DAG
       * @param output2 the second output (output) of the DAG
       * @param <RA> the type of the first result
       * @param <RB> the type of the second result
       * @return a completed DAG with 8 inputs (placeholders) and 2 outputs (outputs).
       */
      public <RA, RB> DAG8x2.Prepared<A, B, C, D, E, F, G, H, RA, RB> withOutputs(Producer<? extends RA> output1,
          Producer<? extends RB> output2) {
        Objects.requireNonNull(output1, "Output 1 may not be null");
        Objects.requireNonNull(output2, "Output 2 may not be null");

        if (_shouldRemapInputs) {
          Map<Producer<?>, Producer<?>> inputMapping =
              DAGUtil.createInputMap(_input1, _placeholder1, _input2, _placeholder2, _input3, _placeholder3, _input4,
                  _placeholder4, _input5, _placeholder5, _input6, _placeholder6, _input7, _placeholder7, _input8,
                  _placeholder8);
          output1 = DAGUtil.replaceInputs(output1, inputMapping);
          output2 = DAGUtil.replaceInputs(output2, inputMapping);
        }

        List<Producer<?>> inputs =
            Arrays.asList(_input1, _input2, _input3, _input4, _input5, _input6, _input7, _input8);

        return ((DAG8x2.Prepared) DAGUtil
            .createPreparedDAG(
                Arrays.asList(_placeholder1, _placeholder2, _placeholder3, _placeholder4, _placeholder5, _placeholder6,
                    _placeholder7, _placeholder8), Arrays.asList(output1, output2)).internalAPI()
            .withInputsUnsafe(inputs)).withReduction(_minimumReducerLevel);
      }

      /**
       * Creates a completed DAG by supplying this partial DAG with its outputs (outputs).
       *
       * @param output1 the first output (output) of the DAG
       * @param output2 the second output (output) of the DAG
       * @param output3 the third output (output) of the DAG
       * @param <RA> the type of the first result
       * @param <RB> the type of the second result
       * @param <RC> the type of the third result
       * @return a completed DAG with 8 inputs (placeholders) and 3 outputs (outputs).
       */
      public <RA, RB, RC> DAG8x3.Prepared<A, B, C, D, E, F, G, H, RA, RB, RC> withOutputs(
          Producer<? extends RA> output1, Producer<? extends RB> output2, Producer<? extends RC> output3) {
        Objects.requireNonNull(output1, "Output 1 may not be null");
        Objects.requireNonNull(output2, "Output 2 may not be null");
        Objects.requireNonNull(output3, "Output 3 may not be null");

        if (_shouldRemapInputs) {
          Map<Producer<?>, Producer<?>> inputMapping =
              DAGUtil.createInputMap(_input1, _placeholder1, _input2, _placeholder2, _input3, _placeholder3, _input4,
                  _placeholder4, _input5, _placeholder5, _input6, _placeholder6, _input7, _placeholder7, _input8,
                  _placeholder8);
          output1 = DAGUtil.replaceInputs(output1, inputMapping);
          output2 = DAGUtil.replaceInputs(output2, inputMapping);
          output3 = DAGUtil.replaceInputs(output3, inputMapping);
        }

        List<Producer<?>> inputs =
            Arrays.asList(_input1, _input2, _input3, _input4, _input5, _input6, _input7, _input8);

        return ((DAG8x3.Prepared) DAGUtil
            .createPreparedDAG(
                Arrays.asList(_placeholder1, _placeholder2, _placeholder3, _placeholder4, _placeholder5, _placeholder6,
                    _placeholder7, _placeholder8), Arrays.asList(output1, output2, output3)).internalAPI()
            .withInputsUnsafe(inputs)).withReduction(_minimumReducerLevel);
      }

      /**
       * Creates a completed DAG by supplying this partial DAG with its outputs (outputs).
       *
       * @param output1 the first output (output) of the DAG
       * @param output2 the second output (output) of the DAG
       * @param output3 the third output (output) of the DAG
       * @param output4 the fourth output (output) of the DAG
       * @param <RA> the type of the first result
       * @param <RB> the type of the second result
       * @param <RC> the type of the third result
       * @param <RD> the type of the fourth result
       * @return a completed DAG with 8 inputs (placeholders) and 4 outputs (outputs).
       */
      public <RA, RB, RC, RD> DAG8x4.Prepared<A, B, C, D, E, F, G, H, RA, RB, RC, RD> withOutputs(
          Producer<? extends RA> output1, Producer<? extends RB> output2, Producer<? extends RC> output3,
          Producer<? extends RD> output4) {
        Objects.requireNonNull(output1, "Output 1 may not be null");
        Objects.requireNonNull(output2, "Output 2 may not be null");
        Objects.requireNonNull(output3, "Output 3 may not be null");
        Objects.requireNonNull(output4, "Output 4 may not be null");

        if (_shouldRemapInputs) {
          Map<Producer<?>, Producer<?>> inputMapping =
              DAGUtil.createInputMap(_input1, _placeholder1, _input2, _placeholder2, _input3, _placeholder3, _input4,
                  _placeholder4, _input5, _placeholder5, _input6, _placeholder6, _input7, _placeholder7, _input8,
                  _placeholder8);
          output1 = DAGUtil.replaceInputs(output1, inputMapping);
          output2 = DAGUtil.replaceInputs(output2, inputMapping);
          output3 = DAGUtil.replaceInputs(output3, inputMapping);
          output4 = DAGUtil.replaceInputs(output4, inputMapping);
        }

        List<Producer<?>> inputs =
            Arrays.asList(_input1, _input2, _input3, _input4, _input5, _input6, _input7, _input8);

        return ((DAG8x4.Prepared) DAGUtil
            .createPreparedDAG(
                Arrays.asList(_placeholder1, _placeholder2, _placeholder3, _placeholder4, _placeholder5, _placeholder6,
                    _placeholder7, _placeholder8), Arrays.asList(output1, output2, output3, output4)).internalAPI()
            .withInputsUnsafe(inputs)).withReduction(_minimumReducerLevel);
      }

      /**
       * Creates a completed DAG by supplying this partial DAG with its outputs (outputs).
       *
       * @param output1 the first output (output) of the DAG
       * @param output2 the second output (output) of the DAG
       * @param output3 the third output (output) of the DAG
       * @param output4 the fourth output (output) of the DAG
       * @param output5 the fifth output (output) of the DAG
       * @param <RA> the type of the first result
       * @param <RB> the type of the second result
       * @param <RC> the type of the third result
       * @param <RD> the type of the fourth result
       * @param <RE> the type of the fifth result
       * @return a completed DAG with 8 inputs (placeholders) and 5 outputs (outputs).
       */
      public <RA, RB, RC, RD, RE> DAG8x5.Prepared<A, B, C, D, E, F, G, H, RA, RB, RC, RD, RE> withOutputs(
          Producer<? extends RA> output1, Producer<? extends RB> output2, Producer<? extends RC> output3,
          Producer<? extends RD> output4, Producer<? extends RE> output5) {
        Objects.requireNonNull(output1, "Output 1 may not be null");
        Objects.requireNonNull(output2, "Output 2 may not be null");
        Objects.requireNonNull(output3, "Output 3 may not be null");
        Objects.requireNonNull(output4, "Output 4 may not be null");
        Objects.requireNonNull(output5, "Output 5 may not be null");

        if (_shouldRemapInputs) {
          Map<Producer<?>, Producer<?>> inputMapping =
              DAGUtil.createInputMap(_input1, _placeholder1, _input2, _placeholder2, _input3, _placeholder3, _input4,
                  _placeholder4, _input5, _placeholder5, _input6, _placeholder6, _input7, _placeholder7, _input8,
                  _placeholder8);
          output1 = DAGUtil.replaceInputs(output1, inputMapping);
          output2 = DAGUtil.replaceInputs(output2, inputMapping);
          output3 = DAGUtil.replaceInputs(output3, inputMapping);
          output4 = DAGUtil.replaceInputs(output4, inputMapping);
          output5 = DAGUtil.replaceInputs(output5, inputMapping);
        }

        List<Producer<?>> inputs =
            Arrays.asList(_input1, _input2, _input3, _input4, _input5, _input6, _input7, _input8);

        return ((DAG8x5.Prepared) DAGUtil
            .createPreparedDAG(
                Arrays.asList(_placeholder1, _placeholder2, _placeholder3, _placeholder4, _placeholder5, _placeholder6,
                    _placeholder7, _placeholder8), Arrays.asList(output1, output2, output3, output4, output5))
            .internalAPI().withInputsUnsafe(inputs)).withReduction(_minimumReducerLevel);
      }

      /**
       * Creates a completed DAG by supplying this partial DAG with its outputs (outputs).
       *
       * @param output1 the first output (output) of the DAG
       * @param output2 the second output (output) of the DAG
       * @param output3 the third output (output) of the DAG
       * @param output4 the fourth output (output) of the DAG
       * @param output5 the fifth output (output) of the DAG
       * @param output6 the sixth output (output) of the DAG
       * @param <RA> the type of the first result
       * @param <RB> the type of the second result
       * @param <RC> the type of the third result
       * @param <RD> the type of the fourth result
       * @param <RE> the type of the fifth result
       * @param <RF> the type of the sixth result
       * @return a completed DAG with 8 inputs (placeholders) and 6 outputs (outputs).
       */
      public <RA, RB, RC, RD, RE, RF> DAG8x6.Prepared<A, B, C, D, E, F, G, H, RA, RB, RC, RD, RE, RF> withOutputs(
          Producer<? extends RA> output1, Producer<? extends RB> output2, Producer<? extends RC> output3,
          Producer<? extends RD> output4, Producer<? extends RE> output5, Producer<? extends RF> output6) {
        Objects.requireNonNull(output1, "Output 1 may not be null");
        Objects.requireNonNull(output2, "Output 2 may not be null");
        Objects.requireNonNull(output3, "Output 3 may not be null");
        Objects.requireNonNull(output4, "Output 4 may not be null");
        Objects.requireNonNull(output5, "Output 5 may not be null");
        Objects.requireNonNull(output6, "Output 6 may not be null");

        if (_shouldRemapInputs) {
          Map<Producer<?>, Producer<?>> inputMapping =
              DAGUtil.createInputMap(_input1, _placeholder1, _input2, _placeholder2, _input3, _placeholder3, _input4,
                  _placeholder4, _input5, _placeholder5, _input6, _placeholder6, _input7, _placeholder7, _input8,
                  _placeholder8);
          output1 = DAGUtil.replaceInputs(output1, inputMapping);
          output2 = DAGUtil.replaceInputs(output2, inputMapping);
          output3 = DAGUtil.replaceInputs(output3, inputMapping);
          output4 = DAGUtil.replaceInputs(output4, inputMapping);
          output5 = DAGUtil.replaceInputs(output5, inputMapping);
          output6 = DAGUtil.replaceInputs(output6, inputMapping);
        }

        List<Producer<?>> inputs =
            Arrays.asList(_input1, _input2, _input3, _input4, _input5, _input6, _input7, _input8);

        return ((DAG8x6.Prepared) DAGUtil
            .createPreparedDAG(
                Arrays.asList(_placeholder1, _placeholder2, _placeholder3, _placeholder4, _placeholder5, _placeholder6,
                    _placeholder7, _placeholder8), Arrays.asList(output1, output2, output3, output4, output5, output6))
            .internalAPI().withInputsUnsafe(inputs)).withReduction(_minimumReducerLevel);
      }

      /**
       * Creates a completed DAG by supplying this partial DAG with its outputs (outputs).
       *
       * @param output1 the first output (output) of the DAG
       * @param output2 the second output (output) of the DAG
       * @param output3 the third output (output) of the DAG
       * @param output4 the fourth output (output) of the DAG
       * @param output5 the fifth output (output) of the DAG
       * @param output6 the sixth output (output) of the DAG
       * @param output7 the seventh output (output) of the DAG
       * @param <RA> the type of the first result
       * @param <RB> the type of the second result
       * @param <RC> the type of the third result
       * @param <RD> the type of the fourth result
       * @param <RE> the type of the fifth result
       * @param <RF> the type of the sixth result
       * @param <RG> the type of the seventh result
       * @return a completed DAG with 8 inputs (placeholders) and 7 outputs (outputs).
       */
      public <RA, RB, RC, RD, RE, RF, RG> DAG8x7.Prepared<A, B, C, D, E, F, G, H, RA, RB, RC, RD, RE, RF, RG> withOutputs(
          Producer<? extends RA> output1, Producer<? extends RB> output2, Producer<? extends RC> output3,
          Producer<? extends RD> output4, Producer<? extends RE> output5, Producer<? extends RF> output6,
          Producer<? extends RG> output7) {
        Objects.requireNonNull(output1, "Output 1 may not be null");
        Objects.requireNonNull(output2, "Output 2 may not be null");
        Objects.requireNonNull(output3, "Output 3 may not be null");
        Objects.requireNonNull(output4, "Output 4 may not be null");
        Objects.requireNonNull(output5, "Output 5 may not be null");
        Objects.requireNonNull(output6, "Output 6 may not be null");
        Objects.requireNonNull(output7, "Output 7 may not be null");

        if (_shouldRemapInputs) {
          Map<Producer<?>, Producer<?>> inputMapping =
              DAGUtil.createInputMap(_input1, _placeholder1, _input2, _placeholder2, _input3, _placeholder3, _input4,
                  _placeholder4, _input5, _placeholder5, _input6, _placeholder6, _input7, _placeholder7, _input8,
                  _placeholder8);
          output1 = DAGUtil.replaceInputs(output1, inputMapping);
          output2 = DAGUtil.replaceInputs(output2, inputMapping);
          output3 = DAGUtil.replaceInputs(output3, inputMapping);
          output4 = DAGUtil.replaceInputs(output4, inputMapping);
          output5 = DAGUtil.replaceInputs(output5, inputMapping);
          output6 = DAGUtil.replaceInputs(output6, inputMapping);
          output7 = DAGUtil.replaceInputs(output7, inputMapping);
        }

        List<Producer<?>> inputs =
            Arrays.asList(_input1, _input2, _input3, _input4, _input5, _input6, _input7, _input8);

        return ((DAG8x7.Prepared) DAGUtil
            .createPreparedDAG(
                Arrays.asList(_placeholder1, _placeholder2, _placeholder3, _placeholder4, _placeholder5, _placeholder6,
                    _placeholder7, _placeholder8),
                Arrays.asList(output1, output2, output3, output4, output5, output6, output7)).internalAPI()
            .withInputsUnsafe(inputs)).withReduction(_minimumReducerLevel);
      }

      /**
       * Creates a completed DAG by supplying this partial DAG with its outputs (outputs).
       *
       * @param output1 the first output (output) of the DAG
       * @param output2 the second output (output) of the DAG
       * @param output3 the third output (output) of the DAG
       * @param output4 the fourth output (output) of the DAG
       * @param output5 the fifth output (output) of the DAG
       * @param output6 the sixth output (output) of the DAG
       * @param output7 the seventh output (output) of the DAG
       * @param output8 the eighth output (output) of the DAG
       * @param <RA> the type of the first result
       * @param <RB> the type of the second result
       * @param <RC> the type of the third result
       * @param <RD> the type of the fourth result
       * @param <RE> the type of the fifth result
       * @param <RF> the type of the sixth result
       * @param <RG> the type of the seventh result
       * @param <RH> the type of the eighth result
       * @return a completed DAG with 8 inputs (placeholders) and 8 outputs (outputs).
       */
      public <RA, RB, RC, RD, RE, RF, RG, RH> DAG8x8.Prepared<A, B, C, D, E, F, G, H, RA, RB, RC, RD, RE, RF, RG, RH> withOutputs(
          Producer<? extends RA> output1, Producer<? extends RB> output2, Producer<? extends RC> output3,
          Producer<? extends RD> output4, Producer<? extends RE> output5, Producer<? extends RF> output6,
          Producer<? extends RG> output7, Producer<? extends RH> output8) {
        Objects.requireNonNull(output1, "Output 1 may not be null");
        Objects.requireNonNull(output2, "Output 2 may not be null");
        Objects.requireNonNull(output3, "Output 3 may not be null");
        Objects.requireNonNull(output4, "Output 4 may not be null");
        Objects.requireNonNull(output5, "Output 5 may not be null");
        Objects.requireNonNull(output6, "Output 6 may not be null");
        Objects.requireNonNull(output7, "Output 7 may not be null");
        Objects.requireNonNull(output8, "Output 8 may not be null");

        if (_shouldRemapInputs) {
          Map<Producer<?>, Producer<?>> inputMapping =
              DAGUtil.createInputMap(_input1, _placeholder1, _input2, _placeholder2, _input3, _placeholder3, _input4,
                  _placeholder4, _input5, _placeholder5, _input6, _placeholder6, _input7, _placeholder7, _input8,
                  _placeholder8);
          output1 = DAGUtil.replaceInputs(output1, inputMapping);
          output2 = DAGUtil.replaceInputs(output2, inputMapping);
          output3 = DAGUtil.replaceInputs(output3, inputMapping);
          output4 = DAGUtil.replaceInputs(output4, inputMapping);
          output5 = DAGUtil.replaceInputs(output5, inputMapping);
          output6 = DAGUtil.replaceInputs(output6, inputMapping);
          output7 = DAGUtil.replaceInputs(output7, inputMapping);
          output8 = DAGUtil.replaceInputs(output8, inputMapping);
        }

        List<Producer<?>> inputs =
            Arrays.asList(_input1, _input2, _input3, _input4, _input5, _input6, _input7, _input8);

        return ((DAG8x8.Prepared) DAGUtil
            .createPreparedDAG(
                Arrays.asList(_placeholder1, _placeholder2, _placeholder3, _placeholder4, _placeholder5, _placeholder6,
                    _placeholder7, _placeholder8),
                Arrays.asList(output1, output2, output3, output4, output5, output6, output7, output8)).internalAPI()
            .withInputsUnsafe(inputs)).withReduction(_minimumReducerLevel);
      }

      /**
       * Creates a completed DAG by supplying this partial DAG with its outputs (outputs).
       *
       * @param output1 the first output (output) of the DAG
       * @param output2 the second output (output) of the DAG
       * @param output3 the third output (output) of the DAG
       * @param output4 the fourth output (output) of the DAG
       * @param output5 the fifth output (output) of the DAG
       * @param output6 the sixth output (output) of the DAG
       * @param output7 the seventh output (output) of the DAG
       * @param output8 the eighth output (output) of the DAG
       * @param output9 the ninth output (output) of the DAG
       * @param <RA> the type of the first result
       * @param <RB> the type of the second result
       * @param <RC> the type of the third result
       * @param <RD> the type of the fourth result
       * @param <RE> the type of the fifth result
       * @param <RF> the type of the sixth result
       * @param <RG> the type of the seventh result
       * @param <RH> the type of the eighth result
       * @param <RI> the type of the ninth result
       * @return a completed DAG with 8 inputs (placeholders) and 9 outputs (outputs).
       */
      public <RA, RB, RC, RD, RE, RF, RG, RH, RI> DAG8x9.Prepared<A, B, C, D, E, F, G, H, RA, RB, RC, RD, RE, RF, RG, RH, RI> withOutputs(
          Producer<? extends RA> output1, Producer<? extends RB> output2, Producer<? extends RC> output3,
          Producer<? extends RD> output4, Producer<? extends RE> output5, Producer<? extends RF> output6,
          Producer<? extends RG> output7, Producer<? extends RH> output8, Producer<? extends RI> output9) {
        Objects.requireNonNull(output1, "Output 1 may not be null");
        Objects.requireNonNull(output2, "Output 2 may not be null");
        Objects.requireNonNull(output3, "Output 3 may not be null");
        Objects.requireNonNull(output4, "Output 4 may not be null");
        Objects.requireNonNull(output5, "Output 5 may not be null");
        Objects.requireNonNull(output6, "Output 6 may not be null");
        Objects.requireNonNull(output7, "Output 7 may not be null");
        Objects.requireNonNull(output8, "Output 8 may not be null");
        Objects.requireNonNull(output9, "Output 9 may not be null");

        if (_shouldRemapInputs) {
          Map<Producer<?>, Producer<?>> inputMapping =
              DAGUtil.createInputMap(_input1, _placeholder1, _input2, _placeholder2, _input3, _placeholder3, _input4,
                  _placeholder4, _input5, _placeholder5, _input6, _placeholder6, _input7, _placeholder7, _input8,
                  _placeholder8);
          output1 = DAGUtil.replaceInputs(output1, inputMapping);
          output2 = DAGUtil.replaceInputs(output2, inputMapping);
          output3 = DAGUtil.replaceInputs(output3, inputMapping);
          output4 = DAGUtil.replaceInputs(output4, inputMapping);
          output5 = DAGUtil.replaceInputs(output5, inputMapping);
          output6 = DAGUtil.replaceInputs(output6, inputMapping);
          output7 = DAGUtil.replaceInputs(output7, inputMapping);
          output8 = DAGUtil.replaceInputs(output8, inputMapping);
          output9 = DAGUtil.replaceInputs(output9, inputMapping);
        }

        List<Producer<?>> inputs =
            Arrays.asList(_input1, _input2, _input3, _input4, _input5, _input6, _input7, _input8);

        return ((DAG8x9.Prepared) DAGUtil
            .createPreparedDAG(
                Arrays.asList(_placeholder1, _placeholder2, _placeholder3, _placeholder4, _placeholder5, _placeholder6,
                    _placeholder7, _placeholder8),
                Arrays.asList(output1, output2, output3, output4, output5, output6, output7, output8, output9))
            .internalAPI().withInputsUnsafe(inputs)).withReduction(_minimumReducerLevel);
      }

      /**
       * Creates a completed DAG by supplying this partial DAG with its outputs (outputs).
       *
       * @param output1 the first output (output) of the DAG
       * @param output2 the second output (output) of the DAG
       * @param output3 the third output (output) of the DAG
       * @param output4 the fourth output (output) of the DAG
       * @param output5 the fifth output (output) of the DAG
       * @param output6 the sixth output (output) of the DAG
       * @param output7 the seventh output (output) of the DAG
       * @param output8 the eighth output (output) of the DAG
       * @param output9 the ninth output (output) of the DAG
       * @param output10 the tenth output (output) of the DAG
       * @param <RA> the type of the first result
       * @param <RB> the type of the second result
       * @param <RC> the type of the third result
       * @param <RD> the type of the fourth result
       * @param <RE> the type of the fifth result
       * @param <RF> the type of the sixth result
       * @param <RG> the type of the seventh result
       * @param <RH> the type of the eighth result
       * @param <RI> the type of the ninth result
       * @param <RJ> the type of the tenth result
       * @return a completed DAG with 8 inputs (placeholders) and 10 outputs (outputs).
       */
      public <RA, RB, RC, RD, RE, RF, RG, RH, RI, RJ> DAG8x10.Prepared<A, B, C, D, E, F, G, H, RA, RB, RC, RD, RE, RF, RG, RH, RI, RJ> withOutputs(
          Producer<? extends RA> output1, Producer<? extends RB> output2, Producer<? extends RC> output3,
          Producer<? extends RD> output4, Producer<? extends RE> output5, Producer<? extends RF> output6,
          Producer<? extends RG> output7, Producer<? extends RH> output8, Producer<? extends RI> output9,
          Producer<? extends RJ> output10) {
        Objects.requireNonNull(output1, "Output 1 may not be null");
        Objects.requireNonNull(output2, "Output 2 may not be null");
        Objects.requireNonNull(output3, "Output 3 may not be null");
        Objects.requireNonNull(output4, "Output 4 may not be null");
        Objects.requireNonNull(output5, "Output 5 may not be null");
        Objects.requireNonNull(output6, "Output 6 may not be null");
        Objects.requireNonNull(output7, "Output 7 may not be null");
        Objects.requireNonNull(output8, "Output 8 may not be null");
        Objects.requireNonNull(output9, "Output 9 may not be null");
        Objects.requireNonNull(output10, "Output 10 may not be null");

        if (_shouldRemapInputs) {
          Map<Producer<?>, Producer<?>> inputMapping =
              DAGUtil.createInputMap(_input1, _placeholder1, _input2, _placeholder2, _input3, _placeholder3, _input4,
                  _placeholder4, _input5, _placeholder5, _input6, _placeholder6, _input7, _placeholder7, _input8,
                  _placeholder8);
          output1 = DAGUtil.replaceInputs(output1, inputMapping);
          output2 = DAGUtil.replaceInputs(output2, inputMapping);
          output3 = DAGUtil.replaceInputs(output3, inputMapping);
          output4 = DAGUtil.replaceInputs(output4, inputMapping);
          output5 = DAGUtil.replaceInputs(output5, inputMapping);
          output6 = DAGUtil.replaceInputs(output6, inputMapping);
          output7 = DAGUtil.replaceInputs(output7, inputMapping);
          output8 = DAGUtil.replaceInputs(output8, inputMapping);
          output9 = DAGUtil.replaceInputs(output9, inputMapping);
          output10 = DAGUtil.replaceInputs(output10, inputMapping);
        }

        List<Producer<?>> inputs =
            Arrays.asList(_input1, _input2, _input3, _input4, _input5, _input6, _input7, _input8);

        return ((DAG8x10.Prepared) DAGUtil
            .createPreparedDAG(
                Arrays.asList(_placeholder1, _placeholder2, _placeholder3, _placeholder4, _placeholder5, _placeholder6,
                    _placeholder7, _placeholder8),
                Arrays
                    .asList(output1, output2, output3, output4, output5, output6, output7, output8, output9, output10))
            .internalAPI().withInputsUnsafe(inputs)).withReduction(_minimumReducerLevel);
      }
    }

    /**
      * A partial DAG with 9 placeholder.  Partial DAGs are <i>completed</i> to create a usable DAG by specifying
      * the outputs (<i>outputs</i>) of the DAG using the withOutputs(...) methods.
      *
     * @param <A> the type of the first input
     * @param <B> the type of the second input
     * @param <C> the type of the third input
     * @param <D> the type of the fourth input
     * @param <E> the type of the fifth input
     * @param <F> the type of the sixth input
     * @param <G> the type of the seventh input
     * @param <H> the type of the eighth input
     * @param <I> the type of the ninth input
      */
    public static class WithPlaceholders9<A, B, C, D, E, F, G, H, I> extends
        AbstractWithPlaceholders9<A, B, C, D, E, F, G, H, I, WithPlaceholders9<A, B, C, D, E, F, G, H, I>> {
      /**
       * Creates a new partial DAG that will be rooted at the provided placeholders.
       *
       * @param placeholder1 the first placeholder
       * @param placeholder2 the second placeholder
       * @param placeholder3 the third placeholder
       * @param placeholder4 the fourth placeholder
       * @param placeholder5 the fifth placeholder
       * @param placeholder6 the sixth placeholder
       * @param placeholder7 the seventh placeholder
       * @param placeholder8 the eighth placeholder
       * @param placeholder9 the ninth placeholder
       */
      WithPlaceholders9(Placeholder<? extends A> placeholder1, Placeholder<? extends B> placeholder2,
          Placeholder<? extends C> placeholder3, Placeholder<? extends D> placeholder4,
          Placeholder<? extends E> placeholder5, Placeholder<? extends F> placeholder6,
          Placeholder<? extends G> placeholder7, Placeholder<? extends H> placeholder8,
          Placeholder<? extends I> placeholder9) {
        super(placeholder1, placeholder2, placeholder3, placeholder4, placeholder5, placeholder6, placeholder7,
            placeholder8, placeholder9);
      }

      /**
       * Creates a new partial DAG that will be rooted at the provided placeholders, which will replace ("remap") the provided
       * "input" nodes that define a subgraph of the original graph (as defined by the ancestors of the outputs that will
       * be provided when the partial DAG is completed).  The input nodes, and any nodes that were exclusively the
       * ancestors of the input nodes, are truncated from the resulting graph.
       *
       * @param placeholder1 the first placeholder
       * @param placeholder2 the second placeholder
       * @param placeholder3 the third placeholder
       * @param placeholder4 the fourth placeholder
       * @param placeholder5 the fifth placeholder
       * @param placeholder6 the sixth placeholder
       * @param placeholder7 the seventh placeholder
       * @param placeholder8 the eighth placeholder
       * @param placeholder9 the ninth placeholder
       * @param input1 the first input
       * @param input2 the second input
       * @param input3 the third input
       * @param input4 the fourth input
       * @param input5 the fifth input
       * @param input6 the sixth input
       * @param input7 the seventh input
       * @param input8 the eighth input
       * @param input9 the ninth input
       */
      WithPlaceholders9(Placeholder<? extends A> placeholder1, Placeholder<? extends B> placeholder2,
          Placeholder<? extends C> placeholder3, Placeholder<? extends D> placeholder4,
          Placeholder<? extends E> placeholder5, Placeholder<? extends F> placeholder6,
          Placeholder<? extends G> placeholder7, Placeholder<? extends H> placeholder8,
          Placeholder<? extends I> placeholder9, Producer<? extends A> input1, Producer<? extends B> input2,
          Producer<? extends C> input3, Producer<? extends D> input4, Producer<? extends E> input5,
          Producer<? extends F> input6, Producer<? extends G> input7, Producer<? extends H> input8,
          Producer<? extends I> input9) {
        super(placeholder1, placeholder2, placeholder3, placeholder4, placeholder5, placeholder6, placeholder7,
            placeholder8, placeholder9, input1, input2, input3, input4, input5, input6, input7, input8, input9);
      }

      /**
       * Creates a completed DAG by supplying this partial DAG with its outputs (outputs).
       *
       * @param output1 the first output (output) of the DAG
       * @param <RA> the type of the first result
       * @return a completed DAG with 9 inputs (placeholders) and 1 output (outputs).
       */
      public <RA> DAG9x1.Prepared<A, B, C, D, E, F, G, H, I, RA> withOutputs(Producer<? extends RA> output1) {
        Objects.requireNonNull(output1, "Output 1 may not be null");

        if (_shouldRemapInputs) {
          Map<Producer<?>, Producer<?>> inputMapping =
              DAGUtil.createInputMap(_input1, _placeholder1, _input2, _placeholder2, _input3, _placeholder3, _input4,
                  _placeholder4, _input5, _placeholder5, _input6, _placeholder6, _input7, _placeholder7, _input8,
                  _placeholder8, _input9, _placeholder9);
          output1 = DAGUtil.replaceInputs(output1, inputMapping);
        }

        List<Producer<?>> inputs =
            Arrays.asList(_input1, _input2, _input3, _input4, _input5, _input6, _input7, _input8, _input9);

        return ((DAG9x1.Prepared) DAGUtil
            .createPreparedDAG(
                Arrays.asList(_placeholder1, _placeholder2, _placeholder3, _placeholder4, _placeholder5, _placeholder6,
                    _placeholder7, _placeholder8, _placeholder9), Arrays.asList(output1)).internalAPI()
            .withInputsUnsafe(inputs)).withReduction(_minimumReducerLevel);
      }

      /**
       * Creates a completed DAG by supplying this partial DAG with its outputs (outputs).
       *
       * @param output1 the first output (output) of the DAG
       * @param <RA> the type of the first result
       * @return a completed DAG with 9 inputs (placeholders) and 1 output (outputs).
       */
      public <RA> DAG9x1.Prepared<A, B, C, D, E, F, G, H, I, RA> withOutput(Producer<? extends RA> output1) {
        Objects.requireNonNull(output1, "Output 1 may not be null");

        if (_shouldRemapInputs) {
          Map<Producer<?>, Producer<?>> inputMapping =
              DAGUtil.createInputMap(_input1, _placeholder1, _input2, _placeholder2, _input3, _placeholder3, _input4,
                  _placeholder4, _input5, _placeholder5, _input6, _placeholder6, _input7, _placeholder7, _input8,
                  _placeholder8, _input9, _placeholder9);
          output1 = DAGUtil.replaceInputs(output1, inputMapping);
        }

        List<Producer<?>> inputs =
            Arrays.asList(_input1, _input2, _input3, _input4, _input5, _input6, _input7, _input8, _input9);

        return ((DAG9x1.Prepared) DAGUtil
            .createPreparedDAG(
                Arrays.asList(_placeholder1, _placeholder2, _placeholder3, _placeholder4, _placeholder5, _placeholder6,
                    _placeholder7, _placeholder8, _placeholder9), Arrays.asList(output1)).internalAPI()
            .withInputsUnsafe(inputs)).withReduction(_minimumReducerLevel);
      }

      /**
       * Creates a completed DAG by supplying this partial DAG with its outputs (outputs).
       *
       * @param output1 the first output (output) of the DAG
       * @param output2 the second output (output) of the DAG
       * @param <RA> the type of the first result
       * @param <RB> the type of the second result
       * @return a completed DAG with 9 inputs (placeholders) and 2 outputs (outputs).
       */
      public <RA, RB> DAG9x2.Prepared<A, B, C, D, E, F, G, H, I, RA, RB> withOutputs(Producer<? extends RA> output1,
          Producer<? extends RB> output2) {
        Objects.requireNonNull(output1, "Output 1 may not be null");
        Objects.requireNonNull(output2, "Output 2 may not be null");

        if (_shouldRemapInputs) {
          Map<Producer<?>, Producer<?>> inputMapping =
              DAGUtil.createInputMap(_input1, _placeholder1, _input2, _placeholder2, _input3, _placeholder3, _input4,
                  _placeholder4, _input5, _placeholder5, _input6, _placeholder6, _input7, _placeholder7, _input8,
                  _placeholder8, _input9, _placeholder9);
          output1 = DAGUtil.replaceInputs(output1, inputMapping);
          output2 = DAGUtil.replaceInputs(output2, inputMapping);
        }

        List<Producer<?>> inputs =
            Arrays.asList(_input1, _input2, _input3, _input4, _input5, _input6, _input7, _input8, _input9);

        return ((DAG9x2.Prepared) DAGUtil
            .createPreparedDAG(
                Arrays.asList(_placeholder1, _placeholder2, _placeholder3, _placeholder4, _placeholder5, _placeholder6,
                    _placeholder7, _placeholder8, _placeholder9), Arrays.asList(output1, output2)).internalAPI()
            .withInputsUnsafe(inputs)).withReduction(_minimumReducerLevel);
      }

      /**
       * Creates a completed DAG by supplying this partial DAG with its outputs (outputs).
       *
       * @param output1 the first output (output) of the DAG
       * @param output2 the second output (output) of the DAG
       * @param output3 the third output (output) of the DAG
       * @param <RA> the type of the first result
       * @param <RB> the type of the second result
       * @param <RC> the type of the third result
       * @return a completed DAG with 9 inputs (placeholders) and 3 outputs (outputs).
       */
      public <RA, RB, RC> DAG9x3.Prepared<A, B, C, D, E, F, G, H, I, RA, RB, RC> withOutputs(
          Producer<? extends RA> output1, Producer<? extends RB> output2, Producer<? extends RC> output3) {
        Objects.requireNonNull(output1, "Output 1 may not be null");
        Objects.requireNonNull(output2, "Output 2 may not be null");
        Objects.requireNonNull(output3, "Output 3 may not be null");

        if (_shouldRemapInputs) {
          Map<Producer<?>, Producer<?>> inputMapping =
              DAGUtil.createInputMap(_input1, _placeholder1, _input2, _placeholder2, _input3, _placeholder3, _input4,
                  _placeholder4, _input5, _placeholder5, _input6, _placeholder6, _input7, _placeholder7, _input8,
                  _placeholder8, _input9, _placeholder9);
          output1 = DAGUtil.replaceInputs(output1, inputMapping);
          output2 = DAGUtil.replaceInputs(output2, inputMapping);
          output3 = DAGUtil.replaceInputs(output3, inputMapping);
        }

        List<Producer<?>> inputs =
            Arrays.asList(_input1, _input2, _input3, _input4, _input5, _input6, _input7, _input8, _input9);

        return ((DAG9x3.Prepared) DAGUtil
            .createPreparedDAG(
                Arrays.asList(_placeholder1, _placeholder2, _placeholder3, _placeholder4, _placeholder5, _placeholder6,
                    _placeholder7, _placeholder8, _placeholder9), Arrays.asList(output1, output2, output3))
            .internalAPI().withInputsUnsafe(inputs)).withReduction(_minimumReducerLevel);
      }

      /**
       * Creates a completed DAG by supplying this partial DAG with its outputs (outputs).
       *
       * @param output1 the first output (output) of the DAG
       * @param output2 the second output (output) of the DAG
       * @param output3 the third output (output) of the DAG
       * @param output4 the fourth output (output) of the DAG
       * @param <RA> the type of the first result
       * @param <RB> the type of the second result
       * @param <RC> the type of the third result
       * @param <RD> the type of the fourth result
       * @return a completed DAG with 9 inputs (placeholders) and 4 outputs (outputs).
       */
      public <RA, RB, RC, RD> DAG9x4.Prepared<A, B, C, D, E, F, G, H, I, RA, RB, RC, RD> withOutputs(
          Producer<? extends RA> output1, Producer<? extends RB> output2, Producer<? extends RC> output3,
          Producer<? extends RD> output4) {
        Objects.requireNonNull(output1, "Output 1 may not be null");
        Objects.requireNonNull(output2, "Output 2 may not be null");
        Objects.requireNonNull(output3, "Output 3 may not be null");
        Objects.requireNonNull(output4, "Output 4 may not be null");

        if (_shouldRemapInputs) {
          Map<Producer<?>, Producer<?>> inputMapping =
              DAGUtil.createInputMap(_input1, _placeholder1, _input2, _placeholder2, _input3, _placeholder3, _input4,
                  _placeholder4, _input5, _placeholder5, _input6, _placeholder6, _input7, _placeholder7, _input8,
                  _placeholder8, _input9, _placeholder9);
          output1 = DAGUtil.replaceInputs(output1, inputMapping);
          output2 = DAGUtil.replaceInputs(output2, inputMapping);
          output3 = DAGUtil.replaceInputs(output3, inputMapping);
          output4 = DAGUtil.replaceInputs(output4, inputMapping);
        }

        List<Producer<?>> inputs =
            Arrays.asList(_input1, _input2, _input3, _input4, _input5, _input6, _input7, _input8, _input9);

        return ((DAG9x4.Prepared) DAGUtil
            .createPreparedDAG(
                Arrays.asList(_placeholder1, _placeholder2, _placeholder3, _placeholder4, _placeholder5, _placeholder6,
                    _placeholder7, _placeholder8, _placeholder9), Arrays.asList(output1, output2, output3, output4))
            .internalAPI().withInputsUnsafe(inputs)).withReduction(_minimumReducerLevel);
      }

      /**
       * Creates a completed DAG by supplying this partial DAG with its outputs (outputs).
       *
       * @param output1 the first output (output) of the DAG
       * @param output2 the second output (output) of the DAG
       * @param output3 the third output (output) of the DAG
       * @param output4 the fourth output (output) of the DAG
       * @param output5 the fifth output (output) of the DAG
       * @param <RA> the type of the first result
       * @param <RB> the type of the second result
       * @param <RC> the type of the third result
       * @param <RD> the type of the fourth result
       * @param <RE> the type of the fifth result
       * @return a completed DAG with 9 inputs (placeholders) and 5 outputs (outputs).
       */
      public <RA, RB, RC, RD, RE> DAG9x5.Prepared<A, B, C, D, E, F, G, H, I, RA, RB, RC, RD, RE> withOutputs(
          Producer<? extends RA> output1, Producer<? extends RB> output2, Producer<? extends RC> output3,
          Producer<? extends RD> output4, Producer<? extends RE> output5) {
        Objects.requireNonNull(output1, "Output 1 may not be null");
        Objects.requireNonNull(output2, "Output 2 may not be null");
        Objects.requireNonNull(output3, "Output 3 may not be null");
        Objects.requireNonNull(output4, "Output 4 may not be null");
        Objects.requireNonNull(output5, "Output 5 may not be null");

        if (_shouldRemapInputs) {
          Map<Producer<?>, Producer<?>> inputMapping =
              DAGUtil.createInputMap(_input1, _placeholder1, _input2, _placeholder2, _input3, _placeholder3, _input4,
                  _placeholder4, _input5, _placeholder5, _input6, _placeholder6, _input7, _placeholder7, _input8,
                  _placeholder8, _input9, _placeholder9);
          output1 = DAGUtil.replaceInputs(output1, inputMapping);
          output2 = DAGUtil.replaceInputs(output2, inputMapping);
          output3 = DAGUtil.replaceInputs(output3, inputMapping);
          output4 = DAGUtil.replaceInputs(output4, inputMapping);
          output5 = DAGUtil.replaceInputs(output5, inputMapping);
        }

        List<Producer<?>> inputs =
            Arrays.asList(_input1, _input2, _input3, _input4, _input5, _input6, _input7, _input8, _input9);

        return ((DAG9x5.Prepared) DAGUtil
            .createPreparedDAG(
                Arrays.asList(_placeholder1, _placeholder2, _placeholder3, _placeholder4, _placeholder5, _placeholder6,
                    _placeholder7, _placeholder8, _placeholder9),
                Arrays.asList(output1, output2, output3, output4, output5)).internalAPI().withInputsUnsafe(inputs))
            .withReduction(_minimumReducerLevel);
      }

      /**
       * Creates a completed DAG by supplying this partial DAG with its outputs (outputs).
       *
       * @param output1 the first output (output) of the DAG
       * @param output2 the second output (output) of the DAG
       * @param output3 the third output (output) of the DAG
       * @param output4 the fourth output (output) of the DAG
       * @param output5 the fifth output (output) of the DAG
       * @param output6 the sixth output (output) of the DAG
       * @param <RA> the type of the first result
       * @param <RB> the type of the second result
       * @param <RC> the type of the third result
       * @param <RD> the type of the fourth result
       * @param <RE> the type of the fifth result
       * @param <RF> the type of the sixth result
       * @return a completed DAG with 9 inputs (placeholders) and 6 outputs (outputs).
       */
      public <RA, RB, RC, RD, RE, RF> DAG9x6.Prepared<A, B, C, D, E, F, G, H, I, RA, RB, RC, RD, RE, RF> withOutputs(
          Producer<? extends RA> output1, Producer<? extends RB> output2, Producer<? extends RC> output3,
          Producer<? extends RD> output4, Producer<? extends RE> output5, Producer<? extends RF> output6) {
        Objects.requireNonNull(output1, "Output 1 may not be null");
        Objects.requireNonNull(output2, "Output 2 may not be null");
        Objects.requireNonNull(output3, "Output 3 may not be null");
        Objects.requireNonNull(output4, "Output 4 may not be null");
        Objects.requireNonNull(output5, "Output 5 may not be null");
        Objects.requireNonNull(output6, "Output 6 may not be null");

        if (_shouldRemapInputs) {
          Map<Producer<?>, Producer<?>> inputMapping =
              DAGUtil.createInputMap(_input1, _placeholder1, _input2, _placeholder2, _input3, _placeholder3, _input4,
                  _placeholder4, _input5, _placeholder5, _input6, _placeholder6, _input7, _placeholder7, _input8,
                  _placeholder8, _input9, _placeholder9);
          output1 = DAGUtil.replaceInputs(output1, inputMapping);
          output2 = DAGUtil.replaceInputs(output2, inputMapping);
          output3 = DAGUtil.replaceInputs(output3, inputMapping);
          output4 = DAGUtil.replaceInputs(output4, inputMapping);
          output5 = DAGUtil.replaceInputs(output5, inputMapping);
          output6 = DAGUtil.replaceInputs(output6, inputMapping);
        }

        List<Producer<?>> inputs =
            Arrays.asList(_input1, _input2, _input3, _input4, _input5, _input6, _input7, _input8, _input9);

        return ((DAG9x6.Prepared) DAGUtil
            .createPreparedDAG(
                Arrays.asList(_placeholder1, _placeholder2, _placeholder3, _placeholder4, _placeholder5, _placeholder6,
                    _placeholder7, _placeholder8, _placeholder9),
                Arrays.asList(output1, output2, output3, output4, output5, output6)).internalAPI()
            .withInputsUnsafe(inputs)).withReduction(_minimumReducerLevel);
      }

      /**
       * Creates a completed DAG by supplying this partial DAG with its outputs (outputs).
       *
       * @param output1 the first output (output) of the DAG
       * @param output2 the second output (output) of the DAG
       * @param output3 the third output (output) of the DAG
       * @param output4 the fourth output (output) of the DAG
       * @param output5 the fifth output (output) of the DAG
       * @param output6 the sixth output (output) of the DAG
       * @param output7 the seventh output (output) of the DAG
       * @param <RA> the type of the first result
       * @param <RB> the type of the second result
       * @param <RC> the type of the third result
       * @param <RD> the type of the fourth result
       * @param <RE> the type of the fifth result
       * @param <RF> the type of the sixth result
       * @param <RG> the type of the seventh result
       * @return a completed DAG with 9 inputs (placeholders) and 7 outputs (outputs).
       */
      public <RA, RB, RC, RD, RE, RF, RG> DAG9x7.Prepared<A, B, C, D, E, F, G, H, I, RA, RB, RC, RD, RE, RF, RG> withOutputs(
          Producer<? extends RA> output1, Producer<? extends RB> output2, Producer<? extends RC> output3,
          Producer<? extends RD> output4, Producer<? extends RE> output5, Producer<? extends RF> output6,
          Producer<? extends RG> output7) {
        Objects.requireNonNull(output1, "Output 1 may not be null");
        Objects.requireNonNull(output2, "Output 2 may not be null");
        Objects.requireNonNull(output3, "Output 3 may not be null");
        Objects.requireNonNull(output4, "Output 4 may not be null");
        Objects.requireNonNull(output5, "Output 5 may not be null");
        Objects.requireNonNull(output6, "Output 6 may not be null");
        Objects.requireNonNull(output7, "Output 7 may not be null");

        if (_shouldRemapInputs) {
          Map<Producer<?>, Producer<?>> inputMapping =
              DAGUtil.createInputMap(_input1, _placeholder1, _input2, _placeholder2, _input3, _placeholder3, _input4,
                  _placeholder4, _input5, _placeholder5, _input6, _placeholder6, _input7, _placeholder7, _input8,
                  _placeholder8, _input9, _placeholder9);
          output1 = DAGUtil.replaceInputs(output1, inputMapping);
          output2 = DAGUtil.replaceInputs(output2, inputMapping);
          output3 = DAGUtil.replaceInputs(output3, inputMapping);
          output4 = DAGUtil.replaceInputs(output4, inputMapping);
          output5 = DAGUtil.replaceInputs(output5, inputMapping);
          output6 = DAGUtil.replaceInputs(output6, inputMapping);
          output7 = DAGUtil.replaceInputs(output7, inputMapping);
        }

        List<Producer<?>> inputs =
            Arrays.asList(_input1, _input2, _input3, _input4, _input5, _input6, _input7, _input8, _input9);

        return ((DAG9x7.Prepared) DAGUtil
            .createPreparedDAG(
                Arrays.asList(_placeholder1, _placeholder2, _placeholder3, _placeholder4, _placeholder5, _placeholder6,
                    _placeholder7, _placeholder8, _placeholder9),
                Arrays.asList(output1, output2, output3, output4, output5, output6, output7)).internalAPI()
            .withInputsUnsafe(inputs)).withReduction(_minimumReducerLevel);
      }

      /**
       * Creates a completed DAG by supplying this partial DAG with its outputs (outputs).
       *
       * @param output1 the first output (output) of the DAG
       * @param output2 the second output (output) of the DAG
       * @param output3 the third output (output) of the DAG
       * @param output4 the fourth output (output) of the DAG
       * @param output5 the fifth output (output) of the DAG
       * @param output6 the sixth output (output) of the DAG
       * @param output7 the seventh output (output) of the DAG
       * @param output8 the eighth output (output) of the DAG
       * @param <RA> the type of the first result
       * @param <RB> the type of the second result
       * @param <RC> the type of the third result
       * @param <RD> the type of the fourth result
       * @param <RE> the type of the fifth result
       * @param <RF> the type of the sixth result
       * @param <RG> the type of the seventh result
       * @param <RH> the type of the eighth result
       * @return a completed DAG with 9 inputs (placeholders) and 8 outputs (outputs).
       */
      public <RA, RB, RC, RD, RE, RF, RG, RH> DAG9x8.Prepared<A, B, C, D, E, F, G, H, I, RA, RB, RC, RD, RE, RF, RG, RH> withOutputs(
          Producer<? extends RA> output1, Producer<? extends RB> output2, Producer<? extends RC> output3,
          Producer<? extends RD> output4, Producer<? extends RE> output5, Producer<? extends RF> output6,
          Producer<? extends RG> output7, Producer<? extends RH> output8) {
        Objects.requireNonNull(output1, "Output 1 may not be null");
        Objects.requireNonNull(output2, "Output 2 may not be null");
        Objects.requireNonNull(output3, "Output 3 may not be null");
        Objects.requireNonNull(output4, "Output 4 may not be null");
        Objects.requireNonNull(output5, "Output 5 may not be null");
        Objects.requireNonNull(output6, "Output 6 may not be null");
        Objects.requireNonNull(output7, "Output 7 may not be null");
        Objects.requireNonNull(output8, "Output 8 may not be null");

        if (_shouldRemapInputs) {
          Map<Producer<?>, Producer<?>> inputMapping =
              DAGUtil.createInputMap(_input1, _placeholder1, _input2, _placeholder2, _input3, _placeholder3, _input4,
                  _placeholder4, _input5, _placeholder5, _input6, _placeholder6, _input7, _placeholder7, _input8,
                  _placeholder8, _input9, _placeholder9);
          output1 = DAGUtil.replaceInputs(output1, inputMapping);
          output2 = DAGUtil.replaceInputs(output2, inputMapping);
          output3 = DAGUtil.replaceInputs(output3, inputMapping);
          output4 = DAGUtil.replaceInputs(output4, inputMapping);
          output5 = DAGUtil.replaceInputs(output5, inputMapping);
          output6 = DAGUtil.replaceInputs(output6, inputMapping);
          output7 = DAGUtil.replaceInputs(output7, inputMapping);
          output8 = DAGUtil.replaceInputs(output8, inputMapping);
        }

        List<Producer<?>> inputs =
            Arrays.asList(_input1, _input2, _input3, _input4, _input5, _input6, _input7, _input8, _input9);

        return ((DAG9x8.Prepared) DAGUtil
            .createPreparedDAG(
                Arrays.asList(_placeholder1, _placeholder2, _placeholder3, _placeholder4, _placeholder5, _placeholder6,
                    _placeholder7, _placeholder8, _placeholder9),
                Arrays.asList(output1, output2, output3, output4, output5, output6, output7, output8)).internalAPI()
            .withInputsUnsafe(inputs)).withReduction(_minimumReducerLevel);
      }

      /**
       * Creates a completed DAG by supplying this partial DAG with its outputs (outputs).
       *
       * @param output1 the first output (output) of the DAG
       * @param output2 the second output (output) of the DAG
       * @param output3 the third output (output) of the DAG
       * @param output4 the fourth output (output) of the DAG
       * @param output5 the fifth output (output) of the DAG
       * @param output6 the sixth output (output) of the DAG
       * @param output7 the seventh output (output) of the DAG
       * @param output8 the eighth output (output) of the DAG
       * @param output9 the ninth output (output) of the DAG
       * @param <RA> the type of the first result
       * @param <RB> the type of the second result
       * @param <RC> the type of the third result
       * @param <RD> the type of the fourth result
       * @param <RE> the type of the fifth result
       * @param <RF> the type of the sixth result
       * @param <RG> the type of the seventh result
       * @param <RH> the type of the eighth result
       * @param <RI> the type of the ninth result
       * @return a completed DAG with 9 inputs (placeholders) and 9 outputs (outputs).
       */
      public <RA, RB, RC, RD, RE, RF, RG, RH, RI> DAG9x9.Prepared<A, B, C, D, E, F, G, H, I, RA, RB, RC, RD, RE, RF, RG, RH, RI> withOutputs(
          Producer<? extends RA> output1, Producer<? extends RB> output2, Producer<? extends RC> output3,
          Producer<? extends RD> output4, Producer<? extends RE> output5, Producer<? extends RF> output6,
          Producer<? extends RG> output7, Producer<? extends RH> output8, Producer<? extends RI> output9) {
        Objects.requireNonNull(output1, "Output 1 may not be null");
        Objects.requireNonNull(output2, "Output 2 may not be null");
        Objects.requireNonNull(output3, "Output 3 may not be null");
        Objects.requireNonNull(output4, "Output 4 may not be null");
        Objects.requireNonNull(output5, "Output 5 may not be null");
        Objects.requireNonNull(output6, "Output 6 may not be null");
        Objects.requireNonNull(output7, "Output 7 may not be null");
        Objects.requireNonNull(output8, "Output 8 may not be null");
        Objects.requireNonNull(output9, "Output 9 may not be null");

        if (_shouldRemapInputs) {
          Map<Producer<?>, Producer<?>> inputMapping =
              DAGUtil.createInputMap(_input1, _placeholder1, _input2, _placeholder2, _input3, _placeholder3, _input4,
                  _placeholder4, _input5, _placeholder5, _input6, _placeholder6, _input7, _placeholder7, _input8,
                  _placeholder8, _input9, _placeholder9);
          output1 = DAGUtil.replaceInputs(output1, inputMapping);
          output2 = DAGUtil.replaceInputs(output2, inputMapping);
          output3 = DAGUtil.replaceInputs(output3, inputMapping);
          output4 = DAGUtil.replaceInputs(output4, inputMapping);
          output5 = DAGUtil.replaceInputs(output5, inputMapping);
          output6 = DAGUtil.replaceInputs(output6, inputMapping);
          output7 = DAGUtil.replaceInputs(output7, inputMapping);
          output8 = DAGUtil.replaceInputs(output8, inputMapping);
          output9 = DAGUtil.replaceInputs(output9, inputMapping);
        }

        List<Producer<?>> inputs =
            Arrays.asList(_input1, _input2, _input3, _input4, _input5, _input6, _input7, _input8, _input9);

        return ((DAG9x9.Prepared) DAGUtil
            .createPreparedDAG(
                Arrays.asList(_placeholder1, _placeholder2, _placeholder3, _placeholder4, _placeholder5, _placeholder6,
                    _placeholder7, _placeholder8, _placeholder9),
                Arrays.asList(output1, output2, output3, output4, output5, output6, output7, output8, output9))
            .internalAPI().withInputsUnsafe(inputs)).withReduction(_minimumReducerLevel);
      }

      /**
       * Creates a completed DAG by supplying this partial DAG with its outputs (outputs).
       *
       * @param output1 the first output (output) of the DAG
       * @param output2 the second output (output) of the DAG
       * @param output3 the third output (output) of the DAG
       * @param output4 the fourth output (output) of the DAG
       * @param output5 the fifth output (output) of the DAG
       * @param output6 the sixth output (output) of the DAG
       * @param output7 the seventh output (output) of the DAG
       * @param output8 the eighth output (output) of the DAG
       * @param output9 the ninth output (output) of the DAG
       * @param output10 the tenth output (output) of the DAG
       * @param <RA> the type of the first result
       * @param <RB> the type of the second result
       * @param <RC> the type of the third result
       * @param <RD> the type of the fourth result
       * @param <RE> the type of the fifth result
       * @param <RF> the type of the sixth result
       * @param <RG> the type of the seventh result
       * @param <RH> the type of the eighth result
       * @param <RI> the type of the ninth result
       * @param <RJ> the type of the tenth result
       * @return a completed DAG with 9 inputs (placeholders) and 10 outputs (outputs).
       */
      public <RA, RB, RC, RD, RE, RF, RG, RH, RI, RJ> DAG9x10.Prepared<A, B, C, D, E, F, G, H, I, RA, RB, RC, RD, RE, RF, RG, RH, RI, RJ> withOutputs(
          Producer<? extends RA> output1, Producer<? extends RB> output2, Producer<? extends RC> output3,
          Producer<? extends RD> output4, Producer<? extends RE> output5, Producer<? extends RF> output6,
          Producer<? extends RG> output7, Producer<? extends RH> output8, Producer<? extends RI> output9,
          Producer<? extends RJ> output10) {
        Objects.requireNonNull(output1, "Output 1 may not be null");
        Objects.requireNonNull(output2, "Output 2 may not be null");
        Objects.requireNonNull(output3, "Output 3 may not be null");
        Objects.requireNonNull(output4, "Output 4 may not be null");
        Objects.requireNonNull(output5, "Output 5 may not be null");
        Objects.requireNonNull(output6, "Output 6 may not be null");
        Objects.requireNonNull(output7, "Output 7 may not be null");
        Objects.requireNonNull(output8, "Output 8 may not be null");
        Objects.requireNonNull(output9, "Output 9 may not be null");
        Objects.requireNonNull(output10, "Output 10 may not be null");

        if (_shouldRemapInputs) {
          Map<Producer<?>, Producer<?>> inputMapping =
              DAGUtil.createInputMap(_input1, _placeholder1, _input2, _placeholder2, _input3, _placeholder3, _input4,
                  _placeholder4, _input5, _placeholder5, _input6, _placeholder6, _input7, _placeholder7, _input8,
                  _placeholder8, _input9, _placeholder9);
          output1 = DAGUtil.replaceInputs(output1, inputMapping);
          output2 = DAGUtil.replaceInputs(output2, inputMapping);
          output3 = DAGUtil.replaceInputs(output3, inputMapping);
          output4 = DAGUtil.replaceInputs(output4, inputMapping);
          output5 = DAGUtil.replaceInputs(output5, inputMapping);
          output6 = DAGUtil.replaceInputs(output6, inputMapping);
          output7 = DAGUtil.replaceInputs(output7, inputMapping);
          output8 = DAGUtil.replaceInputs(output8, inputMapping);
          output9 = DAGUtil.replaceInputs(output9, inputMapping);
          output10 = DAGUtil.replaceInputs(output10, inputMapping);
        }

        List<Producer<?>> inputs =
            Arrays.asList(_input1, _input2, _input3, _input4, _input5, _input6, _input7, _input8, _input9);

        return ((DAG9x10.Prepared) DAGUtil
            .createPreparedDAG(
                Arrays.asList(_placeholder1, _placeholder2, _placeholder3, _placeholder4, _placeholder5, _placeholder6,
                    _placeholder7, _placeholder8, _placeholder9),
                Arrays
                    .asList(output1, output2, output3, output4, output5, output6, output7, output8, output9, output10))
            .internalAPI().withInputsUnsafe(inputs)).withReduction(_minimumReducerLevel);
      }
    }

    /**
      * A partial DAG with 10 placeholder.  Partial DAGs are <i>completed</i> to create a usable DAG by specifying
      * the outputs (<i>outputs</i>) of the DAG using the withOutputs(...) methods.
      *
     * @param <A> the type of the first input
     * @param <B> the type of the second input
     * @param <C> the type of the third input
     * @param <D> the type of the fourth input
     * @param <E> the type of the fifth input
     * @param <F> the type of the sixth input
     * @param <G> the type of the seventh input
     * @param <H> the type of the eighth input
     * @param <I> the type of the ninth input
     * @param <J> the type of the tenth input
      */
    public static class WithPlaceholders10<A, B, C, D, E, F, G, H, I, J> extends
        AbstractWithPlaceholders10<A, B, C, D, E, F, G, H, I, J, WithPlaceholders10<A, B, C, D, E, F, G, H, I, J>> {
      /**
       * Creates a new partial DAG that will be rooted at the provided placeholders.
       *
       * @param placeholder1 the first placeholder
       * @param placeholder2 the second placeholder
       * @param placeholder3 the third placeholder
       * @param placeholder4 the fourth placeholder
       * @param placeholder5 the fifth placeholder
       * @param placeholder6 the sixth placeholder
       * @param placeholder7 the seventh placeholder
       * @param placeholder8 the eighth placeholder
       * @param placeholder9 the ninth placeholder
       * @param placeholder10 the tenth placeholder
       */
      WithPlaceholders10(Placeholder<? extends A> placeholder1, Placeholder<? extends B> placeholder2,
          Placeholder<? extends C> placeholder3, Placeholder<? extends D> placeholder4,
          Placeholder<? extends E> placeholder5, Placeholder<? extends F> placeholder6,
          Placeholder<? extends G> placeholder7, Placeholder<? extends H> placeholder8,
          Placeholder<? extends I> placeholder9, Placeholder<? extends J> placeholder10) {
        super(placeholder1, placeholder2, placeholder3, placeholder4, placeholder5, placeholder6, placeholder7,
            placeholder8, placeholder9, placeholder10);
      }

      /**
       * Creates a new partial DAG that will be rooted at the provided placeholders, which will replace ("remap") the provided
       * "input" nodes that define a subgraph of the original graph (as defined by the ancestors of the outputs that will
       * be provided when the partial DAG is completed).  The input nodes, and any nodes that were exclusively the
       * ancestors of the input nodes, are truncated from the resulting graph.
       *
       * @param placeholder1 the first placeholder
       * @param placeholder2 the second placeholder
       * @param placeholder3 the third placeholder
       * @param placeholder4 the fourth placeholder
       * @param placeholder5 the fifth placeholder
       * @param placeholder6 the sixth placeholder
       * @param placeholder7 the seventh placeholder
       * @param placeholder8 the eighth placeholder
       * @param placeholder9 the ninth placeholder
       * @param placeholder10 the tenth placeholder
       * @param input1 the first input
       * @param input2 the second input
       * @param input3 the third input
       * @param input4 the fourth input
       * @param input5 the fifth input
       * @param input6 the sixth input
       * @param input7 the seventh input
       * @param input8 the eighth input
       * @param input9 the ninth input
       * @param input10 the tenth input
       */
      WithPlaceholders10(Placeholder<? extends A> placeholder1, Placeholder<? extends B> placeholder2,
          Placeholder<? extends C> placeholder3, Placeholder<? extends D> placeholder4,
          Placeholder<? extends E> placeholder5, Placeholder<? extends F> placeholder6,
          Placeholder<? extends G> placeholder7, Placeholder<? extends H> placeholder8,
          Placeholder<? extends I> placeholder9, Placeholder<? extends J> placeholder10, Producer<? extends A> input1,
          Producer<? extends B> input2, Producer<? extends C> input3, Producer<? extends D> input4,
          Producer<? extends E> input5, Producer<? extends F> input6, Producer<? extends G> input7,
          Producer<? extends H> input8, Producer<? extends I> input9, Producer<? extends J> input10) {
        super(placeholder1, placeholder2, placeholder3, placeholder4, placeholder5, placeholder6, placeholder7,
            placeholder8, placeholder9, placeholder10, input1, input2, input3, input4, input5, input6, input7, input8,
            input9, input10);
      }

      /**
       * Creates a completed DAG by supplying this partial DAG with its outputs (outputs).
       *
       * @param output1 the first output (output) of the DAG
       * @param <RA> the type of the first result
       * @return a completed DAG with 10 inputs (placeholders) and 1 output (outputs).
       */
      public <RA> DAG10x1.Prepared<A, B, C, D, E, F, G, H, I, J, RA> withOutputs(Producer<? extends RA> output1) {
        Objects.requireNonNull(output1, "Output 1 may not be null");

        if (_shouldRemapInputs) {
          Map<Producer<?>, Producer<?>> inputMapping =
              DAGUtil.createInputMap(_input1, _placeholder1, _input2, _placeholder2, _input3, _placeholder3, _input4,
                  _placeholder4, _input5, _placeholder5, _input6, _placeholder6, _input7, _placeholder7, _input8,
                  _placeholder8, _input9, _placeholder9, _input10, _placeholder10);
          output1 = DAGUtil.replaceInputs(output1, inputMapping);
        }

        List<Producer<?>> inputs =
            Arrays.asList(_input1, _input2, _input3, _input4, _input5, _input6, _input7, _input8, _input9, _input10);

        return ((DAG10x1.Prepared) DAGUtil
            .createPreparedDAG(
                Arrays.asList(_placeholder1, _placeholder2, _placeholder3, _placeholder4, _placeholder5, _placeholder6,
                    _placeholder7, _placeholder8, _placeholder9, _placeholder10), Arrays.asList(output1)).internalAPI()
            .withInputsUnsafe(inputs)).withReduction(_minimumReducerLevel);
      }

      /**
       * Creates a completed DAG by supplying this partial DAG with its outputs (outputs).
       *
       * @param output1 the first output (output) of the DAG
       * @param <RA> the type of the first result
       * @return a completed DAG with 10 inputs (placeholders) and 1 output (outputs).
       */
      public <RA> DAG10x1.Prepared<A, B, C, D, E, F, G, H, I, J, RA> withOutput(Producer<? extends RA> output1) {
        Objects.requireNonNull(output1, "Output 1 may not be null");

        if (_shouldRemapInputs) {
          Map<Producer<?>, Producer<?>> inputMapping =
              DAGUtil.createInputMap(_input1, _placeholder1, _input2, _placeholder2, _input3, _placeholder3, _input4,
                  _placeholder4, _input5, _placeholder5, _input6, _placeholder6, _input7, _placeholder7, _input8,
                  _placeholder8, _input9, _placeholder9, _input10, _placeholder10);
          output1 = DAGUtil.replaceInputs(output1, inputMapping);
        }

        List<Producer<?>> inputs =
            Arrays.asList(_input1, _input2, _input3, _input4, _input5, _input6, _input7, _input8, _input9, _input10);

        return ((DAG10x1.Prepared) DAGUtil
            .createPreparedDAG(
                Arrays.asList(_placeholder1, _placeholder2, _placeholder3, _placeholder4, _placeholder5, _placeholder6,
                    _placeholder7, _placeholder8, _placeholder9, _placeholder10), Arrays.asList(output1)).internalAPI()
            .withInputsUnsafe(inputs)).withReduction(_minimumReducerLevel);
      }

      /**
       * Creates a completed DAG by supplying this partial DAG with its outputs (outputs).
       *
       * @param output1 the first output (output) of the DAG
       * @param output2 the second output (output) of the DAG
       * @param <RA> the type of the first result
       * @param <RB> the type of the second result
       * @return a completed DAG with 10 inputs (placeholders) and 2 outputs (outputs).
       */
      public <RA, RB> DAG10x2.Prepared<A, B, C, D, E, F, G, H, I, J, RA, RB> withOutputs(
          Producer<? extends RA> output1, Producer<? extends RB> output2) {
        Objects.requireNonNull(output1, "Output 1 may not be null");
        Objects.requireNonNull(output2, "Output 2 may not be null");

        if (_shouldRemapInputs) {
          Map<Producer<?>, Producer<?>> inputMapping =
              DAGUtil.createInputMap(_input1, _placeholder1, _input2, _placeholder2, _input3, _placeholder3, _input4,
                  _placeholder4, _input5, _placeholder5, _input6, _placeholder6, _input7, _placeholder7, _input8,
                  _placeholder8, _input9, _placeholder9, _input10, _placeholder10);
          output1 = DAGUtil.replaceInputs(output1, inputMapping);
          output2 = DAGUtil.replaceInputs(output2, inputMapping);
        }

        List<Producer<?>> inputs =
            Arrays.asList(_input1, _input2, _input3, _input4, _input5, _input6, _input7, _input8, _input9, _input10);

        return ((DAG10x2.Prepared) DAGUtil
            .createPreparedDAG(
                Arrays.asList(_placeholder1, _placeholder2, _placeholder3, _placeholder4, _placeholder5, _placeholder6,
                    _placeholder7, _placeholder8, _placeholder9, _placeholder10), Arrays.asList(output1, output2))
            .internalAPI().withInputsUnsafe(inputs)).withReduction(_minimumReducerLevel);
      }

      /**
       * Creates a completed DAG by supplying this partial DAG with its outputs (outputs).
       *
       * @param output1 the first output (output) of the DAG
       * @param output2 the second output (output) of the DAG
       * @param output3 the third output (output) of the DAG
       * @param <RA> the type of the first result
       * @param <RB> the type of the second result
       * @param <RC> the type of the third result
       * @return a completed DAG with 10 inputs (placeholders) and 3 outputs (outputs).
       */
      public <RA, RB, RC> DAG10x3.Prepared<A, B, C, D, E, F, G, H, I, J, RA, RB, RC> withOutputs(
          Producer<? extends RA> output1, Producer<? extends RB> output2, Producer<? extends RC> output3) {
        Objects.requireNonNull(output1, "Output 1 may not be null");
        Objects.requireNonNull(output2, "Output 2 may not be null");
        Objects.requireNonNull(output3, "Output 3 may not be null");

        if (_shouldRemapInputs) {
          Map<Producer<?>, Producer<?>> inputMapping =
              DAGUtil.createInputMap(_input1, _placeholder1, _input2, _placeholder2, _input3, _placeholder3, _input4,
                  _placeholder4, _input5, _placeholder5, _input6, _placeholder6, _input7, _placeholder7, _input8,
                  _placeholder8, _input9, _placeholder9, _input10, _placeholder10);
          output1 = DAGUtil.replaceInputs(output1, inputMapping);
          output2 = DAGUtil.replaceInputs(output2, inputMapping);
          output3 = DAGUtil.replaceInputs(output3, inputMapping);
        }

        List<Producer<?>> inputs =
            Arrays.asList(_input1, _input2, _input3, _input4, _input5, _input6, _input7, _input8, _input9, _input10);

        return ((DAG10x3.Prepared) DAGUtil
            .createPreparedDAG(
                Arrays.asList(_placeholder1, _placeholder2, _placeholder3, _placeholder4, _placeholder5, _placeholder6,
                    _placeholder7, _placeholder8, _placeholder9, _placeholder10),
                Arrays.asList(output1, output2, output3)).internalAPI().withInputsUnsafe(inputs))
            .withReduction(_minimumReducerLevel);
      }

      /**
       * Creates a completed DAG by supplying this partial DAG with its outputs (outputs).
       *
       * @param output1 the first output (output) of the DAG
       * @param output2 the second output (output) of the DAG
       * @param output3 the third output (output) of the DAG
       * @param output4 the fourth output (output) of the DAG
       * @param <RA> the type of the first result
       * @param <RB> the type of the second result
       * @param <RC> the type of the third result
       * @param <RD> the type of the fourth result
       * @return a completed DAG with 10 inputs (placeholders) and 4 outputs (outputs).
       */
      public <RA, RB, RC, RD> DAG10x4.Prepared<A, B, C, D, E, F, G, H, I, J, RA, RB, RC, RD> withOutputs(
          Producer<? extends RA> output1, Producer<? extends RB> output2, Producer<? extends RC> output3,
          Producer<? extends RD> output4) {
        Objects.requireNonNull(output1, "Output 1 may not be null");
        Objects.requireNonNull(output2, "Output 2 may not be null");
        Objects.requireNonNull(output3, "Output 3 may not be null");
        Objects.requireNonNull(output4, "Output 4 may not be null");

        if (_shouldRemapInputs) {
          Map<Producer<?>, Producer<?>> inputMapping =
              DAGUtil.createInputMap(_input1, _placeholder1, _input2, _placeholder2, _input3, _placeholder3, _input4,
                  _placeholder4, _input5, _placeholder5, _input6, _placeholder6, _input7, _placeholder7, _input8,
                  _placeholder8, _input9, _placeholder9, _input10, _placeholder10);
          output1 = DAGUtil.replaceInputs(output1, inputMapping);
          output2 = DAGUtil.replaceInputs(output2, inputMapping);
          output3 = DAGUtil.replaceInputs(output3, inputMapping);
          output4 = DAGUtil.replaceInputs(output4, inputMapping);
        }

        List<Producer<?>> inputs =
            Arrays.asList(_input1, _input2, _input3, _input4, _input5, _input6, _input7, _input8, _input9, _input10);

        return ((DAG10x4.Prepared) DAGUtil
            .createPreparedDAG(
                Arrays.asList(_placeholder1, _placeholder2, _placeholder3, _placeholder4, _placeholder5, _placeholder6,
                    _placeholder7, _placeholder8, _placeholder9, _placeholder10),
                Arrays.asList(output1, output2, output3, output4)).internalAPI().withInputsUnsafe(inputs))
            .withReduction(_minimumReducerLevel);
      }

      /**
       * Creates a completed DAG by supplying this partial DAG with its outputs (outputs).
       *
       * @param output1 the first output (output) of the DAG
       * @param output2 the second output (output) of the DAG
       * @param output3 the third output (output) of the DAG
       * @param output4 the fourth output (output) of the DAG
       * @param output5 the fifth output (output) of the DAG
       * @param <RA> the type of the first result
       * @param <RB> the type of the second result
       * @param <RC> the type of the third result
       * @param <RD> the type of the fourth result
       * @param <RE> the type of the fifth result
       * @return a completed DAG with 10 inputs (placeholders) and 5 outputs (outputs).
       */
      public <RA, RB, RC, RD, RE> DAG10x5.Prepared<A, B, C, D, E, F, G, H, I, J, RA, RB, RC, RD, RE> withOutputs(
          Producer<? extends RA> output1, Producer<? extends RB> output2, Producer<? extends RC> output3,
          Producer<? extends RD> output4, Producer<? extends RE> output5) {
        Objects.requireNonNull(output1, "Output 1 may not be null");
        Objects.requireNonNull(output2, "Output 2 may not be null");
        Objects.requireNonNull(output3, "Output 3 may not be null");
        Objects.requireNonNull(output4, "Output 4 may not be null");
        Objects.requireNonNull(output5, "Output 5 may not be null");

        if (_shouldRemapInputs) {
          Map<Producer<?>, Producer<?>> inputMapping =
              DAGUtil.createInputMap(_input1, _placeholder1, _input2, _placeholder2, _input3, _placeholder3, _input4,
                  _placeholder4, _input5, _placeholder5, _input6, _placeholder6, _input7, _placeholder7, _input8,
                  _placeholder8, _input9, _placeholder9, _input10, _placeholder10);
          output1 = DAGUtil.replaceInputs(output1, inputMapping);
          output2 = DAGUtil.replaceInputs(output2, inputMapping);
          output3 = DAGUtil.replaceInputs(output3, inputMapping);
          output4 = DAGUtil.replaceInputs(output4, inputMapping);
          output5 = DAGUtil.replaceInputs(output5, inputMapping);
        }

        List<Producer<?>> inputs =
            Arrays.asList(_input1, _input2, _input3, _input4, _input5, _input6, _input7, _input8, _input9, _input10);

        return ((DAG10x5.Prepared) DAGUtil
            .createPreparedDAG(
                Arrays.asList(_placeholder1, _placeholder2, _placeholder3, _placeholder4, _placeholder5, _placeholder6,
                    _placeholder7, _placeholder8, _placeholder9, _placeholder10),
                Arrays.asList(output1, output2, output3, output4, output5)).internalAPI().withInputsUnsafe(inputs))
            .withReduction(_minimumReducerLevel);
      }

      /**
       * Creates a completed DAG by supplying this partial DAG with its outputs (outputs).
       *
       * @param output1 the first output (output) of the DAG
       * @param output2 the second output (output) of the DAG
       * @param output3 the third output (output) of the DAG
       * @param output4 the fourth output (output) of the DAG
       * @param output5 the fifth output (output) of the DAG
       * @param output6 the sixth output (output) of the DAG
       * @param <RA> the type of the first result
       * @param <RB> the type of the second result
       * @param <RC> the type of the third result
       * @param <RD> the type of the fourth result
       * @param <RE> the type of the fifth result
       * @param <RF> the type of the sixth result
       * @return a completed DAG with 10 inputs (placeholders) and 6 outputs (outputs).
       */
      public <RA, RB, RC, RD, RE, RF> DAG10x6.Prepared<A, B, C, D, E, F, G, H, I, J, RA, RB, RC, RD, RE, RF> withOutputs(
          Producer<? extends RA> output1, Producer<? extends RB> output2, Producer<? extends RC> output3,
          Producer<? extends RD> output4, Producer<? extends RE> output5, Producer<? extends RF> output6) {
        Objects.requireNonNull(output1, "Output 1 may not be null");
        Objects.requireNonNull(output2, "Output 2 may not be null");
        Objects.requireNonNull(output3, "Output 3 may not be null");
        Objects.requireNonNull(output4, "Output 4 may not be null");
        Objects.requireNonNull(output5, "Output 5 may not be null");
        Objects.requireNonNull(output6, "Output 6 may not be null");

        if (_shouldRemapInputs) {
          Map<Producer<?>, Producer<?>> inputMapping =
              DAGUtil.createInputMap(_input1, _placeholder1, _input2, _placeholder2, _input3, _placeholder3, _input4,
                  _placeholder4, _input5, _placeholder5, _input6, _placeholder6, _input7, _placeholder7, _input8,
                  _placeholder8, _input9, _placeholder9, _input10, _placeholder10);
          output1 = DAGUtil.replaceInputs(output1, inputMapping);
          output2 = DAGUtil.replaceInputs(output2, inputMapping);
          output3 = DAGUtil.replaceInputs(output3, inputMapping);
          output4 = DAGUtil.replaceInputs(output4, inputMapping);
          output5 = DAGUtil.replaceInputs(output5, inputMapping);
          output6 = DAGUtil.replaceInputs(output6, inputMapping);
        }

        List<Producer<?>> inputs =
            Arrays.asList(_input1, _input2, _input3, _input4, _input5, _input6, _input7, _input8, _input9, _input10);

        return ((DAG10x6.Prepared) DAGUtil
            .createPreparedDAG(
                Arrays.asList(_placeholder1, _placeholder2, _placeholder3, _placeholder4, _placeholder5, _placeholder6,
                    _placeholder7, _placeholder8, _placeholder9, _placeholder10),
                Arrays.asList(output1, output2, output3, output4, output5, output6)).internalAPI()
            .withInputsUnsafe(inputs)).withReduction(_minimumReducerLevel);
      }

      /**
       * Creates a completed DAG by supplying this partial DAG with its outputs (outputs).
       *
       * @param output1 the first output (output) of the DAG
       * @param output2 the second output (output) of the DAG
       * @param output3 the third output (output) of the DAG
       * @param output4 the fourth output (output) of the DAG
       * @param output5 the fifth output (output) of the DAG
       * @param output6 the sixth output (output) of the DAG
       * @param output7 the seventh output (output) of the DAG
       * @param <RA> the type of the first result
       * @param <RB> the type of the second result
       * @param <RC> the type of the third result
       * @param <RD> the type of the fourth result
       * @param <RE> the type of the fifth result
       * @param <RF> the type of the sixth result
       * @param <RG> the type of the seventh result
       * @return a completed DAG with 10 inputs (placeholders) and 7 outputs (outputs).
       */
      public <RA, RB, RC, RD, RE, RF, RG> DAG10x7.Prepared<A, B, C, D, E, F, G, H, I, J, RA, RB, RC, RD, RE, RF, RG> withOutputs(
          Producer<? extends RA> output1, Producer<? extends RB> output2, Producer<? extends RC> output3,
          Producer<? extends RD> output4, Producer<? extends RE> output5, Producer<? extends RF> output6,
          Producer<? extends RG> output7) {
        Objects.requireNonNull(output1, "Output 1 may not be null");
        Objects.requireNonNull(output2, "Output 2 may not be null");
        Objects.requireNonNull(output3, "Output 3 may not be null");
        Objects.requireNonNull(output4, "Output 4 may not be null");
        Objects.requireNonNull(output5, "Output 5 may not be null");
        Objects.requireNonNull(output6, "Output 6 may not be null");
        Objects.requireNonNull(output7, "Output 7 may not be null");

        if (_shouldRemapInputs) {
          Map<Producer<?>, Producer<?>> inputMapping =
              DAGUtil.createInputMap(_input1, _placeholder1, _input2, _placeholder2, _input3, _placeholder3, _input4,
                  _placeholder4, _input5, _placeholder5, _input6, _placeholder6, _input7, _placeholder7, _input8,
                  _placeholder8, _input9, _placeholder9, _input10, _placeholder10);
          output1 = DAGUtil.replaceInputs(output1, inputMapping);
          output2 = DAGUtil.replaceInputs(output2, inputMapping);
          output3 = DAGUtil.replaceInputs(output3, inputMapping);
          output4 = DAGUtil.replaceInputs(output4, inputMapping);
          output5 = DAGUtil.replaceInputs(output5, inputMapping);
          output6 = DAGUtil.replaceInputs(output6, inputMapping);
          output7 = DAGUtil.replaceInputs(output7, inputMapping);
        }

        List<Producer<?>> inputs =
            Arrays.asList(_input1, _input2, _input3, _input4, _input5, _input6, _input7, _input8, _input9, _input10);

        return ((DAG10x7.Prepared) DAGUtil
            .createPreparedDAG(
                Arrays.asList(_placeholder1, _placeholder2, _placeholder3, _placeholder4, _placeholder5, _placeholder6,
                    _placeholder7, _placeholder8, _placeholder9, _placeholder10),
                Arrays.asList(output1, output2, output3, output4, output5, output6, output7)).internalAPI()
            .withInputsUnsafe(inputs)).withReduction(_minimumReducerLevel);
      }

      /**
       * Creates a completed DAG by supplying this partial DAG with its outputs (outputs).
       *
       * @param output1 the first output (output) of the DAG
       * @param output2 the second output (output) of the DAG
       * @param output3 the third output (output) of the DAG
       * @param output4 the fourth output (output) of the DAG
       * @param output5 the fifth output (output) of the DAG
       * @param output6 the sixth output (output) of the DAG
       * @param output7 the seventh output (output) of the DAG
       * @param output8 the eighth output (output) of the DAG
       * @param <RA> the type of the first result
       * @param <RB> the type of the second result
       * @param <RC> the type of the third result
       * @param <RD> the type of the fourth result
       * @param <RE> the type of the fifth result
       * @param <RF> the type of the sixth result
       * @param <RG> the type of the seventh result
       * @param <RH> the type of the eighth result
       * @return a completed DAG with 10 inputs (placeholders) and 8 outputs (outputs).
       */
      public <RA, RB, RC, RD, RE, RF, RG, RH> DAG10x8.Prepared<A, B, C, D, E, F, G, H, I, J, RA, RB, RC, RD, RE, RF, RG, RH> withOutputs(
          Producer<? extends RA> output1, Producer<? extends RB> output2, Producer<? extends RC> output3,
          Producer<? extends RD> output4, Producer<? extends RE> output5, Producer<? extends RF> output6,
          Producer<? extends RG> output7, Producer<? extends RH> output8) {
        Objects.requireNonNull(output1, "Output 1 may not be null");
        Objects.requireNonNull(output2, "Output 2 may not be null");
        Objects.requireNonNull(output3, "Output 3 may not be null");
        Objects.requireNonNull(output4, "Output 4 may not be null");
        Objects.requireNonNull(output5, "Output 5 may not be null");
        Objects.requireNonNull(output6, "Output 6 may not be null");
        Objects.requireNonNull(output7, "Output 7 may not be null");
        Objects.requireNonNull(output8, "Output 8 may not be null");

        if (_shouldRemapInputs) {
          Map<Producer<?>, Producer<?>> inputMapping =
              DAGUtil.createInputMap(_input1, _placeholder1, _input2, _placeholder2, _input3, _placeholder3, _input4,
                  _placeholder4, _input5, _placeholder5, _input6, _placeholder6, _input7, _placeholder7, _input8,
                  _placeholder8, _input9, _placeholder9, _input10, _placeholder10);
          output1 = DAGUtil.replaceInputs(output1, inputMapping);
          output2 = DAGUtil.replaceInputs(output2, inputMapping);
          output3 = DAGUtil.replaceInputs(output3, inputMapping);
          output4 = DAGUtil.replaceInputs(output4, inputMapping);
          output5 = DAGUtil.replaceInputs(output5, inputMapping);
          output6 = DAGUtil.replaceInputs(output6, inputMapping);
          output7 = DAGUtil.replaceInputs(output7, inputMapping);
          output8 = DAGUtil.replaceInputs(output8, inputMapping);
        }

        List<Producer<?>> inputs =
            Arrays.asList(_input1, _input2, _input3, _input4, _input5, _input6, _input7, _input8, _input9, _input10);

        return ((DAG10x8.Prepared) DAGUtil
            .createPreparedDAG(
                Arrays.asList(_placeholder1, _placeholder2, _placeholder3, _placeholder4, _placeholder5, _placeholder6,
                    _placeholder7, _placeholder8, _placeholder9, _placeholder10),
                Arrays.asList(output1, output2, output3, output4, output5, output6, output7, output8)).internalAPI()
            .withInputsUnsafe(inputs)).withReduction(_minimumReducerLevel);
      }

      /**
       * Creates a completed DAG by supplying this partial DAG with its outputs (outputs).
       *
       * @param output1 the first output (output) of the DAG
       * @param output2 the second output (output) of the DAG
       * @param output3 the third output (output) of the DAG
       * @param output4 the fourth output (output) of the DAG
       * @param output5 the fifth output (output) of the DAG
       * @param output6 the sixth output (output) of the DAG
       * @param output7 the seventh output (output) of the DAG
       * @param output8 the eighth output (output) of the DAG
       * @param output9 the ninth output (output) of the DAG
       * @param <RA> the type of the first result
       * @param <RB> the type of the second result
       * @param <RC> the type of the third result
       * @param <RD> the type of the fourth result
       * @param <RE> the type of the fifth result
       * @param <RF> the type of the sixth result
       * @param <RG> the type of the seventh result
       * @param <RH> the type of the eighth result
       * @param <RI> the type of the ninth result
       * @return a completed DAG with 10 inputs (placeholders) and 9 outputs (outputs).
       */
      public <RA, RB, RC, RD, RE, RF, RG, RH, RI> DAG10x9.Prepared<A, B, C, D, E, F, G, H, I, J, RA, RB, RC, RD, RE, RF, RG, RH, RI> withOutputs(
          Producer<? extends RA> output1, Producer<? extends RB> output2, Producer<? extends RC> output3,
          Producer<? extends RD> output4, Producer<? extends RE> output5, Producer<? extends RF> output6,
          Producer<? extends RG> output7, Producer<? extends RH> output8, Producer<? extends RI> output9) {
        Objects.requireNonNull(output1, "Output 1 may not be null");
        Objects.requireNonNull(output2, "Output 2 may not be null");
        Objects.requireNonNull(output3, "Output 3 may not be null");
        Objects.requireNonNull(output4, "Output 4 may not be null");
        Objects.requireNonNull(output5, "Output 5 may not be null");
        Objects.requireNonNull(output6, "Output 6 may not be null");
        Objects.requireNonNull(output7, "Output 7 may not be null");
        Objects.requireNonNull(output8, "Output 8 may not be null");
        Objects.requireNonNull(output9, "Output 9 may not be null");

        if (_shouldRemapInputs) {
          Map<Producer<?>, Producer<?>> inputMapping =
              DAGUtil.createInputMap(_input1, _placeholder1, _input2, _placeholder2, _input3, _placeholder3, _input4,
                  _placeholder4, _input5, _placeholder5, _input6, _placeholder6, _input7, _placeholder7, _input8,
                  _placeholder8, _input9, _placeholder9, _input10, _placeholder10);
          output1 = DAGUtil.replaceInputs(output1, inputMapping);
          output2 = DAGUtil.replaceInputs(output2, inputMapping);
          output3 = DAGUtil.replaceInputs(output3, inputMapping);
          output4 = DAGUtil.replaceInputs(output4, inputMapping);
          output5 = DAGUtil.replaceInputs(output5, inputMapping);
          output6 = DAGUtil.replaceInputs(output6, inputMapping);
          output7 = DAGUtil.replaceInputs(output7, inputMapping);
          output8 = DAGUtil.replaceInputs(output8, inputMapping);
          output9 = DAGUtil.replaceInputs(output9, inputMapping);
        }

        List<Producer<?>> inputs =
            Arrays.asList(_input1, _input2, _input3, _input4, _input5, _input6, _input7, _input8, _input9, _input10);

        return ((DAG10x9.Prepared) DAGUtil
            .createPreparedDAG(
                Arrays.asList(_placeholder1, _placeholder2, _placeholder3, _placeholder4, _placeholder5, _placeholder6,
                    _placeholder7, _placeholder8, _placeholder9, _placeholder10),
                Arrays.asList(output1, output2, output3, output4, output5, output6, output7, output8, output9))
            .internalAPI().withInputsUnsafe(inputs)).withReduction(_minimumReducerLevel);
      }

      /**
       * Creates a completed DAG by supplying this partial DAG with its outputs (outputs).
       *
       * @param output1 the first output (output) of the DAG
       * @param output2 the second output (output) of the DAG
       * @param output3 the third output (output) of the DAG
       * @param output4 the fourth output (output) of the DAG
       * @param output5 the fifth output (output) of the DAG
       * @param output6 the sixth output (output) of the DAG
       * @param output7 the seventh output (output) of the DAG
       * @param output8 the eighth output (output) of the DAG
       * @param output9 the ninth output (output) of the DAG
       * @param output10 the tenth output (output) of the DAG
       * @param <RA> the type of the first result
       * @param <RB> the type of the second result
       * @param <RC> the type of the third result
       * @param <RD> the type of the fourth result
       * @param <RE> the type of the fifth result
       * @param <RF> the type of the sixth result
       * @param <RG> the type of the seventh result
       * @param <RH> the type of the eighth result
       * @param <RI> the type of the ninth result
       * @param <RJ> the type of the tenth result
       * @return a completed DAG with 10 inputs (placeholders) and 10 outputs (outputs).
       */
      public <RA, RB, RC, RD, RE, RF, RG, RH, RI, RJ> DAG10x10.Prepared<A, B, C, D, E, F, G, H, I, J, RA, RB, RC, RD, RE, RF, RG, RH, RI, RJ> withOutputs(
          Producer<? extends RA> output1, Producer<? extends RB> output2, Producer<? extends RC> output3,
          Producer<? extends RD> output4, Producer<? extends RE> output5, Producer<? extends RF> output6,
          Producer<? extends RG> output7, Producer<? extends RH> output8, Producer<? extends RI> output9,
          Producer<? extends RJ> output10) {
        Objects.requireNonNull(output1, "Output 1 may not be null");
        Objects.requireNonNull(output2, "Output 2 may not be null");
        Objects.requireNonNull(output3, "Output 3 may not be null");
        Objects.requireNonNull(output4, "Output 4 may not be null");
        Objects.requireNonNull(output5, "Output 5 may not be null");
        Objects.requireNonNull(output6, "Output 6 may not be null");
        Objects.requireNonNull(output7, "Output 7 may not be null");
        Objects.requireNonNull(output8, "Output 8 may not be null");
        Objects.requireNonNull(output9, "Output 9 may not be null");
        Objects.requireNonNull(output10, "Output 10 may not be null");

        if (_shouldRemapInputs) {
          Map<Producer<?>, Producer<?>> inputMapping =
              DAGUtil.createInputMap(_input1, _placeholder1, _input2, _placeholder2, _input3, _placeholder3, _input4,
                  _placeholder4, _input5, _placeholder5, _input6, _placeholder6, _input7, _placeholder7, _input8,
                  _placeholder8, _input9, _placeholder9, _input10, _placeholder10);
          output1 = DAGUtil.replaceInputs(output1, inputMapping);
          output2 = DAGUtil.replaceInputs(output2, inputMapping);
          output3 = DAGUtil.replaceInputs(output3, inputMapping);
          output4 = DAGUtil.replaceInputs(output4, inputMapping);
          output5 = DAGUtil.replaceInputs(output5, inputMapping);
          output6 = DAGUtil.replaceInputs(output6, inputMapping);
          output7 = DAGUtil.replaceInputs(output7, inputMapping);
          output8 = DAGUtil.replaceInputs(output8, inputMapping);
          output9 = DAGUtil.replaceInputs(output9, inputMapping);
          output10 = DAGUtil.replaceInputs(output10, inputMapping);
        }

        List<Producer<?>> inputs =
            Arrays.asList(_input1, _input2, _input3, _input4, _input5, _input6, _input7, _input8, _input9, _input10);

        return ((DAG10x10.Prepared) DAGUtil
            .createPreparedDAG(
                Arrays.asList(_placeholder1, _placeholder2, _placeholder3, _placeholder4, _placeholder5, _placeholder6,
                    _placeholder7, _placeholder8, _placeholder9, _placeholder10),
                Arrays
                    .asList(output1, output2, output3, output4, output5, output6, output7, output8, output9, output10))
            .internalAPI().withInputsUnsafe(inputs)).withReduction(_minimumReducerLevel);
      }
    }
  }
}
