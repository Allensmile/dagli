// AUTOGENERATED CODE.  DO NOT MODIFY DIRECTLY!  Instead, please modify the transformer/PreparedTransformerX.ftl file.
// See the README in the module's src/template directory for details.
package com.linkedin.dagli.transformer;

import java.util.ArrayList;
import java.util.Arrays;

import com.linkedin.dagli.dag.DAG;
import com.linkedin.dagli.dag.DAG3x1;
import com.linkedin.dagli.objectio.biglist.BigListWriter;
import com.linkedin.dagli.objectio.ObjectReader;
import com.linkedin.dagli.placeholder.Placeholder;
import com.linkedin.dagli.transformer.internal.PreparedTransformer3InternalAPI;
import com.linkedin.dagli.util.collection.Iterables;


public interface PreparedTransformer3<A, B, C, R> extends Transformer3<A, B, C, R>, PreparedTransformer<R> {

  /**
   * Applies the transformer to the given input values.
   *
   * This method must be thread-safe as it may be invoked concurrently on the same instance.
   *
   * @param value1 the first input value
   * @param value2 the second input value
   * @param value3 the third input value
   * @return the result of applying this transformer to the given example
   */
  R apply(A value1, B value2, C value3);

  /**
   * Applies the transformer to the given examples, provided as parallel {@link Iterable}s of values.  Each position
   * in each value list corresponds to a particular example; e.g. values1.get(5) is the first input value for the
   * 6th example.
   *
   * @param values1 the list of values for the first input
   * @param values2 the list of values for the second input
   * @param values3 the list of values for the third input
   * @return an {@link ObjectReader} containing the results of the transformation
   */
  default ObjectReader<R> applyAll(Iterable<? extends A> values1, Iterable<? extends B> values2,
      Iterable<? extends C> values3) {
    long count = Iterables.size64(values1);
    Object executionObject = internalAPI().createExecutionCache(count);

    int minibatchSize = (int) Math.min(count, Math.max(1024, internalAPI().getPreferredMinibatchSize()));
    ArrayList<R> resultBuffer = new ArrayList<>(minibatchSize);
    BigListWriter<R> result = new BigListWriter<>(count);

    ObjectReader
        .concatenate(Object[]::new, ObjectReader.wrap(values1), ObjectReader.wrap(values2), ObjectReader.wrap(values3))
        .lazyMap(Arrays::asList).forEachBatch(minibatchSize, batch -> {
          internalAPI().applyAllUnsafe(executionObject, batch.size(), batch, resultBuffer);
          result.writeAll(resultBuffer);
          resultBuffer.clear();
        });

    return result.createReader();
  }

  @Override
  PreparedTransformer3InternalAPI<A, B, C, R, ? extends PreparedTransformer3<A, B, C, R>> internalAPI();

  /**
   * Casts a prepared transformer to a "supertype".  This cast is safe due to the semantics of prepared transformers.
   *
   * @param prepared the prepared transformer to cast
   * @param <A> the new type of input #1
   * @param <B> the new type of input #2
   * @param <C> the new type of input #3
   * @param <R> the new result type
   * @return the provided {@code prepared}, cast to the desired "supertype"
   */
  @SuppressWarnings("unchecked")
  static <A, B, C, R> PreparedTransformer3<A, B, C, R> cast(
      PreparedTransformer3<? super A, ? super B, ? super C, ? extends R> prepared) {
    // safe due to semantics of prepared transformers:
    return (PreparedTransformer3<A, B, C, R>) prepared;
  }

  /**
   * Creates a trivial DAG that wraps the provided transformer, with the DAG retaining the transformer's existing
   * inputs or, if the transformer is already a DAG, simply returns it unaltered.
   *
   * @param transformer the transformer to wrap
   * @param <A> the type of transformer input #1
   * @param <B> the type of transformer input #2
   * @param <C> the type of transformer input #3
   * @param <R> the type of result produced by the transformer
   * @return a trivial DAG that wraps the provided transformer, or the transformer itself if it is already a DAG
   */
  static <A, B, C, R> DAG3x1.Prepared<A, B, C, R> toDAG(PreparedTransformer3<A, B, C, R> transformer) {
    if (transformer instanceof DAG3x1.Prepared) {
      return (DAG3x1.Prepared<A, B, C, R>) transformer;
    }

    Placeholder<A> placeholder1 = new Placeholder<>("Input #1");
    Placeholder<B> placeholder2 = new Placeholder<>("Input #2");
    Placeholder<C> placeholder3 = new Placeholder<>("Input #3");
    return DAG.Prepared
        .withPlaceholders(placeholder1, placeholder2, placeholder3)
        .withNoReduction()
        .withOutput(transformer.internalAPI().withInputs(placeholder1, placeholder2, placeholder3))
        .withAllInputs(transformer.internalAPI().getInput1(), transformer.internalAPI().getInput2(),
            transformer.internalAPI().getInput3());
  }
}
