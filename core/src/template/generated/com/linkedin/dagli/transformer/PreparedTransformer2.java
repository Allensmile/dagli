// AUTOGENERATED CODE.  DO NOT MODIFY DIRECTLY!  Instead, please modify the transformer/PreparedTransformerX.ftl file.
// See the README in the module's src/template directory for details.
package com.linkedin.dagli.transformer;

import java.util.ArrayList;
import java.util.Arrays;

import com.linkedin.dagli.dag.DAG;
import com.linkedin.dagli.dag.DAG2x1;
import com.linkedin.dagli.objectio.biglist.BigListWriter;
import com.linkedin.dagli.objectio.ObjectReader;
import com.linkedin.dagli.placeholder.Placeholder;
import com.linkedin.dagli.transformer.internal.PreparedTransformer2InternalAPI;
import com.linkedin.dagli.util.collection.Iterables;


public interface PreparedTransformer2<A, B, R> extends Transformer2<A, B, R>, PreparedTransformer<R> {

  /**
   * Applies the transformer to the given input values.
   *
   * This method must be thread-safe as it may be invoked concurrently on the same instance.
   *
   * @param value1 the first input value
   * @param value2 the second input value
   * @return the result of applying this transformer to the given example
   */
  R apply(A value1, B value2);

  /**
   * Applies the transformer to the given examples, provided as parallel {@link Iterable}s of values.  Each position
   * in each value list corresponds to a particular example; e.g. values1.get(5) is the first input value for the
   * 6th example.
   *
   * @param values1 the list of values for the first input
   * @param values2 the list of values for the second input
   * @return an {@link ObjectReader} containing the results of the transformation
   */
  default ObjectReader<R> applyAll(Iterable<? extends A> values1, Iterable<? extends B> values2) {
    long count = Iterables.size64(values1);
    Object executionObject = internalAPI().createExecutionCache(count);

    int minibatchSize = (int) Math.min(count, Math.max(1024, internalAPI().getPreferredMinibatchSize()));
    ArrayList<R> resultBuffer = new ArrayList<>(minibatchSize);
    BigListWriter<R> result = new BigListWriter<>(count);

    ObjectReader.concatenate(Object[]::new, ObjectReader.wrap(values1), ObjectReader.wrap(values2))
        .lazyMap(Arrays::asList).forEachBatch(minibatchSize, batch -> {
          internalAPI().applyAllUnsafe(executionObject, batch.size(), batch, resultBuffer);
          result.writeAll(resultBuffer);
          resultBuffer.clear();
        });

    return result.createReader();
  }

  @Override
  PreparedTransformer2InternalAPI<A, B, R, ? extends PreparedTransformer2<A, B, R>> internalAPI();

  /**
   * Casts a prepared transformer to a "supertype".  This cast is safe due to the semantics of prepared transformers.
   *
   * @param prepared the prepared transformer to cast
   * @param <A> the new type of input #1
   * @param <B> the new type of input #2
   * @param <R> the new result type
   * @return the provided {@code prepared}, cast to the desired "supertype"
   */
  @SuppressWarnings("unchecked")
  static <A, B, R> PreparedTransformer2<A, B, R> cast(PreparedTransformer2<? super A, ? super B, ? extends R> prepared) {
    // safe due to semantics of prepared transformers:
    return (PreparedTransformer2<A, B, R>) prepared;
  }

  /**
   * Creates a trivial DAG that wraps the provided transformer, with the DAG retaining the transformer's existing
   * inputs or, if the transformer is already a DAG, simply returns it unaltered.
   *
   * @param transformer the transformer to wrap
   * @param <A> the type of transformer input #1
   * @param <B> the type of transformer input #2
   * @param <R> the type of result produced by the transformer
   * @return a trivial DAG that wraps the provided transformer, or the transformer itself if it is already a DAG
   */
  static <A, B, R> DAG2x1.Prepared<A, B, R> toDAG(PreparedTransformer2<A, B, R> transformer) {
    if (transformer instanceof DAG2x1.Prepared) {
      return (DAG2x1.Prepared<A, B, R>) transformer;
    }

    Placeholder<A> placeholder1 = new Placeholder<>("Input #1");
    Placeholder<B> placeholder2 = new Placeholder<>("Input #2");
    return DAG.Prepared.withPlaceholders(placeholder1, placeholder2).withNoReduction()
        .withOutput(transformer.internalAPI().withInputs(placeholder1, placeholder2))
        .withAllInputs(transformer.internalAPI().getInput1(), transformer.internalAPI().getInput2());
  }
}
