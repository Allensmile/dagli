// AUTOGENERATED CODE.  DO NOT MODIFY DIRECTLY!  Instead, please modify the transformer/PreparableTransformerX.ftl file.
// See the README in the module's src/template directory for details.
package com.linkedin.dagli.transformer;

import com.linkedin.dagli.dag.DAG;
import com.linkedin.dagli.dag.DAG10x1;
import com.linkedin.dagli.dag.SimpleDAGExecutor;
import com.linkedin.dagli.preparer.PreparerContext;
import com.linkedin.dagli.preparer.PreparerResultMixed;
import com.linkedin.dagli.placeholder.Placeholder;
import com.linkedin.dagli.transformer.internal.PreparableTransformer10InternalAPI;
import com.linkedin.dagli.util.collection.Iterables;


public interface PreparableTransformer10<A, B, C, D, E, F, G, H, I, J, R, N extends PreparedTransformer10<A, B, C, D, E, F, G, H, I, J, R>>
    extends Transformer10<A, B, C, D, E, F, G, H, I, J, R>, PreparableTransformer<R, N> {

  @Override
  PreparableTransformer10InternalAPI<A, B, C, D, E, F, G, H, I, J, R, N, ? extends PreparableTransformer10<A, B, C, D, E, F, G, H, I, J, R, N>> internalAPI();

  /**
   * Casts a preparable transformer to a "supertype".  This cast is safe due to the semantics of preparable
   * transformers.
   *
   * @param preparable the preparable transformer to cast
   * @param <A> the new type of input #1
   * @param <B> the new type of input #2
   * @param <C> the new type of input #3
   * @param <D> the new type of input #4
   * @param <E> the new type of input #5
   * @param <F> the new type of input #6
   * @param <G> the new type of input #7
   * @param <H> the new type of input #8
   * @param <I> the new type of input #9
   * @param <J> the new type of input #10
   * @param <R> the new result type
   * @param <N> the new prepared transformer type
   * @return the provided {@code preparable}, cast to the desired "supertype"
   */
  @SuppressWarnings("unchecked")
  static <A, B, C, D, E, F, G, H, I, J, R, N extends PreparedTransformer10<A, B, C, D, E, F, G, H, I, J, R>> PreparableTransformer10<A, B, C, D, E, F, G, H, I, J, R, N> cast(
      PreparableTransformer10<? super A, ? super B, ? super C, ? super D, ? super E, ? super F, ? super G, ? super H, ? super I, ? super J, ? extends R, ? extends N> preparable) {
    // safe due to semantics of preparable transformers:
    return (PreparableTransformer10<A, B, C, D, E, F, G, H, I, J, R, N>) preparable;
  }

  /**
   * Casts a preparable transformer to a "supertype" with an unknown type of prepared transformer.  This cast is safe
   * due to the semantics of preparable transformers.
   *
   * @param preparable the preparable transformer to cast
   * @param <A> the new type of input #1
   * @param <B> the new type of input #2
   * @param <C> the new type of input #3
   * @param <D> the new type of input #4
   * @param <E> the new type of input #5
   * @param <F> the new type of input #6
   * @param <G> the new type of input #7
   * @param <H> the new type of input #8
   * @param <I> the new type of input #9
   * @param <J> the new type of input #10
   * @param <R> the new result type
   * @return the provided {@code preparable}, cast to the desired "supertype"
   */
  @SuppressWarnings("unchecked")
  static <A, B, C, D, E, F, G, H, I, J, R> PreparableTransformer10<A, B, C, D, E, F, G, H, I, J, R, PreparedTransformer10<A, B, C, D, E, F, G, H, I, J, R>> castWithGenericPrepared(
      PreparableTransformer10<? super A, ? super B, ? super C, ? super D, ? super E, ? super F, ? super G, ? super H, ? super I, ? super J, ? extends R, ?> preparable) {
    // safe due to semantics of preparable transformers:
    return (PreparableTransformer10<A, B, C, D, E, F, G, H, I, J, R, PreparedTransformer10<A, B, C, D, E, F, G, H, I, J, R>>) preparable;
  }

  /**
   * Prepares a preparable transformer and returns the result (which includes the prepared transformer for both the
   * "preparation" data (in this case, the values passed to this method) and "new" data.
   *
   * @param preparable the transformer to prepare
   * @param values1 the values for the first input to the transformer for each example
   * @param values2 the values for the second input to the transformer for each example
   * @param values3 the values for the third input to the transformer for each example
   * @param values4 the values for the fourth input to the transformer for each example
   * @param values5 the values for the fifth input to the transformer for each example
   * @param values6 the values for the sixth input to the transformer for each example
   * @param values7 the values for the seventh input to the transformer for each example
   * @param values8 the values for the eighth input to the transformer for each example
   * @param values9 the values for the ninth input to the transformer for each example
   * @param values10 the values for the tenth input to the transformer for each example
   * @param <A> the type of the first input
   * @param <B> the type of the second input
   * @param <C> the type of the third input
   * @param <D> the type of the fourth input
   * @param <E> the type of the fifth input
   * @param <F> the type of the sixth input
   * @param <G> the type of the seventh input
   * @param <H> the type of the eighth input
   * @param <I> the type of the ninth input
   * @param <J> the type of the tenth input
   * @param <R> the type of the result of the prepared transformers
   * @param <N> the type of the prepared transformer ("for new data")
   * @return a {@link PreparerResultMixed} containing the prepared transformers for "preparation data" (the provided
   *         values)
   */
  @SuppressWarnings("unchecked")
  static <A, B, C, D, E, F, G, H, I, J, R, N extends PreparedTransformer10<A, B, C, D, E, F, G, H, I, J, R>> PreparerResultMixed<PreparedTransformer10<A, B, C, D, E, F, G, H, I, J, R>, N> prepare(
      PreparableTransformer10<A, B, C, D, E, F, G, H, I, J, R, N> preparable, Iterable<? extends A> values1,
      Iterable<? extends B> values2, Iterable<? extends C> values3, Iterable<? extends D> values4,
      Iterable<? extends E> values5, Iterable<? extends F> values6, Iterable<? extends G> values7,
      Iterable<? extends H> values8, Iterable<? extends I> values9, Iterable<? extends J> values10) {
    return (PreparerResultMixed<PreparedTransformer10<A, B, C, D, E, F, G, H, I, J, R>, N>) preparable.internalAPI()
        .prepare(PreparerContext.builder(Iterables.size64(values1)).setExecutor(new SimpleDAGExecutor()).build(),
            values1, values2, values3, values4, values5, values6, values7, values8, values9, values10);
  }

  /**
   * Creates a trivial DAG that wraps the provided transformer, with the DAG retaining the transformer's existing
   * inputs or, if the transformer is already a DAG, simply returns it unaltered.
   *
   * @param transformer the transformer to wrap
   * @param <A> the type of transformer input #1
   * @param <B> the type of transformer input #2
   * @param <C> the type of transformer input #3
   * @param <D> the type of transformer input #4
   * @param <E> the type of transformer input #5
   * @param <F> the type of transformer input #6
   * @param <G> the type of transformer input #7
   * @param <H> the type of transformer input #8
   * @param <I> the type of transformer input #9
   * @param <J> the type of transformer input #10
   * @param <R> the type of result produced by the transformer
   * @return a trivial DAG that wraps the provided transformer, or the transformer itself if it is already a DAG
   */
  @SuppressWarnings("unchecked")
  static <A, B, C, D, E, F, G, H, I, J, R> DAG10x1<A, B, C, D, E, F, G, H, I, J, R> toDAG(
      PreparableTransformer10<A, B, C, D, E, F, G, H, I, J, R, ?> transformer) {
    if (transformer instanceof DAG10x1) {
      return (DAG10x1<A, B, C, D, E, F, G, H, I, J, R>) transformer;
    }

    Placeholder<A> placeholder1 = new Placeholder<>("Input #1");
    Placeholder<B> placeholder2 = new Placeholder<>("Input #2");
    Placeholder<C> placeholder3 = new Placeholder<>("Input #3");
    Placeholder<D> placeholder4 = new Placeholder<>("Input #4");
    Placeholder<E> placeholder5 = new Placeholder<>("Input #5");
    Placeholder<F> placeholder6 = new Placeholder<>("Input #6");
    Placeholder<G> placeholder7 = new Placeholder<>("Input #7");
    Placeholder<H> placeholder8 = new Placeholder<>("Input #8");
    Placeholder<I> placeholder9 = new Placeholder<>("Input #9");
    Placeholder<J> placeholder10 = new Placeholder<>("Input #10");
    return DAG
        .withPlaceholders(placeholder1, placeholder2, placeholder3, placeholder4, placeholder5, placeholder6,
            placeholder7, placeholder8, placeholder9, placeholder10)
        .withNoReduction()
        .withOutput(
            transformer.internalAPI().withInputs(placeholder1, placeholder2, placeholder3, placeholder4, placeholder5,
                placeholder6, placeholder7, placeholder8, placeholder9, placeholder10))
        .withAllInputs(transformer.internalAPI().getInput1(), transformer.internalAPI().getInput2(),
            transformer.internalAPI().getInput3(), transformer.internalAPI().getInput4(),
            transformer.internalAPI().getInput5(), transformer.internalAPI().getInput6(),
            transformer.internalAPI().getInput7(), transformer.internalAPI().getInput8(),
            transformer.internalAPI().getInput9(), transformer.internalAPI().getInput10());
  }
}
